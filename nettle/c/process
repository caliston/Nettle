/**
 * Processing code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "graphics.h"
#include "keyboard.h"
#include "lineedit.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "wimp.h"
#include "zapredraw.h"
#include "messages.h"

static struct session_struct *changedsession;
static struct coordspair changedbox;


void changedbox_init (struct session_struct *session)
{
  changedsession = session;
  changedbox.tl.x = 255;
  changedbox.tl.y = 255;
  changedbox.br.x = 0;
  changedbox.br.y = 0;
}

void changedbox_update (int cx0, int cy0, int cx1, int cy1)
{
  if (cx0 < changedbox.tl.x) changedbox.tl.x = cx0;
  if (cy0 < changedbox.tl.y) changedbox.tl.y = cy0;
  if (cx1 > changedbox.br.x) changedbox.br.x = cx1;
  if (cy1 > changedbox.br.y) changedbox.br.y = cy1;
}


void changedbox_update_char (int cx0, int cy0)
{
  if (cx0 < changedbox.tl.x) changedbox.tl.x = cx0;
  if (cy0 < changedbox.tl.y) changedbox.tl.y = cy0;
  if (cx0 > changedbox.br.x) changedbox.br.x = cx0;
  if (cy0 > changedbox.br.y) changedbox.br.y = cy0;
}


void changedbox_update_offset (int calc)
{
  int x = (calc / 4) % changedsession->terminal_size.x;
  int y = (calc / 4) / changedsession->terminal_size.x;
  changedbox_update_char (x, y);
}


void changedbox_update_whole (void)
{
  changedbox_update (0, changedsession->scrollback,
                    changedsession->terminal_size.x - 1,
                    changedsession->scrollback + changedsession->terminal_size.y - 1);
}


void force_redraw_changedbox (void)
{
  force_redraw (changedsession->window_handle,
                changedbox.tl.x * redraw.r_charw << eig.x,
                (-changedbox.br.y - 1) * redraw.r_charh << eig.y,
                (changedbox.br.x + 1) * redraw.r_charw << eig.x,
                -changedbox.tl.y * redraw.r_charh << eig.y);
}

static char status_positive(char iac_type)
{
  switch (iac_type)
  {
    case TELNET_WILL:
      return TELNET_DO;
      break;

    case TELNET_WONT:
      return TELNET_DONT;
      break;

    case TELNET_DO:
      return TELNET_WILL;
      break;

    case TELNET_DONT:
      return TELNET_WONT;
      break;
  }

  generror("Invalid IAC type",false);
  return 0;
}

static int status_negative(int iac_type)
{
  switch (iac_type)
  {
    case TELNET_WILL:
      return TELNET_DONT;
      break;

    case TELNET_WONT:
      return TELNET_DONT;
      break;

    case TELNET_DO:
      return TELNET_WONT;
      break;

    case TELNET_DONT:
      return TELNET_WONT;
      break;
  }

  generror("Invalid IAC type",false);
  return 0;
}

static void reprocess_position_scroll(struct session_struct *session)
{
  int count;
  int scrolled = 0;

  /* TODO: use Wimp_BlockCopy to scroll the (rendered) window contemt */

  /* scroll if y>scroll_end */

  while (session->pos.y>(session->scroll_end+session->scrollback-1))
  {
    session->pos.y--;
    scrolled = 1;

    if (session==selection_session)
    {
      selection_start-=session->terminal_size.x;
      selection_end-=session->terminal_size.x;
      if (selection_start<0)
      {
        selection_start=0;
      }
      if (selection_end<0)
      {
        selection_end=0;
      }
    }

    if (session->scroll_start==1)
    {
      /* scroll scrollback as well */

      MEMMOVE (
           session->assigned_area+(session->terminal_size.x*4),

           session->assigned_area,

           (session->terminal_size.x*
            (session->scroll_end+session->scrollback-1))*4);
    }
    else
    {
      char *calc = session->assigned_area +
                    ((session->terminal_size.x *
                     (session->scroll_start + session->scrollback)) * 4);
      MEMMOVE (calc, calc - session->terminal_size.x * 4,
               session->terminal_size.x *
              (session->scroll_end - session->scroll_start) * 4);
    }

    /* and clear the new line */
    for (count=0; count<session->terminal_size.x; count++)
    {
       int calc=(((session->scroll_end+session->scrollback-1)*
              session->terminal_size.x)+count)*4;

       write_assigned(session,calc,7,0,0,32);
    }

  }


  /* scroll if Y<scroll_start */

  while (session->pos.y<(session->scroll_start+
                                        session->scrollback-1))
  {
    session->pos.y++;
    scrolled = 1;

    if (selection_session)
    {
      selection_start+=session->terminal_size.x;
      selection_end+=session->terminal_size.x;
      if (selection_start>(session->terminal_size.x*
        		   (session->terminal_size.y+
        		    session->scrollback)))
      {
        selection_start=(session->terminal_size.x*
        		   (session->terminal_size.y+
        		    session->scrollback));
      }
      if (selection_end>(session->terminal_size.x*
        		   (session->terminal_size.y+
        		    session->scrollback)))
      {
        selection_end=(session->terminal_size.x*
        		   (session->terminal_size.y+
        		    session->scrollback));
      }
    }
    {
      char *calc = session->assigned_area +
		   ((session->terminal_size.x *
		     (session->scroll_start + session->scrollback)) * 4);
      MEMMOVE (calc - session->terminal_size.x * 4, calc,
	       session->terminal_size.x *
		 (session->scroll_end - session->scroll_start) * 4);
    }

    /* and clear the new line */
    for (count=0; count<session->terminal_size.x; count++)
    {
       int calc=(((session->scroll_start+session->scrollback-1)*
              session->terminal_size.x)+count)*4;

       write_assigned(session,calc,7,0,0,32);
    }
  }

  if (scrolled)
  {
    changedbox_update_whole ();
    /* also mark the scrollback area for redraw if necessary */
    if (session->scroll_start == 1)
      changedbox_update (0, 0,  session->terminal_size.x - 1, session->scrollback);
  }
}


static void reprocess_position(struct session_struct *session)
{
  /* this reshuffles everything so that everything is back on screen, this allows the cursor */
  /* to sit at  (81,24) without causing a newline (which would break pine and things) */
  /* It also shuffles up the selection areas */

  if (session->pos.x >= session->terminal_size.x)
  {
    if (session->other_session_flags & NETTLE_OTHER_WRAP_MODE)
    {
      session->pos.x=0;
      session->pos.y++;
      reprocess_position_scroll(session);
    }
    else
    {
      session->pos.x = session->terminal_size.x - 1;
    }
  }
}


static void row_shift_right (struct session_struct *session, int chars)
{
  char *start, *end;

  /* don't do too much */
  if (chars > session->terminal_size.x - session->pos.x)
    chars = session->terminal_size.x - session->pos.x;

  /* do nothing if cursor is at/beyond RHS */
  if (session->pos.x >= session->terminal_size.x)
    return;

  changedbox_update (session->pos.x, session->pos.y,
                     session->terminal_size.x - 1, session->pos.y);

  start = session->assigned_area +
          (session->pos.y * session->terminal_size.x + session->pos.x) * 4;
  end = session->assigned_area +
        (session->pos.y + 1) * session->terminal_size.x * 4;

  MEMMOVE (start, start + 4 * chars, end - start - 4 * chars);
}

static void work_out_character_character_set(struct session_struct *session,int character_set,
                                             int data, unsigned char byte)
{
  switch (character_set)
  {
    case NETTLE_CHSET_ASCII:
      write_assigned_character(session, data, byte);
      break;
    case NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS:
      write_assigned_character(session, data, byte | 0x80);
      break;
    case NETTLE_CHSET_UK_NATIONAL:
      if (byte!='#')
      {
        write_assigned_character(session, data, byte);
      }
      else
      {
        write_assigned_character(session, data, '£');
      }
      break;
    case NETTLE_CHSET_DEC_SPECIAL_GRAPHICS:
      {
        int graphics_byte=dec_graphics_table[byte];

        if (graphics_byte<0x100)
        {
          write_assigned_character(session, data, (char) graphics_byte);
        }
        else
        {
          write_assigned_flags(session, data, read_assigned_flags(session,data) |
                                                                          NETTLE_FLAG_PLUS100);
          write_assigned_character(session, data, (char) graphics_byte-0x100);
        }
      }
      break;
    case NETTLE_CHSET_DOWNLINE_LOADABLE:
      write_assigned_character(session, data, byte);
      break;
  }
}

static void work_out_character(struct session_struct *session, int data, unsigned char byte)
{
  int character_set_gl;
  int character_set_gr;

  switch (session->character_set_gl)
  {
    case NETTLE_CHSET_G0:
    default:
      character_set_gl=session->character_set_g0;
      break;

    case NETTLE_CHSET_G1:
      character_set_gl=session->character_set_g1;
      break;

    case NETTLE_CHSET_G2:
      character_set_gl=session->character_set_g2;
      break;

    case NETTLE_CHSET_G3:
      character_set_gl=session->character_set_g3;
      break;
  }

  switch (session->character_set_gr)
  {
    case NETTLE_CHSET_G0:
    default:
      character_set_gr=session->character_set_g0;
      break;

    case NETTLE_CHSET_G1:
      character_set_gr=session->character_set_g1;
      break;

    case NETTLE_CHSET_G2:
      character_set_gr=session->character_set_g2;
      break;

    case NETTLE_CHSET_G3:
      character_set_gr=session->character_set_g3;
      break;
  }

  if (byte<0x80)
  {
    work_out_character_character_set(session, character_set_gl, data, byte);
  }
  else
  {
    work_out_character_character_set(session, character_set_gr, data, byte & 0x7f);
  }
}


static void byte_null(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_enquiry(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_bell(struct session_struct *session)
{
  NOT_USED(session);

  /* Bell */
  _swi(OS_WriteI + 7, 0);
}

static void byte_backspace(struct session_struct *session)
{
  /* Backspace */
  if (session->pos.x>0)
    session->pos.x--;
}

static void byte_horizontal_tabulation(struct session_struct *session)
{
  /* Tab */
  int loop;
  int current_tab=session->terminal_size.x;

  for (loop=0; loop<session->number_of_tabs; loop++)
  {
    if (session->tabs[loop]>session->pos.x &&
        session->tabs[loop]<current_tab)
    {
      current_tab=session->tabs[loop];
    }
  }

  if (current_tab<session->terminal_size.x)
  {
    session->pos.x=current_tab;
  }
}

static void byte_linefeed(struct session_struct *session)
{
  /* LF,VT,FF */
  session->pos.y++;

  if (session->other_session_flags & NETTLE_OTHER_LINEFEED_MODE)
  {
    session->pos.x=0;
  }

  reprocess_position(session);
  reprocess_position_scroll(session);
}

static void byte_carriage_return(struct session_struct *session)
{
  /* CR */
  session->pos.x=0;
}

static void byte_shift_out(struct session_struct *session)
{
  session->character_set_gl=NETTLE_CHSET_G1;
}

static void byte_shift_in(struct session_struct *session)
{
  session->character_set_gl=NETTLE_CHSET_G0;
}

static void byte_device_control_1(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_device_control_3(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_cancel(struct session_struct *session)
{
  int data=((session->pos.y*session->terminal_size.x)+
             session->pos.x)*4;

  write_assigned(session,data,session->current_fg,
  				     session->current_bg,
  				     session->current_flags,
  				     '?');

  session->escape_state=NETTLE_ESCAPE_NONE;
  session->escape_string_length=0;
}

static void byte_substitute(struct session_struct *session)
{
  session->escape_state=NETTLE_ESCAPE_NONE;
  session->escape_string_length=0;
}

static void byte_escape(struct session_struct *session)
{
  /* ESCAPE */
  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length>=2)
    {
      if (session->escape_string[0]=='\x1B')
      {
        switch (session->escape_string[1])
        {
          case 'P': case '^': case '_': case ']':
            return;
            break;
        }
      }
    }
  }

  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string_length=1;
}

static void byte_delete(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_index(struct session_struct *session)
{
  /* Index */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='D';
  session->escape_string_length=2;
}

static void byte_next_line(struct session_struct *session)
{
  /* Next line */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='E';
  session->escape_string_length=2;
}

static void byte_horizontal_tab_set(struct session_struct *session)
{
  /* Horizontal tab set */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='H';
  session->escape_string_length=2;
}

static void byte_reverse_index(struct session_struct *session)
{
  /* Reverse index */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='M';
  session->escape_string_length=2;
}

static void byte_single_shift_g2(struct session_struct *session)
{
  /* Single shift G2 */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='N';
  session->escape_string_length=2;
}

static void byte_single_shift_g3(struct session_struct *session)
{
  /* Single shift G3 */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='O';
  session->escape_string_length=2;
}

static void byte_device_control_string(struct session_struct *session)
{
  /* Device control string */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='P';
  session->escape_string_length=2;
}

static void byte_control_sequence_intro(struct session_struct *session)
{
  /* Control sequence introducer */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='[';
  session->escape_string_length=2;
}

static void byte_string_terminator(struct session_struct *session)
{
  /* String terminator */
  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length>=2)
    {
      if (session->escape_string[0]=='\x1B')
      {
        if (session->escape_string[1]=='[')
        {
          session->escape_string[session->escape_string_length++]='\x1B';
          session->escape_string[session->escape_string_length++]='\\';
        }
      }
    }
  }
}


static void byte_telnet(struct session_struct *session)
{
  /* Telnet negotiation */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\xFF';
  session->escape_string_length=1;
}


static void byte_default(struct session_struct *session, char byte)
{
  int data;

  reprocess_position(session);

  if (session->other_session_flags & NETTLE_OTHER_INSERT_MODE)
  {
    /* If we're inserting a character, then shuffle all the characters along a byte */
    row_shift_right (session, 1);
  }

  changedbox_update_char (session->pos.x, session->pos.y);

  data = ((session->pos.y*session->terminal_size.x)+session->pos.x)*4;

  /* write out the data */
  write_assigned(session,data,session->current_fg,
                                     session->current_bg,
                                     session->current_flags,
                                     '?');

  work_out_character(session,data,byte);

  session->pos.x++;
}

static void clear_screen(struct session_struct *session, int calc, int calc2, char fg, char bg,
                         char flags, char character)
{
  int loop;

  /* clear the specified area with the specified fg,bg,flags and character */
  for (loop=calc; loop<calc2; loop+=4)
  {
    write_assigned(session,loop,fg,bg,flags,character);
  }
}


static void snap_cursor_to_terminal(struct session_struct *session)
{
  /* snaps the cursor inside the terminal */
  if (session->pos.x<0)
  {
    session->pos.x=0;
  }
  if (session->pos.x>=session->terminal_size.x)
  {
    session->pos.x=session->terminal_size.x-1;
  }

  if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
  {
    if (session->pos.y<session->scroll_start+
                                   session->scrollback-1)
    {
    session->pos.y=session->scroll_start+
                                 session->scrollback-1;
    }
    if (session->pos.y>session->scroll_end+
    				   session->scrollback-1)
    {
      session->pos.y=session->scroll_end+
    				   session->scrollback-1;
    }
  }
  else
  {
    if (session->pos.y<session->scrollback)
    {
    session->pos.y=session->scrollback;
    }
    if (session->pos.y>session->terminal_size.y+
    				   session->scrollback-1)
    {
      session->pos.y=session->terminal_size.y+
    				   session->scrollback-1;
    }
  }
}


static bool process_escape_length_2(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case '=':
          /* Selects application keypad mode */
          session->other_session_flags=session->other_session_flags | NETTLE_OTHER_APPLI_MODE;
          done=true;
          break;
        case '>':
          /* Selects numeric keypad mode */
          session->other_session_flags=session->other_session_flags & ~NETTLE_OTHER_APPLI_MODE;
          done=true;
          break;
        case '<':
          /* Enter ANSI mode */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            session->other_session_flags=session->other_session_flags & ~NETTLE_OTHER_VT52_MODE;
            done=true;
          }
          break;
        case '\\':
          /* End Device Control String (no effect here - this is to allow for variants of */
          /* title bar content changing) */
          done=true;
          break;
        case '7':
          /* Save cursor position */
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            session->old_pos.x=session->pos.x;
            session->old_pos.y=session->pos.y-session->scrollback;
            session->old_current_flags=session->current_flags;
            session->old_current_fg=session->current_fg;
            session->old_current_bg=session->current_bg;
            session->old_other_session_flags=session->other_session_flags;
            session->old_character_set_gl=session->character_set_gl;
            session->old_character_set_gr=session->character_set_gr;
            session->old_character_set_g0=session->character_set_g0;
            session->old_character_set_g1=session->character_set_g1;
            session->old_character_set_g2=session->character_set_g2;
            session->old_character_set_g3=session->character_set_g3;
            done=true;
          }
          break;
        case '8':
          /* Restore cursor position */
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            session->pos.x=session->old_pos.x;
            session->pos.y=session->old_pos.y+session->scrollback;
            session->current_flags=session->old_current_flags;
            session->current_fg=session->old_current_fg;
            session->current_bg=session->old_current_bg;
            session->other_session_flags=session->old_other_session_flags;
            session->character_set_gl=session->old_character_set_gl;
            session->character_set_gr=session->old_character_set_gr;
            session->character_set_g0=session->old_character_set_g0;
            session->character_set_g1=session->old_character_set_g1;
            session->character_set_g2=session->old_character_set_g2;
            session->character_set_g3=session->old_character_set_g3;
            snap_cursor_to_terminal(session);
            done=true;
          }
          break;
        case 'A':
          /* Cursor up (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->pos.y>session->scrollback)
              session->pos.y--;

            done=true;
          }
          break;
        case 'B':
          /* Cursor down (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->pos.y<session->terminal_size.y+session->scrollback+1)
              session->pos.y++;

            done=true;
          }
          break;
       case 'C':
          /* Cursor right (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->pos.x<session->terminal_size.x-1)
              session->pos.x++;

            done=true;
          }
          break;
        case 'D':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Move cursor left (in VT52 mode) */
            if (session->pos.x>0)
              session->pos.x--;
          }
          else
          {
            /* Moves cursor down one line (in non-VT52 mode) */
            session->pos.y++;
            reprocess_position_scroll(session);
          }
          done=true;
          break;
        case 'E':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            /* Carriage return and line feed */
            session->pos.y++;
            session->pos.x=0;
            reprocess_position(session);
            done=true;
          }
          break;
        case 'F':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Enter "graphics" Mode */
            done=true;
          }
          break;
        case 'G':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Exit "graphics" Mode */
            done=true;
          }
          break;
        case 'H':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Cursor to home (VT52 mode) */
            session->pos.x=0;
            session->pos.y=session->scrollback;
          }
          else
          {
            /* Set tab (non-VT52 mode) */
            if (session->number_of_tabs<MAX_TAB_NUMBER)
            {
              session->tabs[session->number_of_tabs]=session->pos.x;
              session->number_of_tabs++;
            }
            else
            {
              printf("Error: too many tabs, ignored\n");
            }
          }
          done=true;
          break;
        case 'I':
          /* Reverse line feed */
          session->pos.y--;
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            reprocess_position_scroll(session);
          }
          done=true;
          break;
        case 'J':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Erase to end of screen */
            changedbox_update (0, session->pos.y,
                               session->terminal_size.x - 1,
                               session->scrollback + session->terminal_size.y - 1);
            clear_screen(session,

                       ((session->pos.y*session->terminal_size.x)+
                       session->pos.x)*4,

                       (session->terminal_size.x*
                       (session->terminal_size.y+
                        session->scrollback))*4-4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);
            done=true;
          }
          break;
        case 'K':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Erase to end of line */
            changedbox_update (session->pos.x, session->pos.y,
                               session->terminal_size.x - 1, session->pos.y);
            clear_screen(session,

                       ((session->pos.y*session->terminal_size.x)+
                         session->pos.x)*4,

                       (session->pos.y+1)*
                       session->terminal_size.x*4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);
            done=true;
          }
          break;
        case 'M':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            session->pos.y--;
            reprocess_position_scroll(session);
            done=true;
          }
          break;
        case 'c':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            reset_terminal(session);
            session->pos.x=0;
            session->pos.y=session->scrollback;
            done=true;
          }
          break;
        case 'Z':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            char block[3];
            block[0]='\x1B';
            block[1]='/';
            block[2]='Z';
            nettle_senddata(session,block,3);
            done=true;
          }
          break;
      }
      break;
    case 255:
      switch (session->escape_string[1])
      {
        case TELNET_DATAMARK:
          done=true;
          break;
        case TELNET_GA:
          done=true;
          break;
        case TELNET_IAC:
          done=true;
          byte_default(session, 255);
          break;
      }
      break;
  }

  return done;
}

static void determine_character_set(struct session_struct *session)
{
  switch (session->escape_string[2])
  {
    case 'B':
      /* ASCII */
      switch (session->escape_string[1])
      {
        case '(':
          session->character_set_g0=NETTLE_CHSET_ASCII;
          break;
        case ')':
          session->character_set_g1=NETTLE_CHSET_ASCII;
          break;
        case '*':
          if (session->terminal_mode==2)
          {
            session->character_set_g2=NETTLE_CHSET_ASCII;
          }
          break;
        case '+':
          if (session->terminal_mode==2)
          {
            session->character_set_g3=NETTLE_CHSET_ASCII;
          }
          break;
      }
      break;
    case '<':
      /* DEC Supplemental graphics */
      if (session->terminal_mode==2)
      {
        switch (session->escape_string[2])
        {
          case '(':
            session->character_set_g0=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
          case ')':
            session->character_set_g1=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
          case '*':
            session->character_set_g2=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
          case '+':
            session->character_set_g3=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
        }
      }
      break;
    case 'A':
      /* UK National */
      if (session->terminal_mode==1)
      {
        switch (session->escape_string[1])
        {
          case '(':
            session->character_set_g0=NETTLE_CHSET_UK_NATIONAL;
            break;
          case ')':
            session->character_set_g1=NETTLE_CHSET_UK_NATIONAL;
            break;
        }
      }
      break;
    case '0':
      /* DEC Special Graphics */
      switch (session->escape_string[1])
      {
        case '(':
          session->character_set_g0=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          break;
        case ')':
          session->character_set_g1=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          break;
        case '*':
          if (session->terminal_mode==2)
          {
            session->character_set_g2=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          }
          break;
        case '+':
          if (session->terminal_mode==2)
          {
            session->character_set_g3=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          }
          break;
      }
      break;
  }
}

static bool process_escape_length_3(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case '(': case ')': case '*': case '+':
          determine_character_set(session);
          done=true;
          break;
        case '#':
          done=true;
          switch (session->escape_string[2])
          {
            case '3': case '4': case '5': case '6':
              /* various font size alterations - not supported */
              break;
            case '8':
              /* Clear screen with E's */
              changedbox_update_whole ();
              clear_screen(session,

                           session->scrollback*
                           session->terminal_size.x*4,

                           (session->terminal_size.x*
                           (session->terminal_size.y+
                            session->scrollback))*4-4,

                           session->current_fg,
                           session->current_bg,
                           0,
                           'E');
              break;
          }
          break;
      }
      break;
    case 255:
      {
        /* IAC */
        int iac_type=session->escape_string[1];


        switch (iac_type)
        {
          case TELNET_WILL:
          case TELNET_DO:
            done=true;

            switch (session->escape_string[2])
            {
              case TELOPT_ECHO:
              case TELOPT_TERMINAL_TYPE:
              case TELOPT_NAWS:
              case TELOPT_TERMINAL_SPEED:
                if (session->session_flags[(unsigned char) session->escape_string[2]]==false)
                {
                  char block[3];

                  block[0]=TELNET_IAC;
                  block[1]=status_positive(iac_type);
                  block[2]=session->escape_string[2];
                  nettle_senddata(session,block,3);

                }

                session->session_flags[(unsigned char) session->escape_string[2]]=true;

                if (session->escape_string[2]==31)
                {
                  char block[9];

                  block[0]=TELNET_IAC;
                  block[1]=TELNET_SB;
                  block[2]=TELOPT_NAWS;
                  block[3]=session->terminal_size.x / 256;
                  block[4]=session->terminal_size.x % 256;
                  block[5]=session->terminal_size.y / 256;
                  block[6]=session->terminal_size.y % 256;
                  block[7]=TELNET_IAC;
                  block[8]=TELNET_SE;
                  nettle_senddata(session,block,9);
                }

                break;
              default:
                {
                  char block[3];

                  block[0]=TELNET_IAC;
                  block[1]=status_negative(iac_type);
                  block[2]=session->escape_string[2];
                  nettle_senddata(session,block,3);

                  printf("For information: Telnet option %d, %d not supported\n",iac_type, session->escape_string[2]);
                }
                session->session_flags[(unsigned char) session->escape_string[2]]=false;
                break;
            }
            break;
          case TELNET_WONT:
          case TELNET_DONT:
            done=true;

            if (session->session_flags[(unsigned char) session->escape_string[2]]==true)
            {
              char block[3];

              block[0]=TELNET_IAC;
              block[1]=status_negative(iac_type);
              block[2]=session->escape_string[2];
              nettle_senddata(session,block,3);

            }
            session->session_flags[(unsigned char) session->escape_string[2]]=false;
            break;
        }
      }
      break;
  }

  return done;
}


static bool process_escape_length_x(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case 'Y':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->escape_string_length==4)
            {
              session->pos.x=session->escape_string[3]-32;
              session->pos.y=session->escape_string[2]-32+session->scrollback;
              done=true;
            }
          }
          break;
        case '[':
          switch (session->escape_string[session->escape_string_length-1])
          {
            case 'A':
              /* Cursor up Pn lines */
              if (session->escape_string[2]!='A')
              {
                int move=atoi(session->escape_string+2);
                session->pos.y -= move ? move : 1;
              }
              else
              {
                session->pos.y--;
              }
              if (session->pos.y<session->scrollback+session->scroll_start-1)
              {
                session->pos.y=session->scrollback+session->scroll_start-1;
              }
              done=true;
              break;
            case 'B':
              /* Cursor down Pn lines */
              if (session->escape_string[2]!='B')
              {
                int move=atoi(session->escape_string+2);
                session->pos.y += move ? move : 1;
              }
              else
              {
                session->pos.y++;
              }
              if (session->pos.y>session->scrollback+session->scroll_end-1)
              {
                session->pos.y=session->scrollback+session->scroll_end-1;
              }
              done=true;
              break;
            case 'C':
              /* Cursor right Pn chars */
              if (session->escape_string[2]!='C')
              {
                int move=atoi(session->escape_string+2);
                session->pos.x += move ? move : 1;
              }
              else
              {
                session->pos.x++;
              }
              if (session->pos.x>session->terminal_size.x-1)
              {
                session->pos.x=session->terminal_size.x-1;
              }
              done=true;
              break;
            case 'D':
              /* Cursor left Pn chars */
              if (session->escape_string[2]!='D')
              {
                int move=atoi(session->escape_string+2);
                session->pos.x -= move ? move : 1;
              }
              else
              {
                session->pos.x--;
              }
              if (session->pos.x<0)
              {
                session->pos.x=0;
              }
              done=true;
              break;
            case 'G':
              /* Cursor character absolute */
              if (session->escape_string[2]!='G')
              {
                session->pos.x = atoi(session->escape_string+2)-1;
              }
              else
              {
                session->pos.x=0;
              }
              if (session->pos.x>session->terminal_size.x-1)
              {
                session->pos.x=session->terminal_size.x-1;
              }
              done=true;
              break;
            case 'H': case 'f':
              /* Direct cursor addressing */
              if (esc_instr(session->escape_string,";", session->escape_string_length)>=0)
              {
                session->pos.x=atoi(session->escape_string+
                                                esc_instr(session->escape_string,
                                                ";",session->escape_string_length)
                                                +1)-1;

                if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
                {
                  session->pos.y=session->scrollback+
                   			       session->scroll_start-1+
                                             atoi(session->escape_string+2)-1;
                }
                else
                {
                  session->pos.y=session->scrollback+atoi(session->escape_string+2)-1;
                }
              }
              else
              {
                session->pos.x=0;
                if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
                {
                  session->pos.y=session->scrollback+session->scroll_start-1;
                }
                else
                {
                  session->pos.y=session->scrollback;
                }
              }
              snap_cursor_to_terminal(session);
              done=true;
              break;
            case 'J':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'J':
                  /* Clear screen from cursor to end of screen */
                  changedbox_update (0, session->pos.y,
                                     session->terminal_size.x - 1,
                                     session->scrollback + session->terminal_size.y - 1);
                  clear_screen(session,

                       ((session->pos.y*session->terminal_size.x)+
                       session->pos.x)*4,

                       (session->terminal_size.x*
                       (session->terminal_size.y+
                        session->scrollback))*4-4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);

                  break;
                case '1':
                  /* Clear screen from beginning of screen to cursor */
                  changedbox_update (0, 0, session->terminal_size.x - 1,
                                     session->pos.y);
                  clear_screen(session,

                       (session->scrollback*
                         session->terminal_size.x)*4,

                       ((session->pos.y*
                         session->terminal_size.x)+
                        session->pos.x)*4+4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);

                  break;
                case '2':
                  /* Clear screen */
                  changedbox_update_whole ();
                  clear_screen(session,

                       (session->scrollback*
                         session->terminal_size.x)*4,

                       (session->terminal_size.x*
                        (session->terminal_size.y+
                         session->scrollback))*4-4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);

                  break;
              }
              break;
            case 'K':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'K':
                  /* Clear line from cursor to end of line */
                  changedbox_update (session->pos.x, session->pos.y,
                                     session->terminal_size.x - 1, session->pos.y);
                  clear_screen(session,

                       ((session->pos.y*session->terminal_size.x)+
                         session->pos.x)*4,

                       (session->pos.y+1)*
                       session->terminal_size.x*4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);

                  break;
                case '1':
                  /* Clear from beginning of line to cursor */
                  changedbox_update (0, session->pos.y,
                                     session->pos.x, session->pos.y);
                  clear_screen(session,

                       (session->pos.y*session->terminal_size.x)*4,

                       ((session->pos.y*session->terminal_size.x)+
                        session->pos.x)*4+4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);

                  break;
                case '2':
                  /* Clear entire line */
                  changedbox_update (0, session->pos.y,
                                     session->terminal_size.x - 1, session->pos.y);
                  clear_screen(session,

                       (session->pos.y*session->terminal_size.x)*4,

                       ((session->pos.y+1)*
                        session->terminal_size.x)*4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);

                  break;
              }
              break;
            case 'L':
              /* Insert line(s) */
              if (session->pos.y-session->scrollback<session->scroll_end-1
                  &&
                  session->pos.y-session->scrollback>=session->scroll_start-1)
              {
                char *calc, *calc2;
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                calc = session->assigned_area+
                            (session->pos.y*session->terminal_size.x)*4;

                if (move>session->scroll_end-session->scroll_start-
                         (session->pos.y-session->scrollback-1)+1)
                {
                  move=session->scroll_end-session->scroll_start-
                       (session->pos.y-session->scrollback-1)+1;
                }

                calc2 = session->assigned_area+
                             ((session->pos.y+move)*session->terminal_size.x)*4;

                MEMMOVE (calc, calc2,
                                          ((session->scroll_end+session->scrollback-
                                            session->pos.y-move)*session->terminal_size.x*4));

                changedbox_update (0, session->pos.y,
                                   session->terminal_size.x - 1,
                                   session->scrollback + session->terminal_size.y - 1);

                clear_screen(session,
                             (session->pos.y*session->terminal_size.x)*4,

                             ((session->pos.y+move)*session->terminal_size.x)*4,

                             session->current_fg,
                             session->current_bg,
                             0,
                             32);
              }
              done=true;
              break;
            case 'M':
              /* Delete line(s) */
              if (session->pos.y-session->scrollback<session->scroll_end-1
                  &&
                  session->pos.y-session->scrollback>=session->scroll_start-1)
              {
                char *calc, *calc2;
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                calc = session->assigned_area+
                            (session->pos.y*session->terminal_size.x)*4;

                if (move>session->scroll_end-session->scroll_start-
                         (session->pos.y-session->scrollback-1)+1)
                {
                  move=session->scroll_end-session->scroll_start-
                       (session->pos.y-session->scrollback-1)+1;
                }

                calc2 = session->assigned_area+
                             ((session->pos.y+move)*session->terminal_size.x)*4;

                MEMMOVE (calc2, calc,
                                          ((session->scroll_end-(session->pos.y-
                                            session->scrollback)-move)*
                                            session->terminal_size.x*4));

                changedbox_update (0, session->pos.y,
                                   session->terminal_size.x - 1,
                                   session->scrollback + session->terminal_size.y - 1);

                clear_screen(session,
                             ((session->scrollback+session->scroll_end-move)*
                              session->terminal_size.x)*4,

                             ((session->scrollback+session->scroll_end)*
                              session->terminal_size.x)*4,

                             session->current_fg,
                             session->current_bg,
                             0,
                             32);
              }
              done=true;
              break;
            case 'P':
              {
                /* Delete character(s) */
                char *calc, *calc2;
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                calc = session->assigned_area+
                           ((session->pos.y*session->terminal_size.x)+
                           session->pos.x)*4;
                calc2 = session->assigned_area+
                            ((session->pos.y+1)*session->terminal_size.x)*4;

                MEMMOVE (calc+(4*move), calc, calc2-calc-(4*move));

                changedbox_update (session->pos.x, session->pos.y,
                                   session->terminal_size.x - 1, session->pos.y);

                clear_screen(session,

                             ((session->pos.y*session->terminal_size.x)+
                              (session->terminal_size.x-move))*4,

                              ((session->pos.y+1)*session->terminal_size.x)*4,

                              session->current_fg,
                              0, /* always black (ref. rxvt behaviour) */
                              0,
                              32);

                done=true;
              }
              break;
            case '@':
              {
                /* Insert character(s) */
                int move=atoi(session->escape_string+2);

                row_shift_right (session, move < 1 ? 1 : move);

                clear_screen(session,

                             ((session->pos.y*session->terminal_size.x)+
                              (session->pos.x))*4,

                              ((session->pos.y*session->terminal_size.x)+
                               (session->pos.x+(move < 1 ? 1 : move)))*4,

                              session->current_fg,
                              session->current_bg,
                              0,
                              32);

                done=true;
              }
              break;
            case 'X':
              /* Erase character(s) */
              {
                int move=atoi(session->escape_string+2);
                if (move == 0)
                  move = 1;
                changedbox_update (session->pos.x, session->pos.y,
                                   session->pos.x + move - 1, session->pos.y);
                clear_screen(session,
              	       ((session->pos.y*session->terminal_size.x)+
                       session->pos.x)*4,

              	       ((session->pos.y*session->terminal_size.x)+
                        session->pos.x + move) * 4 - 4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);
              }
              done=true;
              break;
            case 'c':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'c':
                  {
                    char block[16];

                    strcpy(block,"\x1B[?6x;1;6c");

                    block[4]=session->terminal_mode+48;

                    nettle_senddata(session,block,strlen(block));
                  }
                  break;
              }
              break;
            case 'g':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'g':
                  /* Clear tab in current xpos */
                  {
                    int loop=0;
                    while (loop<session->number_of_tabs &&
                           session->pos.x!=session->tabs[loop])
                    {
                      loop++;
                    }

                    if (session->pos.x==session->tabs[loop])
                    {
                      int loop2;
                      for (loop2=loop+1; loop2<session->number_of_tabs; loop2++)
                      {
                        session->tabs[loop2-1]=session->tabs[loop2];
                      }
                      session->number_of_tabs--;
                    }
                  }
                  break;
                case '3':
                  /* Clear all tabs */
                  session->number_of_tabs=0;
                  break;
              }
              break;
            case 'h':
              done=true;
              switch (session->escape_string[2])
              {
                case '?':
                  /* DIGITAL private modes */
                  {
                    int loop=3;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='h')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 1:
                          /* Cause the cursor to generate "application" control functions */
                          break;
                        case 3:
                          /* Selects 132 columns per line */
                          resize_terminal(session, 132,
                                                   session->terminal_size.y,
                                                   session->scrollback,
                                                   false);
                          break;
                        case 4:
                          /* Selects smooth scroll */
                          break;
                        case 5:
                          /* Selects reverse video */
                          session->other_session_flags |= NETTLE_OTHER_REVERSE_VIDEO;
                          break;
                        case 6:
                          /* Home position based in scrolling region */
                          session->other_session_flags |= NETTLE_OTHER_ORIGIN_MODE;

                          session->pos.x=0;
                          session->pos.y=session->scrollback+session->scroll_start-1;
                          break;
                        case 7:
                          /* Autowrap */
                          session->other_session_flags |= NETTLE_OTHER_WRAP_MODE;
                          break;
                        case 25:
                          /* Make cursor visible */
                          session->other_session_flags |= NETTLE_OTHER_CURSOR_VIS;
                          break;
                      }
                    }
                  }
                  break;
                default:
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='h')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 2:
                          /* Turn on keyboard lock */
                          session->other_session_flags |= NETTLE_OTHER_KEYLOCK_MODE;
                          break;
                        case 4:
                          /* Turn on insert mode */
                          session->other_session_flags |= NETTLE_OTHER_INSERT_MODE;
                          break;
                        case 8:
                          /* Turn on auto repeat */
                          break;
                        case 12:
                          /* Turn off local echo (NB. just using telnet's local echo stuff) */
                          session->session_flags[1]=true;
                          break;
                        case 20:
                          /* Make LF,FF,VT move to first column of next line */
                          session->other_session_flags |= NETTLE_OTHER_LINEFEED_MODE;
                          break;
                        case 67:
                          /* Make Backspace send BS and Delete send DEL */
                          session->other_session_flags |= NETTLE_OTHER_BACKSPACE_MODE;
                          break;
                      }
                    }
                  }
                  break;
              }
              break;
            case 'l':
              done=true;

              switch (session->escape_string[2])
              {
                case '?':
                  /* DIGITAL private modes */
                  {
                    int loop=3;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='l')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 1:
                          /* Cause the cursor to generate ANSI cursor control sequences */
                          break;
                        case 2:
                          /* Sets the terminal to VT52 mode */
                          session->other_session_flags |= NETTLE_OTHER_VT52_MODE;
                          break;
                        case 3:
                          /* Selects 80 columns per line */
                          resize_terminal(session, 80,
                                                   session->terminal_size.y,
                                                   session->scrollback,
                                                   false);
                          break;
                        case 4:
                          /* Selects jump scroll */
                          break;
                        case 5:
                          /* Selects normal video */
                          session->other_session_flags &= ~NETTLE_OTHER_REVERSE_VIDEO;
                          break;
                        case 6:
                          /* Home position based in top-left of screen */
                          session->other_session_flags &= ~NETTLE_OTHER_ORIGIN_MODE;
                          break;
                        case 7:
                          /* No autowrap */
                          session->other_session_flags &= ~NETTLE_OTHER_WRAP_MODE;
                          break;
                        case 8:
                          /* Turn off auto repeat */
                          break;
                        case 25:
                          /* Make cursor invisible */
                          session->other_session_flags &= ~NETTLE_OTHER_CURSOR_VIS;
                          break;
                      }
                    }
                  }
                  break;
                default:
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='l')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 2:
                          /* Turn off keyboard lock */
                          session->other_session_flags &= ~NETTLE_OTHER_KEYLOCK_MODE;
                          break;
                        case 4:
                          /* Turn off insert mode */
                          session->other_session_flags &= ~NETTLE_OTHER_INSERT_MODE;
                          break;
                        case 12:
                          /* Turn on local echo (NB. just using telnet's echo stuff) */
                          session->session_flags[1]=false;
                          break;
                        case 20:
                          /* Make LF,FF,VT move to next line (normal behaviour) */
                          session->other_session_flags &= ~NETTLE_OTHER_LINEFEED_MODE;
                          break;
                        case 67:
                          /* Make Backspace send Delete and Delete send ESC '[3~' (requires DeepKeys) */
                          session->other_session_flags &= ~NETTLE_OTHER_BACKSPACE_MODE;
                          break;
                      }
                    }
                  }
                  break;
              }
              break;
            case 'm':
              {
                bool status=false;
                int loop=2;

                done=true;

                if (session->current_fg & 8)
                {
                  status=true;
                }

                while (loop<session->escape_string_length)
                {
                  char string[256]="";
                  while(session->escape_string[loop]!=';' &&
                        session->escape_string[loop]!='m')
                  {
                    string[strlen(string)+1]='\0';
                    string[strlen(string)]=session->escape_string[loop];
                    loop++;
                  }
                  loop++;

	          switch (atoi(string))
	          {
	            case 0:
                      /* Clear all attributes */
                      status=false;
                      session->current_fg=7;
                      session->current_bg=0;
                      session->current_flags=0;
                      break;
                    case 1: case 5:
                      /* Bold, Blink */
                      session->current_fg |= 8;
                      status=true;
                      break;
                    case 27:
                      /* Cancel invert */
                      session->current_flags &= ~NETTLE_FLAG_INVERTED;
                     break;
                    case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
                      /* Foreground */
                      session->current_fg=atoi(string)-30;
                      if (status)
                      {
                        session->current_fg |= 8;
                      }
                      break;
                    case 39:
                      session->current_fg=7;
                      break;
                    case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:
                      /* Background */
                      session->current_bg=atoi(string)-40;
                      break;
                    case 49:
                      session->current_bg=0;
                      break;
                    case 7:
                      /* Invert */
                      session->current_flags |= NETTLE_FLAG_INVERTED;
                      break;
                  }
                }
              }
              break;
            case 'n':
              done=true;
              switch (session->escape_string[2])
              {
                case '5':
                  {
                    char block[4];
                    block[0]=27;
                    block[1]='[';
                    block[2]='0'; /* terminal OK */
                    block[3]='n';
                    nettle_senddata(session,block,sizeof(block));
                  }
                  break;
                case '6':
                  {
                    char block[16];
                    sprintf(block,"\x1B[%d;%dR",session->pos.y-
                    				session->scrollback+1,
                    				session->pos.x+1);
                    nettle_senddata(session,block,strlen(block));
                  }
                  break;
                case '?':
                  if (session->escape_string[3]=='1')
                  {
                    if (session->escape_string[4]=='5')
                    {
                      char block[7];

                      /* There is no printer */
                      strcpy(block,"\x1B[?13n");
                      nettle_senddata(session,block,strlen(block));
                    }
                  }
                  break;
              }
              break;
            case 'p':
              done=true;
              switch (session->escape_string[session->escape_string_length-2])
              {
                case '!':
                  /* Soft Reset terminal */
                  reset_terminal(session);
                  break;
                case '\"':
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='\"')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 61:
                          /* Set terminal to level 1 compatibility (VT100 mode) */
                          session->terminal_mode=1;
                          break;
                        case 62:
                          /* Set terminal to level 2 compatibility (VT200 mode) */
                          session->terminal_mode=2;
                          break;
                        case 0: case 2:
                          /* Set terminal to 8-bit mode */
                          session->bit_controls=true;
                          break;
                        case 1:
                          /* Set terminal to 7-bit mode */
                          session->bit_controls=false;
                          break;
                      }
                    }
                  }
                  break;
              }
              break;
            case 'r':
              /* Specify scrolling region */
              done=true;

              if (esc_instr(session->escape_string,";",session->escape_string_length)>=0)
              {
                session->scroll_start=atoi(session->escape_string+2);

                session->scroll_end=atoi(session->escape_string+
                                                esc_instr(session->escape_string,
                                                ";",session->escape_string_length)
                                                +1);
              }
              else
              {
                session->scroll_start=1;
                session->scroll_end=session->terminal_size.y;
              }

              if (session->scroll_start<1)
                session->scroll_start=1;

              if (session->scroll_end>session->terminal_size.y)
                session->scroll_end=session->terminal_size.y;

              if (session->pos.y<session->scrollback+session->scroll_start-1)
              {
                session->pos.y=session->scrollback+session->scroll_start-1;
              }

              if (session->pos.y>session->scrollback+session->scroll_end-1)
              {
                session->pos.y=session->scrollback+session->scroll_end-1;
              }

              break;
          }
          break;
        case ']':
          if (session->escape_string[session->escape_string_length-1]==7)
          {
            switch (atoi(session->escape_string+2))
            {
              case 0:
                /* Change Icon Name and Window Title to Pt */
                {
                  char string[256];
                  int loop=esc_instr(session->escape_string,
                                     ";", session->escape_string_length)+1;
                  int counter=0;

                  while (session->escape_string[loop]!=7)
                  {
                    string[counter]=session->escape_string[loop];
                    counter++;
                    loop++;
                  }
                  string[counter]='\0';
                  set_title_bar(session->window_handle,string);
                }
                break;
              case 1:
                /* Change Icon Name to Pt */
                break;
              case 2:
                /* Change Window Title to Pt */
                {
                  char string[256];
                  int loop=esc_instr(session->escape_string,
                                     ";", session->escape_string_length)+1;
                  int counter=0;

                  while (session->escape_string[loop]!=7)
                  {
                    string[counter]=session->escape_string[loop];
                    counter++;
                    loop++;
                  }
                  string[counter]='\0';
                  set_title_bar(session->window_handle,string);
                }
                break;
              case 46:
                /* Change Log File to Pt */
                break;
              case 50:
                /* Set Font to Pt */
                break;
            }

            done=true;
          }
          break;
      }
      break;
    case TELNET_IAC:
      switch (session->escape_string[1])
      {
        case TELNET_SB:
          if (session->escape_string[session->escape_string_length-2]==TELNET_IAC
              &&
              session->escape_string[session->escape_string_length-1]==TELNET_SE)
          {
            switch (session->escape_string[2])
            {
              case TELOPT_TERMINAL_TYPE:
                if (session->escape_string[3]==1)
                {
                  char block[256];
                  block[0]=TELNET_IAC;
                  block[1]=TELNET_SB;
                  block[2]=TELOPT_TERMINAL_TYPE;
                  block[3]=TELOPT_SUB_IS;
                  strcpy(block+4,terminal_name[session->terminal_type]);
                  block[4+strlen(terminal_name[session->terminal_type])]=TELNET_IAC;
                  block[5+strlen(terminal_name[session->terminal_type])]=TELNET_SE;
                  nettle_senddata(session,block,6+strlen(terminal_name[session->terminal_type]));
                  done=true;
                }
                break;
              case TELOPT_TERMINAL_SPEED:
                if (session->escape_string[3]==1)
                {
                  char block[256];
                  block[0]=TELNET_IAC;
                  block[1]=TELNET_SB;
                  block[2]=TELOPT_TERMINAL_SPEED;
                  block[3]=TELOPT_SUB_IS;
                  strcpy(block+4,"9600");
                  block[4+strlen("9600")]=TELNET_IAC;
                  block[5+strlen("9600")]=TELNET_SE;
                  nettle_senddata(session,block,6+strlen("9600"));
                  done=true;
                }
            }
          }
          break;
      }
      break;
  }
  return done;
}


static bool process_escape(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string_length)
  {
    case 0: case 1:
      /* strings of length 0 or 1 */
      done=false;
      break;
    case 2:
      /* strings of length 2 */
      done=process_escape_length_2(session);
      break;
    case 3:
      /* strings of length 3 */
      done=process_escape_length_3(session);
    default:
      /* strings of length >= 3 */
      if (!done)
      {
        done=process_escape_length_x(session);
      }
      break;
  }

  if (done)
  {
    session->escape_string_length=0;
    session->escape_state=NETTLE_ESCAPE_NONE;
  }

  return done;
}


void process_data(struct session_struct *session, char byte)
{
  bool done=false;

  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length==255)
    {
      generror(lookup_static ("esctoolong"), false);
      session->escape_state=NETTLE_ESCAPE_NONE;
      session->escape_string_length=0;
    }
    else
    {
      session->escape_string[session->escape_string_length]=byte;
      session->escape_string_length++;

      done = process_escape(session);
    }
  }

  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string[0]==TELNET_IAC)
    {
      return;
    }
  }

  if (!done)
  {
    switch (byte)
    {
      /* VT codes */
      case 0:   byte_null                  (session); break;
      case 1:                                         break;
      case 2:                                         break;
      case 3:                                         break;
      case 4:                                         break;
      case 5:   byte_enquiry               (session); break;
      case 7:   byte_bell                  (session); break;
      case 8:   byte_backspace             (session); break;
      case 9:   byte_horizontal_tabulation (session); break;
      case 10:
      case 11:
      case 12:  byte_linefeed              (session); break;
      case 13:  byte_carriage_return       (session); break;
      case 14:  byte_shift_out             (session); break;
      case 15:  byte_shift_in              (session); break;
      case 16:                                        break;
      case 17:  byte_device_control_1      (session); break;
      case 18:                                        break;
      case 19:  byte_device_control_3      (session); break;
      case 20:                                        break;
      case 21:                                        break;
      case 22:                                        break;
      case 23:                                        break;
      case 24:  byte_cancel                (session); break;
      case 25:                                        break;
      case 26:  byte_substitute            (session); break;
      case 27:  byte_escape                (session); break;
      case 28:                                        break;
      case 29:                                        break;
      case 30:                                        break;
      case 31:                                        break;
      case 127: byte_delete                (session); break;

      /* VT C1 codes */
      case 128:                                       break;
      case 129:                                       break;
      case 130:                                       break;
      case 131:                                       break;
      case 132: byte_index		   (session); break;
      case 133: byte_next_line		   (session); break;
      case 134:                                       break;
      case 135:                                       break;
      case 136: byte_horizontal_tab_set    (session); break;
      case 137:                                       break;
      case 138:                                       break;
      case 139:                                       break;
      case 140:                                       break;
      case 141: byte_reverse_index         (session); break;
      case 142: byte_single_shift_g2       (session); break;
      case 143: byte_single_shift_g3       (session); break;
      case 144: byte_device_control_string (session); break;
      case 145:                                       break;
      case 146:                                       break;
      case 147:                                       break;
      case 148:                                       break;
      case 149:                                       break;
      case 150:                                       break;
      case 151:                                       break;
      case 152:                                       break;
      case 153:                                       break;
      case 154:                                       break;
      case 155: byte_control_sequence_intro(session); break;
      case 156: byte_string_terminator     (session); break;
      case 157:                                       break;
      case 158:                                       break;
      case 159:                                       break;
      case 160:                                       break;

      /* Telnet codes */
      case 255: byte_telnet                (session); break;

      /* Other codes */
      default:
        if (session->escape_state==NETTLE_ESCAPE_NONE)
        {
                byte_default          (session, byte);
        }
        break;
    }
  }
}


void process_wimp_key(struct session_struct *session, int key, int extra)
{
  char block[256];
  int size_of_block=0;
  int calc;
  char cursor_flags;

  if (session->other_session_flags & NETTLE_OTHER_KEYLOCK_MODE)
    return;

  calc=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session,calc) & (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  cursor_flags |= NETTLE_FLAG_CURSOR;

  /* remove the cursor from the position */
  changedbox_init (session);
  changedbox_update_offset (calc);
  write_assigned_flags(session,calc,read_assigned_flags(session,calc)
						 & ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));
  force_redraw_changedbox ();

  changedbox_init (session);

  size_of_block = decode_key (session, key, extra, block);

  if (session->session_flags[1]==false)
  {
    int loop;
    int data;

    for (loop=0; loop<size_of_block; loop++)
    {
      switch (block[loop])
      {
        case 7: byte_bell                  (session); break;
        case 8: byte_backspace             (session);

          changedbox_update_char (session->pos.x, session->pos.y);
          data=((session->pos.y*session->terminal_size.x)+
             session->pos.x)*4;

          write_assigned(session,data,session->current_fg,
          				     session->current_bg,
          				     session->current_flags,
          				     32);
         break;

        case 9:  byte_horizontal_tabulation(session); break;
        case 10: byte_linefeed             (session); break;
        case 13: byte_carriage_return      (session); break;

        default:
          reprocess_position(session);

          data=((session->pos.y*session->terminal_size.x)+
             session->pos.x)*4;

          if (block[loop]<32)
          {
            changedbox_update_char (session->pos.x, session->pos.y);
            write_assigned(session,data,session->current_fg,
            				       session->current_bg,
            				       session->current_flags,
            				       '^');
            session->pos.x++;
            reprocess_position(session);

            data=((session->pos.y*session->terminal_size.x)+
                 session->pos.x)*4;
          }

          /* write out the data */
          changedbox_update_char (session->pos.x, session->pos.y);
          write_assigned(session,data,session->current_fg,
            				     session->current_bg,
            				     session->current_flags,
            				     '?');

          if (block[loop]<32)
          {
            write_assigned_character(session,data,block[loop]+64);
          }
          else
          {
            write_assigned_character(session,data,block[loop]);
          }
          session->pos.x++;

          break;
      }
    }
  }

  nettle_senddata(session,block,size_of_block);

  calc=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session,calc,read_assigned_flags(session,calc) | cursor_flags);
  }

  /* redraw the window */
  force_redraw_changedbox ();

  /* force the selection back on (it may have got overwritten by new data) */
  refresh_selection_set();
  force_redraw_selection();

  /* redraw the cursor, in case it isn't in the main redraw block */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    changedbox_init (session);
    changedbox_update_offset (calc);
    force_redraw_changedbox ();
  }
}


void process_line_editor(struct session_struct *session)
{
  char *icon_text;
  char block[256];
  int size_of_block=0;
  int calc;
  char cursor_flags;
  char *send_block=0;
  int size_of_send_block=0;
  int icon_text_loop;
  int line_editor_icon=(session->line_editor_type==LINEEDIT_CHECKBOX ? 1 : 0);

  {
    char data[512];

    read_icon_data(session->pane_handle, line_editor_icon, data, sizeof(data));

    icon_text = malloc(strlen(data) + 3);
    assert(icon_text != NULL);

    strcpy(icon_text, data);
    strcat(icon_text, "\r");
  }

  if (session->other_session_flags & NETTLE_OTHER_KEYLOCK_MODE)
    return;

  calc=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session,calc) & (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  cursor_flags |= NETTLE_FLAG_CURSOR;

  /* remove the cursor from the position */
  changedbox_init (session);
  changedbox_update_offset (calc);
  write_assigned_flags(session,calc,read_assigned_flags(session,calc)
						 & ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));
  force_redraw_changedbox ();

  changedbox_init (session);

  for (icon_text_loop=0; icon_text_loop<strlen(icon_text); icon_text_loop++)
  {
    int key=icon_text[icon_text_loop];

    size_of_block = decode_key (session, key, 0, block);

    if (session->session_flags[1]==false)
    {
      int data;
      int loop;

      for (loop=0; loop<size_of_block; loop++)
      {
        switch (block[loop])
        {
          case 7: byte_bell                  (session); break;
          case 8: byte_backspace             (session);

            changedbox_update_char (session->pos.x, session->pos.y);

            data=((session->pos.y*session->terminal_size.x)+
               session->pos.x)*4;

            write_assigned(session,data,session->current_fg,
            				       session->current_bg,
            				       session->current_flags,
            				       32);
            break;

          case 9:  byte_horizontal_tabulation(session); break;
          case 10: byte_linefeed             (session); break;
          case 13: byte_carriage_return      (session); break;

          default:
            reprocess_position(session);

            data=((session->pos.y*session->terminal_size.x)+
               session->pos.x)*4;

            if (block[loop]<32)
            {
              changedbox_update_char (session->pos.x, session->pos.y);
              write_assigned(session,data,session->current_fg,
              					 session->current_bg,
              					 session->current_flags,
              					 '^');
              session->pos.x++;
              reprocess_position(session);

              data=((session->pos.y*session->terminal_size.x)+
                   session->pos.x)*4;
            }

            /* write out the data */
            changedbox_update_char (session->pos.x, session->pos.y);
            write_assigned(session,data,session->current_fg,
              					 session->current_bg,
              					 session->current_flags,
              					 '?');

            if (block[loop]<32)
            {
              write_assigned_character(session,data,block[loop]+64);
            }
            else
            {
              work_out_character(session,data,block[loop]);
            }
            session->pos.x++;

            break;
        }
      }
    }
    send_block=realloc(send_block,size_of_send_block+size_of_block); /* FIXME: Dangerous use of realloc() */
    strncpy(send_block+size_of_send_block,block,size_of_block);
    size_of_send_block+=size_of_block;
  }

  nettle_senddata(session,send_block,size_of_send_block);

  calc=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session,calc,read_assigned_flags(session,calc) | cursor_flags);
  }

  /* redraw the window */
  force_redraw_changedbox ();

  /* force the selection back on (it may have got overwritten by new data) */
  refresh_selection_set();
  force_redraw_selection();

  /* redraw the cursor, in case it isn't in the main redraw block */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    changedbox_init (session);
    changedbox_update_offset (calc);
    force_redraw_changedbox ();
  }

  {
    int loop;

    for (loop=line_editor_size-1; loop>1; loop--)
    {
      strcpy(session->line_editor_history+(loop*512),
        	   session->line_editor_history+((loop-1)*512));
    }
  }

  strcpy(session->line_editor_history+(1*512),
         icon_text);

  set_icon_data(session->pane_handle,line_editor_icon,"");

  set_caret_position(session->pane_handle, line_editor_icon, -1, 0);

  session->line_editor_position=0;
  session->line_editor_total++;

  if (session->line_editor_total>line_editor_size)
  {
    session->line_editor_total=line_editor_size;
  }

  free(send_block);
  free(icon_text);
}


/* get the current cursor position */
int get_cursor_position(struct session_struct *session)
{
  int xpos = session->pos.x;

  /* get a sanitised x coordinate */
  if (xpos >= session->terminal_size.x)
    xpos = session->terminal_size.x - 1;

  /* return real offset or, if outside terminal, the last available offset */
  return (session->pos.y >= session->terminal_size.y + session->scrollback)
    ? (session->terminal_size.y + session->scrollback)
       * session->terminal_size.x * 4 - 4
    : ((session->pos.y * session->terminal_size.x) + xpos) * 4;
}
