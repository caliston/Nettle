/**
 * Processing code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "graphics.h"
#include "keyboard.h"
#include "lineedit.h"
#include "messages.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "spool.h"
#include "wimp.h"
#include "wimputil.h"
#include "zapredraw.h"

static struct session_struct *changedsession;
static struct coordspair changedbox;

static char csi_sequence[8];

void changedbox_init (struct session_struct *session)
{
  changedsession = session;
  changedbox.tl.x = 255;
  changedbox.tl.y = 255;
  changedbox.br.x = 0;
  changedbox.br.y = 0;
}

void changedbox_update (int cx0, int cy0, int cx1, int cy1)
{
  if (cx0 < changedbox.tl.x) changedbox.tl.x = cx0;
  if (cy0 < changedbox.tl.y) changedbox.tl.y = cy0;
  if (cx1 > changedbox.br.x) changedbox.br.x = cx1;
  if (cy1 > changedbox.br.y) changedbox.br.y = cy1;
}


void changedbox_update_char (int cx0, int cy0)
{
  if (cx0 < changedbox.tl.x) changedbox.tl.x = cx0;
  if (cy0 < changedbox.tl.y) changedbox.tl.y = cy0;
  if (cx0 > changedbox.br.x) changedbox.br.x = cx0;
  if (cy0 > changedbox.br.y) changedbox.br.y = cy0;
}


void changedbox_update_offset (int calc)
{
  int x = (calc / 4) % changedsession->terminal_size.x;
  int y = (calc / 4) / changedsession->terminal_size.x;
  changedbox_update_char (x, y);
}


void changedbox_update_whole (void)
{
  changedbox_update (0, changedsession->scrollback,
                    changedsession->terminal_size.x - 1,
                    changedsession->scrollback + changedsession->terminal_size.y - 1);
}


void force_redraw_changedbox (void)
{
  force_redraw (changedsession->window_handle,
                changedbox.tl.x * redraw.r_charw << eig.x,
                (-changedbox.br.y - 1) * redraw.r_charh << eig.y,
                (changedbox.br.x + 1) * redraw.r_charw << eig.x,
                -changedbox.tl.y * redraw.r_charh << eig.y);
}

static char status_positive(char iac_type)
{
  switch (iac_type)
  {
    case TELNET_WILL:
      return TELNET_DO;
      break;

    case TELNET_WONT:
      return TELNET_DONT;
      break;

    case TELNET_DO:
      return TELNET_WILL;
      break;

    case TELNET_DONT:
      return TELNET_WONT;
      break;
  }

  generror("Invalid IAC type",false);
  return 0;
}

static int status_negative(int iac_type)
{
  switch (iac_type)
  {
    case TELNET_WILL:
      return TELNET_DONT;
      break;

    case TELNET_WONT:
      return TELNET_DONT;
      break;

    case TELNET_DO:
      return TELNET_WONT;
      break;

    case TELNET_DONT:
      return TELNET_WONT;
      break;
  }

  generror("Invalid IAC type",false);
  return 0;
}

static void shuffle_up(struct session_struct *session, int start, int end)
{
  int *wrapped_line;
  int loop;

  /* copy the wrapped line to a temporary buffer */
  wrapped_line=session->assigned_area[start];

  for (loop=start+1; loop<end+1; loop++)
  {
    if (valid_y(session, loop-1) && valid_y(session, loop))
    {
      session->assigned_area[loop-1]=session->assigned_area[loop];
    }
  }

  session->assigned_area[end]=wrapped_line;
}

static void shuffle_down(struct session_struct *session, int start, int end)
{
  int *wrapped_line;
  int loop;

  /* copy the wrapped line to a temporary buffer */
  wrapped_line=session->assigned_area[end];

  for (loop=end; loop>start; loop--)
  {
    if (valid_y(session, loop) && valid_y(session, loop-1))
    {
      session->assigned_area[loop]=session->assigned_area[loop-1];
    }
  }

  session->assigned_area[start]=wrapped_line;
}

static void scroll_up(struct session_struct *session, bool wrap)
{
  if (selection_session == session)
  {
    selection_start-=session->terminal_size.x;
    selection_end-=session->terminal_size.x;
    if (selection_start<0)
      selection_start=0;
    if (selection_end<0)
      selection_end=0;
  }

  if (session->scroll_start==1 &&
      (session->other_session_flags & NETTLE_OTHER_SCREEN_MODE) == 0)
  {
    shuffle_up(session, 0, session->scrollback+session->scroll_end-1);
  }
  else
  {
    shuffle_up(session, session->scrollback+session->scroll_start-1,
                        session->scrollback+session->scroll_end-1);
  }

  /* and clear or restore the new line */
  if (!wrap)
  {
    /* wrap is false, clear the wrapped line */
    int count;

    for (count=0; count<session->terminal_size.x; count++)
    {
      write_assigned(session,
                     count,
                     session->scroll_end+session->scrollback-1,
                     7, 0, 0, 32);
    }
  }

  if (session->scroll_start == 1 &&
      (session->other_session_flags & NETTLE_OTHER_SCREEN_MODE) == 0)
    changedbox_update (0, 0,
                       session->terminal_size.x - 1,
                       session->scrollback + session->scroll_end - 1);
  else
    changedbox_update (0, session->scrollback + session->scroll_start - 1,
                       session->terminal_size.x - 1,
                       session->scrollback + session->scroll_end - 1);
}

static void scroll_down (struct session_struct *session, bool wrap)
{
  if (selection_session == session)
  {
    selection_start+=session->terminal_size.x;
    selection_end+=session->terminal_size.x;
    if (selection_start>(session->terminal_size.x*
			 (session->terminal_size.y+session->scrollback)))
    {
        selection_start=(session->terminal_size.x*
			 (session->terminal_size.y+session->scrollback));
    }

    if (selection_end>(session->terminal_size.x*
		       (session->terminal_size.y+session->scrollback)))
    {
      selection_end=(session->terminal_size.x*
		     (session->terminal_size.y+session->scrollback));
    }
  }

  shuffle_down(session, session->scrollback+session->scroll_start-1,
                        session->scrollback+session->scroll_end-1);

  /* and clear or restore the new line */
  if (!wrap)
  {
    /* wrap is false, clear the wrapped line */
    int count;

    for (count=0; count<session->terminal_size.x; count++)
    {
      write_assigned(session,
                     count,
                     session->scroll_start+session->scrollback-1,
                     7, 0, 0, 32);
    }
  }


  changedbox_update (0, session->scrollback + session->scroll_start - 1,
                     session->terminal_size.x - 1,
                     session->scrollback + session->scroll_end - 1);
}

static void reprocess_position_scroll(struct session_struct *session)
{
  /* scroll if y>scroll_end */

  while (session->pos.y>(session->scroll_end+session->scrollback-1))
  {
    session->pos.y--;
    scroll_up (session, false);
  }

  /* scroll if Y<scroll_start */

  while (session->pos.y<(session->scroll_start+session->scrollback-1))
  {
    session->pos.y++;
    scroll_down (session, false);
  }
}


static void reprocess_position(struct session_struct *session)
{
  /* this reshuffles everything so that everything is back on screen, this allows the cursor */
  /* to sit at  (81,24) without causing a newline (which would break pine and things) */
  /* It also shuffles up the selection areas */

  if (session->pos.x >= session->terminal_size.x)
  {
    if (session->other_session_flags & NETTLE_OTHER_WRAP_MODE)
    {
      session->pos.x=0;
      session->pos.y++;
      reprocess_position_scroll(session);
    }
    else
    {
      session->pos.x = session->terminal_size.x - 1;
    }
  }
}


static void row_shift_right (struct session_struct *session, int chars)
{
  int loop;

  /* don't do too much */
  if (chars > session->terminal_size.x - session->pos.x)
    chars = session->terminal_size.x - session->pos.x;

  /* do nothing if cursor is at/beyond RHS */
  if (session->pos.x >= session->terminal_size.x)
    return;

  changedbox_update (session->pos.x, session->pos.y,
                     session->terminal_size.x - 1, session->pos.y);

  for (loop=session->terminal_size.x-1; loop>session->pos.x+chars-1; loop--)
  {
    session->assigned_area[session->pos.y][loop]=
             session->assigned_area[session->pos.y][loop-chars];
  }
}

static void work_out_character_character_set(struct session_struct *session,int character_set,
                                             int xpos, int ypos, unsigned char byte)
{
  switch (character_set)
  {
    case NETTLE_CHSET_ASCII:
      write_assigned_character(session, xpos, ypos, byte);
      break;
    case NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS:
      write_assigned_character(session, xpos, ypos, byte | 0x80);
      break;
    case NETTLE_CHSET_UK_NATIONAL:
      if (byte!='#')
      {
        write_assigned_character(session, xpos, ypos, byte);
      }
      else
      {
        write_assigned_character(session, xpos, ypos, '£');
      }
      break;
    case NETTLE_CHSET_DEC_SPECIAL_GRAPHICS:
      {
        int graphics_byte=dec_graphics_table[byte];

        if (graphics_byte<0x100)
        {
          write_assigned_character(session, xpos, ypos, (char) graphics_byte);
        }
        else
        {
          write_assigned_flags(session, xpos, ypos,
                               read_assigned_flags(session, xpos, ypos) | NETTLE_FLAG_PLUS100);
          write_assigned_character(session, xpos, ypos, (char) graphics_byte-0x100);
        }
      }
      break;
    case NETTLE_CHSET_DOWNLINE_LOADABLE:
      write_assigned_character(session, xpos, ypos, byte);
      break;
  }
}

static void work_out_character(struct session_struct *session, int xpos, int ypos,
                               unsigned char byte)
{
  int character_set_gl;
  int character_set_gr;

  switch (session->character_set_gl)
  {
    case NETTLE_CHSET_G0:
    default:
      character_set_gl=session->character_set_g0;
      break;

    case NETTLE_CHSET_G1:
      character_set_gl=session->character_set_g1;
      break;

    case NETTLE_CHSET_G2:
      character_set_gl=session->character_set_g2;
      break;

    case NETTLE_CHSET_G3:
      character_set_gl=session->character_set_g3;
      break;
  }

  switch (session->character_set_gr)
  {
    case NETTLE_CHSET_G0:
    default:
      character_set_gr=session->character_set_g0;
      break;

    case NETTLE_CHSET_G1:
      character_set_gr=session->character_set_g1;
      break;

    case NETTLE_CHSET_G2:
      character_set_gr=session->character_set_g2;
      break;

    case NETTLE_CHSET_G3:
      character_set_gr=session->character_set_g3;
      break;
  }

  if (byte<0x80)
  {
    work_out_character_character_set(session, character_set_gl, xpos, ypos, byte);
  }
  else
  {
    work_out_character_character_set(session, character_set_gr, xpos, ypos, byte & 0x7f);
  }
}


static void byte_null(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_enquiry(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_bell(struct session_struct *session)
{
  NOT_USED(session);

  /* Bell */
  _swi(OS_WriteI + 7, 0);
}

static void byte_backspace(struct session_struct *session)
{
  /* Backspace */
  if (session->pos.x>0)
    session->pos.x--;
}

static void byte_horizontal_tabulation(struct session_struct *session)
{
  /* Tab */
  int loop;
  int current_tab=session->terminal_size.x;

  for (loop=0; loop<session->number_of_tabs; loop++)
  {
    if (session->tabs[loop]>session->pos.x &&
        session->tabs[loop]<current_tab)
    {
      current_tab=session->tabs[loop];
    }
  }

  if (current_tab<session->terminal_size.x)
  {
    session->pos.x=current_tab;
  }
  else
  {
    session->pos.x=session->terminal_size.x - 1;
  }
}

static void byte_reverse_horizontal_tabulation(struct session_struct *session)
{
  /* Tab */
  int loop;
  int current_tab=session->terminal_size.x;

  for (loop=session->number_of_tabs-1; loop>=0; loop--)
   {
    if (session->tabs[loop]<session->pos.x &&
        session->tabs[loop]>current_tab)
    {
      current_tab=session->tabs[loop];
    }
  }

  if (current_tab < session->terminal_size.x)
  {
    session->pos.x = current_tab;
  }
  else
  {
    session->pos.x = 0;
  }
}

static void byte_linefeed(struct session_struct *session)
{
  /* LF,VT,FF */
  session->pos.y++;

  if (session->other_session_flags & NETTLE_OTHER_LINEFEED_MODE)
  {
    session->pos.x=0;
  }

  /*reprocess_position(session);*/
  reprocess_position_scroll(session);
}

static void byte_carriage_return(struct session_struct *session)
{
  /* CR */
  session->pos.x=0;
}

static void byte_shift_out(struct session_struct *session)
{
  session->character_set_gl=NETTLE_CHSET_G1;
}

static void byte_shift_in(struct session_struct *session)
{
  session->character_set_gl=NETTLE_CHSET_G0;
}

static void byte_device_control_1(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_device_control_3(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_cancel(struct session_struct *session)
{
  write_assigned(session, session->pos.x, session->pos.y,
                 session->current_fg,
  		 session->current_bg,
  		 session->current_flags,
  		 '?');

  session->escape_state=NETTLE_ESCAPE_NONE;
  session->escape_string_length=0;
}

static void byte_substitute(struct session_struct *session)
{
  session->escape_state=NETTLE_ESCAPE_NONE;
  session->escape_string_length=0;
}

static void byte_escape(struct session_struct *session)
{
  /* ESCAPE */
  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length>=2)
    {
      if (session->escape_string[0]=='\x1B')
      {
        switch (session->escape_string[1])
        {
          case 'P': case '^': case '_': case ']':
            return;
            break;
        }
      }
    }
  }

  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string_length=1;
}

static void byte_delete(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_index(struct session_struct *session)
{
  /* Index */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='D';
  session->escape_string_length=2;
}

static void byte_next_line(struct session_struct *session)
{
  /* Next line */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='E';
  session->escape_string_length=2;
}

static void byte_horizontal_tab_set(struct session_struct *session)
{
  /* Horizontal tab set */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='H';
  session->escape_string_length=2;
}

static void byte_reverse_index(struct session_struct *session)
{
  /* Reverse index */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='M';
  session->escape_string_length=2;
}

static void byte_single_shift_g2(struct session_struct *session)
{
  /* Single shift G2 */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='N';
  session->escape_string_length=2;
}

static void byte_single_shift_g3(struct session_struct *session)
{
  /* Single shift G3 */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='O';
  session->escape_string_length=2;
}

static void byte_device_control_string(struct session_struct *session)
{
  /* Device control string */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='P';
  session->escape_string_length=2;
}

static void byte_control_sequence_intro(struct session_struct *session)
{
  /* Control sequence introducer */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='[';
  session->escape_string_length=2;
}

static void byte_string_terminator(struct session_struct *session)
{
  /* String terminator */
  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length>=2)
    {
      if (session->escape_string[0]=='\x1B')
      {
        if (session->escape_string[1]=='[')
        {
          session->escape_string[session->escape_string_length++]='\x1B';
          session->escape_string[session->escape_string_length++]='\\';
        }
      }
    }
  }
}


static void byte_telnet(struct session_struct *session)
{
  /* Telnet negotiation */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\xFF';
  session->escape_string_length=1;
}


static void byte_default(struct session_struct *session, char byte)
{
  reprocess_position(session);

  if (session->other_session_flags & NETTLE_OTHER_INSERT_MODE)
  {
    /* If we're inserting a character, then shuffle all the characters along a byte */
    row_shift_right (session, 1);
  }

  changedbox_update_char (session->pos.x, session->pos.y);

  /* write out the data */
  write_assigned(session, session->pos.x, session->pos.y,
                 session->current_fg,
                 session->current_bg,
                 session->current_flags,
                 '?');

  work_out_character(session, session->pos.x, session->pos.y, byte);

  session->pos.x++;
}

void clear_screen(struct session_struct *session, int calc, int calc2, char fg, char bg,
                  char flags, char character)
{
  int loop;

  /* clear the specified area with the specified fg,bg,flags and character */
  for (loop=calc; loop<calc2; loop+=4)
  {
    write_assigned(session,
                   (loop/4) % session->terminal_size.x,
                   (loop/4) / session->terminal_size.x,
                   fg, bg, flags, character);
  }
}

static void clear_alt_screen(struct session_struct *session, int calc, int calc2, char fg,
                             char bg,char flags, char character)
{
  int loop;

  /* clear the specified area with the specified fg,bg,flags and character */
  for (loop=calc; loop<calc2; loop+=4)
  {
    write_alt_assigned(session,
                      (loop/4) % session->terminal_size.x,
                      (loop/4) / session->terminal_size.x,
                      fg, bg, flags, character);
  }
}

static void snap_cursor_to_terminal(struct session_struct *session)
{
  /* snaps the cursor inside the terminal */
  if (session->pos.x<0)
  {
    session->pos.x=0;
  }
  if (session->pos.x>=session->terminal_size.x)
  {
    session->pos.x=session->terminal_size.x-1;
  }

  if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
  {
    if (session->pos.y<session->scroll_start+session->scrollback-1)
    {
    session->pos.y=session->scroll_start+session->scrollback-1;
    }
    if (session->pos.y>session->scroll_end+session->scrollback-1)
    {
      session->pos.y=session->scroll_end+session->scrollback-1;
    }
  }
  else
  {
    if (session->pos.y<session->scrollback)
    {
    session->pos.y=session->scrollback;
    }
    if (session->pos.y>session->terminal_size.y+session->scrollback-1)
    {
      session->pos.y=session->terminal_size.y+session->scrollback-1;
    }
  }
}

static void save_cursor_position (struct session_struct *session)
{
  session->old_pos.x=session->pos.x;
  session->old_pos.y=session->pos.y-session->scrollback;
  session->old_current_flags=session->current_flags;
  session->old_current_fg=session->current_fg;
  session->old_current_bg=session->current_bg;
  session->old_other_session_flags=session->other_session_flags;
  session->old_character_set_gl=session->character_set_gl;
  session->old_character_set_gr=session->character_set_gr;
  session->old_character_set_g0=session->character_set_g0;
  session->old_character_set_g1=session->character_set_g1;
  session->old_character_set_g2=session->character_set_g2;
  session->old_character_set_g3=session->character_set_g3;
}

static void restore_cursor_position (struct session_struct *session)
{
  session->pos.x=session->old_pos.x;
  session->pos.y=session->old_pos.y+session->scrollback;
  session->current_flags=session->old_current_flags;
  session->current_fg=session->old_current_fg;
  session->current_bg=session->old_current_bg;
  session->other_session_flags=session->old_other_session_flags;
  session->character_set_gl=session->old_character_set_gl;
  session->character_set_gr=session->old_character_set_gr;
  session->character_set_g0=session->old_character_set_g0;
  session->character_set_g1=session->old_character_set_g1;
  session->character_set_g2=session->old_character_set_g2;
  session->character_set_g3=session->old_character_set_g3;
  snap_cursor_to_terminal(session);
}

static void swap_alternate_main(struct session_struct *session)
{
  int xpos;
  int ypos;

  if (!session->alternate_area)
    return;

  for (ypos=0; ypos<session->terminal_size.y; ypos++)
  {
    for (xpos=0; xpos<session->terminal_size.x; xpos++)
    {
      /* Can make this more efficient */
      char fg       =read_alt_assigned_fg(session, xpos, ypos);
      char bg       =read_alt_assigned_bg(session, xpos, ypos);
      char flags    =read_alt_assigned_flags(session, xpos, ypos);
      char character=read_alt_assigned_character(session, xpos, ypos);

      write_alt_assigned(session, xpos, ypos,
                         read_assigned_fg(session, xpos, ypos+session->scrollback),
                         read_assigned_bg(session, xpos, ypos+session->scrollback),
                         read_assigned_flags(session, xpos, ypos+session->scrollback),
                         read_assigned_character(session, xpos, ypos+session->scrollback));

      write_assigned(session, xpos, ypos+session->scrollback, fg, bg, flags, character);
    }
  }
}

static void copy_alternate_main(struct session_struct *session)
{
  int xpos;
  int ypos;

  if (!session->alternate_area)
    return;

  for (ypos=0; ypos<session->terminal_size.y; ypos++)
  {
    for (xpos=0; xpos<session->terminal_size.x; xpos++)
    {
      /* Can make this more efficient */
      char fg       =read_alt_assigned_fg(session, xpos, ypos);
      char bg       =read_alt_assigned_bg(session, xpos, ypos);
      char flags    =read_alt_assigned_flags(session, xpos, ypos);
      char character=read_alt_assigned_character(session, xpos, ypos);
      write_assigned(session, xpos, ypos+session->scrollback, fg, bg, flags, character);
    }
  }
}

void copy_main_alternate(struct session_struct *session)
{
  int xpos;
  int ypos;

  if (!session->alternate_area)
    return;

  for (ypos=0; ypos<session->terminal_size.y; ypos++)
  {
    for (xpos=0; xpos<session->terminal_size.x; xpos++)
    {
      /* Can make this more efficient */
      char fg       =read_assigned_fg(session, xpos, ypos+session->scrollback);
      char bg       =read_assigned_bg(session, xpos, ypos+session->scrollback);
      char flags    =read_assigned_flags(session, xpos, ypos+session->scrollback);
      char character=read_assigned_character(session, xpos, ypos+session->scrollback);
      write_alt_assigned(session, xpos, ypos, fg, bg, flags, character);
    }
  }
}

static void clear_main_screen(struct session_struct *session)
{
  clear_screen(session, session->scrollback*session->terminal_size.x*4,
                        session->terminal_size.x*
                                 (session->terminal_size.y+session->scrollback)*4,
                        session->current_fg,
                        session->current_bg,
                        session->current_flags,
                        32);
}

static void clear_alternate_screen(struct session_struct *session)
{
  clear_alt_screen(session, 0,
                            session->terminal_size.x*session->terminal_size.y*4,
                            session->current_fg,
                            session->current_bg,
                            session->current_flags,
                            32);
}

static bool process_escape_length_2(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case '=':
          /* Selects application keypad mode */
          session->other_session_flags |= NETTLE_OTHER_APPLI_MODE;
          done=true;
          break;
        case '>':
          /* Selects numeric keypad mode */
          session->other_session_flags &= ~NETTLE_OTHER_APPLI_MODE;
          done=true;
          break;
        case '<':
          /* Enter ANSI mode */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            session->other_session_flags &= ~NETTLE_OTHER_VT52_MODE;
            done=true;
          }
          break;
        case '\\':
          /* End Device Control String (no effect here - this is to allow for variants of */
          /* title bar content changing) */
          done=true;
          break;
        case '7':
          /* Save cursor position */
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            save_cursor_position (session);
            done=true;
          }
          break;
        case '8':
          /* Restore cursor position */
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            restore_cursor_position (session);
            done=true;
          }
          break;
        case 'A':
          /* Cursor up (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->pos.y>session->scrollback)
              session->pos.y--;

            done=true;
          }
          break;
        case 'B':
          /* Cursor down (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->pos.y<session->terminal_size.y+session->scrollback-1)
              session->pos.y++;

            done=true;
          }
          break;
       case 'C':
          /* Cursor right (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->pos.x<session->terminal_size.x-1)
              session->pos.x++;

            done=true;
          }
          break;
        case 'D':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Move cursor left (in VT52 mode) */
            if (session->pos.x>0)
              session->pos.x--;
          }
          else
          {
            /* Moves cursor down one line (in non-VT52 mode) */
            session->pos.y++;
            reprocess_position_scroll(session);
          }
          done=true;
          break;
        case 'E':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            /* Carriage return and line feed */
            session->pos.y++;
            session->pos.x=0;
            reprocess_position(session);
            done=true;
          }
          break;
        case 'F':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Enter "graphics" Mode */
            done=true;
          }
          break;
        case 'G':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Exit "graphics" Mode */
            done=true;
          }
          break;
        case 'H':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Cursor to home (VT52 mode) */
            session->pos.x=0;
            session->pos.y=session->scrollback;
          }
          else
          {
            /* Set tab (non-VT52 mode) */
            if (session->number_of_tabs<MAX_TAB_NUMBER)
            {
              session->tabs[session->number_of_tabs]=session->pos.x;
              session->number_of_tabs++;
            }
            else
            {
              printf("Error: too many tabs, ignored\n");
            }
          }
          done=true;
          break;
        case 'I':
          /* Reverse line feed */
          session->pos.y--;
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            reprocess_position_scroll(session);
          }
          done=true;
          break;
        case 'J':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Erase to end of screen */
            changedbox_update (0, session->pos.y,
                               session->terminal_size.x - 1,
                               session->scrollback + session->terminal_size.y - 1);
            clear_screen(session,

                       ((session->pos.y*session->terminal_size.x)+
                       session->pos.x)*4,

                       (session->terminal_size.x*
                       (session->terminal_size.y+
                        session->scrollback))*4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);
            done=true;
          }
          break;
        case 'K':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Erase to end of line */
            changedbox_update (session->pos.x, session->pos.y,
                               session->terminal_size.x - 1, session->pos.y);
            clear_screen(session,

                       ((session->pos.y*session->terminal_size.x)+
                         session->pos.x)*4,

                       (session->pos.y+1)*session->terminal_size.x*4,

                       session->current_fg,
                       session->current_bg,
                       session->current_flags,
                       32);
            done=true;
          }
          break;
        case 'M':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            session->pos.y--;
            reprocess_position_scroll(session);
            done=true;
          }
          break;
        case 'c':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            reset_terminal(session);
            session->pos.x=0;
            session->pos.y=session->scrollback;
            done=true;
          }
          break;
        case 'Z':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            char block[3];
            block[0]='\x1B';
            block[1]='/';
            block[2]='Z';
            nettle_senddata(session,block,3);
            done=true;
          }
          break;
      }
      break;
    case 255:
      switch (session->escape_string[1])
      {
        case TELNET_DATAMARK:
          done=true;
          break;
        case TELNET_GA:
          done=true;
          break;
        case TELNET_IAC:
          byte_default(session, 255);
          done=true;
          break;
      }
      break;
  }

  return done;
}

static void determine_character_set(struct session_struct *session)
{
  switch (session->escape_string[2])
  {
    case 'B':
      /* ASCII */
      switch (session->escape_string[1])
      {
        case '(':
          session->character_set_g0=NETTLE_CHSET_ASCII;
          break;
        case ')':
          session->character_set_g1=NETTLE_CHSET_ASCII;
          break;
        case '*':
          if (session->terminal_mode==2)
          {
            session->character_set_g2=NETTLE_CHSET_ASCII;
          }
          break;
        case '+':
          if (session->terminal_mode==2)
          {
            session->character_set_g3=NETTLE_CHSET_ASCII;
          }
          break;
      }
      break;
    case '<':
      /* DEC Supplemental graphics */
      if (session->terminal_mode==2)
      {
        switch (session->escape_string[2])
        {
          case '(':
            session->character_set_g0=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
          case ')':
            session->character_set_g1=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
          case '*':
            session->character_set_g2=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
          case '+':
            session->character_set_g3=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
            break;
        }
      }
      break;
    case 'A':
      /* UK National */
      if (session->terminal_mode==1)
      {
        switch (session->escape_string[1])
        {
          case '(':
            session->character_set_g0=NETTLE_CHSET_UK_NATIONAL;
            break;
          case ')':
            session->character_set_g1=NETTLE_CHSET_UK_NATIONAL;
            break;
        }
      }
      break;
    case '0':
      /* DEC Special Graphics */
      switch (session->escape_string[1])
      {
        case '(':
          session->character_set_g0=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          break;
        case ')':
          session->character_set_g1=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          break;
        case '*':
          if (session->terminal_mode==2)
          {
            session->character_set_g2=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          }
          break;
        case '+':
          if (session->terminal_mode==2)
          {
            session->character_set_g3=NETTLE_CHSET_DEC_SPECIAL_GRAPHICS;
          }
          break;
      }
      break;
  }
}

static bool process_escape_length_3(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case ' ':
          /* Set C1 Control Transmission */
          if (session->terminal_type==2)
          {
            switch (session->escape_string[2])
            {
              case 'F':
                /* 7-bit */
                session->bit_controls=false;
                done=true;
                break;
              case 'G':
                /* 8-bit */
                session->bit_controls=true;
                done=true;
                break;
            }
          }
          break;
        case '(': case ')': case '*': case '+':
          determine_character_set(session);
          done=true;
          break;
        case '#':
          switch (session->escape_string[2])
          {
            case '3': case '4': case '5': case '6':
              /* various font size alterations - not supported */
              break;
            case '8':
              /* Clear screen with E's */
              changedbox_update_whole ();
              clear_screen(session,

                           session->scrollback*
                           session->terminal_size.x*4,

                           (session->terminal_size.x*
                           (session->terminal_size.y+
                            session->scrollback))*4,

                           session->current_fg,
                           session->current_bg,
                           0,
                           'E');
              break;
          }
          done=true;
          break;
      }
      break;
    case 255:
      {
        /* IAC */
        int iac_type=session->escape_string[1];

        switch (iac_type)
        {
          case TELNET_WILL:
          case TELNET_DO:
            switch (session->escape_string[2])
            {
              case TELOPT_ECHO:
              case TELOPT_TERMINAL_TYPE:
              case TELOPT_NAWS:
              case TELOPT_TERMINAL_SPEED:
                if (session->session_flags[(unsigned char) session->escape_string[2]]==false)
                {
                  char block[3];

                  block[0]=TELNET_IAC;
                  block[1]=status_positive(iac_type);
                  block[2]=session->escape_string[2];
                  nettle_senddata(session,block,3);

                }

                session->session_flags[(unsigned char) session->escape_string[2]]=true;

                if (session->escape_string[2]==31)
                {
                  char block[9];

                  block[0]=TELNET_IAC;
                  block[1]=TELNET_SB;
                  block[2]=TELOPT_NAWS;
                  block[3]=session->terminal_size.x / 256;
                  block[4]=session->terminal_size.x % 256;
                  block[5]=session->terminal_size.y / 256;
                  block[6]=session->terminal_size.y % 256;
                  block[7]=TELNET_IAC;
                  block[8]=TELNET_SE;
                  nettle_senddata(session,block,9);
                }

                break;
              default:
                {
                  char block[3];

                  block[0]=TELNET_IAC;
                  block[1]=status_negative(iac_type);
                  block[2]=session->escape_string[2];
                  nettle_senddata(session,block,3);

                  printf("For information: Telnet option %d, %d not supported\n",iac_type, session->escape_string[2]);
                }
                session->session_flags[(unsigned char) session->escape_string[2]]=false;
                break;
            }
            done=true;
            break;
          case TELNET_WONT:
          case TELNET_DONT:
            if (session->session_flags[(unsigned char) session->escape_string[2]]==true)
            {
              char block[3];

              block[0]=TELNET_IAC;
              block[1]=status_negative(iac_type);
              block[2]=session->escape_string[2];
              nettle_senddata(session,block,3);

            }
            session->session_flags[(unsigned char) session->escape_string[2]]=false;
            done=true;
            break;
        }
      }
      break;
  }

  return done;
}


static bool process_escape_length_x(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case 'Y':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->escape_string_length==4)
            {
              session->pos.x=session->escape_string[3]-32;
              session->pos.y=session->escape_string[2]-32+session->scrollback;
              done=true;
            }
          }
          break;
        case '[':
          switch (session->escape_string[session->escape_string_length-1])
          {
            case '?': case ';':
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
              break;
            case 'A':
              /* Cursor up Pn lines */
              if (session->escape_string[2]!='A')
              {
                int move=atoi(session->escape_string+2);
                session->pos.y -= move ? move : 1;
              }
              else
              {
                session->pos.y--;
              }
              if (session->pos.y<session->scrollback+session->scroll_start-1)
              {
                session->pos.y=session->scrollback+session->scroll_start-1;
              }
              done=true;
              break;
            case 'B':
              /* Cursor down Pn lines */
              if (session->escape_string[2]!='B')
              {
                int move=atoi(session->escape_string+2);
                session->pos.y += move ? move : 1;
              }
              else
              {
                session->pos.y++;
              }
              if (session->pos.y>session->scrollback+session->scroll_end-1)
              {
                session->pos.y=session->scrollback+session->scroll_end-1;
              }
              done=true;
              break;
            case 'C':
            case 'a':
              /* Cursor right Pn chars */
              if (session->escape_string[2]!='C')
              {
                int move=atoi(session->escape_string+2);
                session->pos.x += move ? move : 1;
              }
              else
              {
                session->pos.x++;
              }
              if (session->pos.x>session->terminal_size.x-1)
              {
                session->pos.x=session->terminal_size.x-1;
              }
              done=true;
              break;
            case 'D':
            case 'j':
              /* Cursor left Pn chars */
              if (session->escape_string[2]!='D')
              {
                int move=atoi(session->escape_string+2);
                session->pos.x -= move ? move : 1;
              }
              else
              {
                session->pos.x--;
              }
              if (session->pos.x<0)
              {
                session->pos.x=0;
              }
              done=true;
              break;
            case 'E':
            /*case 'k':*/
              /* Pn'th following line (no scroll) */
              {
                int move = atoi (session->escape_string + 2);
                session->pos.y += (move < 1) ? 1 : move;
              }
              snap_cursor_to_terminal(session);
              done=true;
              break;
            case 'F':
            case 'e':
              /* Pn'th preceding line (no scroll) */
              {
                int move = atoi (session->escape_string + 2);
                session->pos.y -= (move < 1) ? 1 : move;
              }
              snap_cursor_to_terminal(session);
              done=true;
              break;
            case 'G':
            case '`':
              /* Set cursor column */
              session->pos.x = atoi (session->escape_string + 2) - 1;
              snap_cursor_to_terminal(session);
              done=true;
              break;
            case 'H': case 'f':
              /* Direct cursor addressing */
              if (esc_instr(session->escape_string,";", session->escape_string_length)>=0)
              {
                session->pos.x=atoi(session->escape_string+
                                                esc_instr(session->escape_string,
                                                ";",session->escape_string_length)
                                                +1)-1;

                if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
                {
                  session->pos.y=session->scrollback+
                   			       session->scroll_start-1+
                                             atoi(session->escape_string+2)-1;
                }
                else
                {
                  session->pos.y=session->scrollback+atoi(session->escape_string+2)-1;
                }
              }
              else
              {
                session->pos.x=0;
                if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
                {
                  session->pos.y=session->scrollback+session->scroll_start-1;
                }
                else
                {
                  session->pos.y=session->scrollback;
                }
              }
              snap_cursor_to_terminal(session);
              done=true;
              break;
            case 'I':
              /* Cursor forward Pn tabs */
              {
                int move = atoi (session->escape_string + 2);
                if (move < 1)
                  move = 1;
                do {
                  byte_horizontal_tabulation (session);
                } while (--move);
              }
              done=true;
              break;
            case 'J':
              {
                int loop, limit = -1;
                loop = atoi (session->escape_string + 2
                             + (session->escape_string[2] == '?'));
                switch (loop)
                {
                  /* Various clears, leaving attributes */
                  case 0:
                    /* Clear screen from cursor to end of screen */
                    changedbox_update (0, session->pos.y,
                                       session->terminal_size.x - 1,
                                       session->scrollback
                                       + session->terminal_size.y - 1);
                    loop = (session->pos.y * session->terminal_size.x
                            + session->pos.x) * 4,
                    limit = session->terminal_size.x
                            * (session->terminal_size.y + session->scrollback)
                            * 4;
                    break;
                  case 1:
                    /* Clear screen from beginning of screen to cursor */
                    changedbox_update (0, 0, session->terminal_size.x - 1,
                                       session->pos.y);
                    loop = session->scrollback * session->terminal_size.x * 4;
                    limit = (session->pos.y * session->terminal_size.x
                             + session->pos.x) * 4 + 4;
                    break;
                  case 2:
                    /* Clear screen */
                    changedbox_update_whole ();
                    loop = session->scrollback * session->terminal_size.x * 4;
                    limit = session->terminal_size.x
                            * (session->terminal_size.y + session->scrollback)
                            * 4;
                    break;
               }
                if (limit == -1)
                  ;
                else if (session->escape_string[2] == '?')
                  for (; loop < limit; loop += 4)
                    write_assigned_character (session,
                                              (loop/4) % session->terminal_size.x,
                                              (loop/4) / session->terminal_size.x,
                                              ' ');
                else
                  clear_screen (session, loop, limit,
                                session->current_fg,
                                session->current_bg,
                                session->current_flags,
                                32);
              }
              done=true;
              break;
            case 'K':
              {
                int loop, limit = -1;
                loop = atoi (session->escape_string + 2
                             + (session->escape_string[2] == '?'));
                switch (loop)
                {
                  /* Various clears, leaving attributes */
                  case 0:
                    /* Clear line from cursor to end */
                    changedbox_update (session->pos.x, session->pos.y,
                                       session->terminal_size.x - 1,
                                       session->pos.y);
                    loop = (session->pos.y * session->terminal_size.x
                            + session->pos.x) * 4,
                    limit = session->terminal_size.x * (session->pos.y + 1) * 4;
                    break;
                  case 1:
                    /* Clear line from beginning to cursor */
                    changedbox_update (0, session->pos.y,
                                       session->pos.x, session->pos.y);
                    loop = session->pos.y * session->terminal_size.x * 4;
                    limit = (session->pos.y * session->terminal_size.x
                             + session->pos.x) * 4 + 4;
                    break;
                  case 2:
                    /* Clear line */
                    changedbox_update (0, session->pos.y,
                                       session->terminal_size.x - 1,
                                       session->pos.y);
                    loop = session->pos.y * session->terminal_size.x * 4;
                    limit = loop + session->terminal_size.x * 4;
                    break;
                }
                if (limit == -1)
                  ;
                else if (session->escape_string[2] == '?')
                  for (; loop < limit; loop += 4)
                    write_assigned_character (session,
                                              (loop/4) % session->terminal_size.x,
                                              (loop/4) / session->terminal_size.x,
                                              ' ');
                else
                  clear_screen (session, loop, limit,
                                session->current_fg,
                                session->current_bg,
                                session->current_flags,
                                32);
              }
              done=true;
              break;
            case 'L':
              /* Insert line(s) */
              if (session->pos.y-session->scrollback<session->scroll_end-1
                  &&
                  session->pos.y-session->scrollback>=session->scroll_start-1)
              {
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                if (move>session->scroll_end-(session->pos.y-session->scrollback))
                {
                  move=session->scroll_end-(session->pos.y-session->scrollback);
                }

                while (move>0)
                {
                  shuffle_down(session, session->pos.y,
                                        session->scrollback+session->scroll_end-1);

                  clear_screen(session,
                               session->pos.y*session->terminal_size.x*4,
                               (session->pos.y+1)*session->terminal_size.x*4,
                               session->current_fg,
                               session->current_bg,
                               0,
                               ' ');

                  move--;
                }

                changedbox_update (0, session->pos.y,
                                   session->terminal_size.x - 1,
                                   session->scrollback + session->terminal_size.y - 1);
              }
              done=true;
              break;
            case 'M':
              /* Delete line(s) */
              if (session->pos.y-session->scrollback<session->scroll_end-1
                  &&
                  session->pos.y-session->scrollback>=session->scroll_start-1)
              {
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                if (move>session->scroll_end-(session->pos.y-session->scrollback))
                {
                  move=session->scroll_end-(session->pos.y-session->scrollback);
                }

                while (move>0)
                {
                  shuffle_up(session, session->pos.y,
                                        session->scrollback+session->scroll_end-1);

                  clear_screen(session,
                               (session->scrollback+session->scroll_end-1)*
                                         session->terminal_size.x*4,
                               (session->scrollback+session->scroll_end)*
                                         session->terminal_size.x*4,
                               session->current_fg,
                               session->current_bg,
                               0,
                               ' ');

                  move--;
                }

                changedbox_update (0, session->pos.y,
                                   session->terminal_size.x - 1,
                                   session->scrollback + session->terminal_size.y - 1);
              }
              done=true;
              break;
            case 'N':
              /* Erase in field */
              /* ... definition of "active field"? */
              done = true;
              break;
            case 'O':
              /* Erase in area */
              /* ... definition of "active qualified area"? */
              done = true;
              break;
            case 'P':
              {
                /* Delete character(s) */
                int loop;
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                for (loop=session->pos.x; loop<session->terminal_size.x-move; loop++)
                {
                  session->assigned_area[session->pos.y][loop]=
                           session->assigned_area[session->pos.y][loop+move];
                }

                changedbox_update (session->pos.x, session->pos.y,
                                   session->terminal_size.x - 1, session->pos.y);

                clear_screen(session,

                             ((session->pos.y*session->terminal_size.x)+
                              (session->terminal_size.x-move))*4,

                              ((session->pos.y+1)*session->terminal_size.x)*4,

                              session->current_fg,
                              0,
                              0,
                              32);
              }
              done=true;
              break;
            case 'Q':
              /* Select editing extent */
              /* Affects various insert/delete commands */
              done = true;
              break;
            case 'S':
              /* Scroll up (with wraparound) */
              {
                int move=atoi(session->escape_string+2);
                if (move < 1)
                  move = 1;

                /* limit things a little... */
                if (session->scroll_start == 1 &&
                    (session->other_session_flags & NETTLE_OTHER_SCREEN_MODE) == 0)
                {
                  if (move > session->scrollback + session->terminal_size.y)
                    move = session->scrollback + session->terminal_size.y;
                }
                else
                  if (move > session->terminal_size.y)
                    move = session->terminal_size.y;

                do
                {
                  scroll_up (session, true);
                } while (--move);
              }
              done = true;
              break;
            case 'T':
              /* Scroll down (with wraparound) */
              {
                int move=atoi(session->escape_string+2);
                if (move < 1)
                  move = 1;

                /* limit things a little... */
                if (move > session->terminal_size.y)
                  move = session->terminal_size.y;

                do
                {
                  scroll_down (session, true);
                } while (--move);
              }
              done = true;
              break;
            case 'U':
              /* Pn'th following page */
              done = true;
              break;
            case 'V':
              /* Pn'th preceding page */
              done = true;
              break;
            case 'W':
              /* tabulation control */
              done = true;
              break;
            case '@':
              {
                /* Insert character(s) */
                int move=atoi(session->escape_string+2);

                row_shift_right (session, move < 1 ? 1 : move);

                clear_screen(session,

                             ((session->pos.y*session->terminal_size.x)+
                              (session->pos.x))*4,

                              ((session->pos.y*session->terminal_size.x)+
                               (session->pos.x+(move < 1 ? 1 : move)))*4,

                              session->current_fg,
                              session->current_bg,
                              0,
                              32);

                done=true;
              }
              break;
            case 'X':
              /* Erase character(s) */
              {
                int move=atoi(session->escape_string+2);
                if (move == 0)
                  move = 1;
                if (session->pos.x + move >= session->terminal_size.x)
                  move = session->terminal_size.x - session->pos.x;

                changedbox_update (session->pos.x, session->pos.y,
                                   session->pos.x + move, session->pos.y);
                clear_screen(session,
              	       ((session->pos.y*session->terminal_size.x)+
                       session->pos.x)*4,

              	       ((session->pos.y*session->terminal_size.x)+
                        session->pos.x + move) * 4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);
              }
              done=true;
              break;
            case 'Z':
              /* Cursor backward Pn tabs */
              {
                int move = atoi (session->escape_string + 2);
                if (move < 1)
                  move = 1;
                do {
                  byte_reverse_horizontal_tabulation (session);
                } while (--move);
              }
              done=true;
              break;
            case 'b':
              /* Repeat preceding character Pn times */
              done = true;
              break;
            case 'c':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'c':
                  {
                    /* Primary DA Request */
                    char block[16];

                    sprintf(block,"%s?6x;1;6c",csi_sequence);

                    block[2+strlen(csi_sequence)]=session->terminal_mode+48;

                    nettle_senddata(session,block,strlen(block));
                  }
                  break;
                case '>':
                  switch (session->escape_string[3])
                  {
                    case '0': case 'c':
                      {
                        /* Secondary DA Request */
                        char block[16];

                        sprintf(block,"%s>1;10;0c",csi_sequence);

                        nettle_senddata(session,block,strlen(block));
                      }
                      break;
                  }
                  break;
              }
              break;
            case 'd':
              /* Set cursor row */
              session->pos.y = session->scrollback + atoi (session->escape_string + 2) - 1;
              snap_cursor_to_terminal(session);
              done=true;
              break;
            case 'g':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'g':
                  /* Clear tab in current xpos */
                  {
                    int loop=0;
                    while (loop<session->number_of_tabs &&
                           session->pos.x!=session->tabs[loop])
                    {
                      loop++;
                    }

                    if (session->pos.x==session->tabs[loop])
                    {
                      int loop2;
                      for (loop2=loop+1; loop2<session->number_of_tabs; loop2++)
                      {
                        session->tabs[loop2-1]=session->tabs[loop2];
                      }
                      session->number_of_tabs--;
                    }
                  }
                  break;
                case '3':
                  /* Clear all tabs */
                  session->number_of_tabs=0;
                  break;
              }
              break;
            case 'h':
              switch (session->escape_string[2])
              {
                case '?':
                  /* DIGITAL, xterm private modes */
                  {
                    int loop=3;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='h')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 1:
                          /* Cause the cursor to generate "application" control functions */
                          break;
                        case 3:
                          /* Selects 132 columns per line */
                          if (!(session->other_session_flags & NETTLE_OTHER_COLUMN_MODE))
                          {
                            resize_terminal(session, 132,
                                                     session->terminal_size.y,
                                                     session->scrollback,
                                                     false);
                            session->other_session_flags |= NETTLE_OTHER_COLUMN_MODE;
                          }
                          break;
                        case 4:
                          /* Selects smooth scroll */
                          break;
                        case 5:
                          /* Selects reverse video */
                          session->other_session_flags |= NETTLE_OTHER_REVERSE_VIDEO;
                          changedbox_update_whole();
                          break;
                        case 6:
                          /* Home position based in scrolling region */
                          session->other_session_flags |= NETTLE_OTHER_ORIGIN_MODE;

                          session->pos.x=0;
                          session->pos.y=session->scrollback+session->scroll_start-1;
                          break;
                        case 7:
                          /* Autowrap */
                          session->other_session_flags |= NETTLE_OTHER_WRAP_MODE;
                          break;
                        case 25:
                          /* Make cursor visible */
                          session->other_session_flags |= NETTLE_OTHER_CURSOR_VIS;
                          break;
                        case 47:
                        case 1047:
                          /* Alternate screen mode (xterm) */
                          if (!(session->other_session_flags & NETTLE_OTHER_SCREEN_MODE))
                          {
                            swap_alternate_main (session);
                            changedbox_update (0, session->scrollback,
                                               session->terminal_size.x - 1,
                                               session->scrollback +
                                                        session->terminal_size.y - 1);
                            session->other_session_flags |= NETTLE_OTHER_SCREEN_MODE;
                          }
                          break;
                        case 67:
                          /* Make Backspace send BS and Delete send DEL */
                          session->other_session_flags |= NETTLE_OTHER_BACKSPACE_MODE;
                          break;
                        case 1048:
                          save_cursor_position (session);
                          break;
                        case 1049:
                          /* Alternate screen, save cursor, clear (xterm) */
                          if (!(session->other_session_flags & NETTLE_OTHER_SCREEN_MODE))
                          {
                            save_cursor_position (session);
                            copy_main_alternate (session);
                            clear_main_screen (session);
                            changedbox_update (0, session->scrollback,
                                               session->terminal_size.x - 1,
                                               session->scrollback +
                                                        session->terminal_size.y - 1);
                            session->other_session_flags |= NETTLE_OTHER_SCREEN_MODE;
                          }
                          break;
                      }
                    }
                  }
                  break;
                default:
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='h')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 2:
                          /* Turn on keyboard lock */
                          session->other_session_flags |= NETTLE_OTHER_KEYLOCK_MODE;
                          break;
                        case 4:
                          /* Turn on insert mode */
                          session->other_session_flags |= NETTLE_OTHER_INSERT_MODE;
                          break;
                        case 8:
                          /* Turn on auto repeat */
                          break;
                        case 12:
                          /* Turn off local echo (NB. just using telnet's local echo stuff) */
                          session->session_flags[1]=true;
                          break;
                        case 20:
                          /* Make LF,FF,VT move to first column of next line */
                          session->other_session_flags |= NETTLE_OTHER_LINEFEED_MODE;
                          break;
                      }
                    }
                  }
                  break;
              }
              done=true;
              break;
            case 'l':
              switch (session->escape_string[2])
              {
                case '?':
                  /* DIGITAL, xterm private modes */
                  {
                    int loop=3;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='l')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 1:
                          /* Cause the cursor to generate ANSI cursor control sequences */
                          break;
                        case 2:
                          /* Sets the terminal to VT52 mode */
                          session->other_session_flags |= NETTLE_OTHER_VT52_MODE;
                          break;
                        case 3:
                          /* Selects 80 columns per line */
                          if (session->other_session_flags & NETTLE_OTHER_COLUMN_MODE)
                          {
                            resize_terminal(session, 80,
                                                     session->terminal_size.y,
                                                     session->scrollback,
                                                     false);
                            session->other_session_flags &= ~NETTLE_OTHER_COLUMN_MODE;
                          }
                          break;
                        case 4:
                          /* Selects jump scroll */
                          break;
                        case 5:
                          /* Selects normal video */
                          session->other_session_flags &= ~NETTLE_OTHER_REVERSE_VIDEO;
                          changedbox_update_whole();
                          break;
                        case 6:
                          /* Home position based in top-left of screen */
                          session->other_session_flags &= ~NETTLE_OTHER_ORIGIN_MODE;
                          break;
                        case 7:
                          /* No autowrap */
                          session->other_session_flags &= ~NETTLE_OTHER_WRAP_MODE;
                          break;
                        case 8:
                          /* Turn off auto repeat */
                          break;
                        case 25:
                          /* Make cursor invisible */
                          session->other_session_flags &= ~NETTLE_OTHER_CURSOR_VIS;
                          break;
                        case 47:
                        case 1049:
                          /* Primary screen mode (xterm) */
                          if (session->other_session_flags & NETTLE_OTHER_SCREEN_MODE)
                          {
                            swap_alternate_main (session);
                            restore_cursor_position (session);
                            changedbox_update (0, session->scrollback,
                                               session->terminal_size.x - 1,
                                               session->scrollback +
                                                        session->terminal_size.y - 1);
                            session->other_session_flags &= ~NETTLE_OTHER_SCREEN_MODE;
                          }
                          break;
                        case 67:
                          /* Make Backspace send Delete and Delete send ESC '[3~' (requires DeepKeys) */
                          session->other_session_flags &= ~NETTLE_OTHER_BACKSPACE_MODE;
                          break;
                        case 1047:
                          /* Primary screen, clear, restore cursor (xterm) */
                          if (session->other_session_flags & NETTLE_OTHER_SCREEN_MODE)
                          {
                            copy_alternate_main (session);
                            clear_alternate_screen (session);
                            changedbox_update (0, session->scrollback,
                                               session->terminal_size.x - 1,
                                               session->scrollback +
                                                        session->terminal_size.y - 1);
                            session->other_session_flags &= ~NETTLE_OTHER_SCREEN_MODE;
                          }
                          break;
                        case 1048:
                          restore_cursor_position (session);
                          break;
                      }
                    }
                  }
                  break;
                default:
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='l')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 2:
                          /* Turn off keyboard lock */
                          session->other_session_flags &= ~NETTLE_OTHER_KEYLOCK_MODE;
                          break;
                        case 4:
                          /* Turn off insert mode */
                          session->other_session_flags &= ~NETTLE_OTHER_INSERT_MODE;
                          break;
                        case 12:
                          /* Turn on local echo (NB. just using telnet's echo stuff) */
                          session->session_flags[1]=false;
                          break;
                        case 20:
                          /* Make LF,FF,VT move to next line (normal behaviour) */
                          session->other_session_flags &= ~NETTLE_OTHER_LINEFEED_MODE;
                          break;
                      }
                    }
                  }
                  break;
              }
              done=true;
              break;
            case 'm':
              {
                bool status=false;
                int loop=2;

                if (session->current_fg & 8)
                {
                  status=true;
                }

                while (loop<session->escape_string_length)
                {
                  char string[256]="";
                  while(session->escape_string[loop]!=';' &&
                        session->escape_string[loop]!='m')
                  {
                    string[strlen(string)+1]='\0';
                    string[strlen(string)]=session->escape_string[loop];
                    loop++;
                  }
                  loop++;

	          switch (atoi(string))
	          {
	            case 0:
                      /* Clear all attributes */
                      status=false;
                      session->current_fg=7;
                      session->current_bg=0;
                      session->current_flags=0;
                      break;
                    case 1: case 5:
                      /* Bold, Blink */
                      session->current_fg |= 8;
                      status=true;
                      break;
                    case 27:
                      /* Cancel invert */
                      session->current_flags &= ~NETTLE_FLAG_INVERTED;
                     break;
                    case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
                      /* Foreground */
                      session->current_fg=atoi(string)-30;
                      if (status)
                      {
                        session->current_fg |= 8;
                      }
                      break;
                    case 39:
                      session->current_fg=7;
                      break;
                    case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:
                      /* Background */
                      session->current_bg=atoi(string)-40;
                      break;
                    case 49:
                      session->current_bg=0;
                      break;
                    case 7:
                      /* Invert */
                      session->current_flags |= NETTLE_FLAG_INVERTED;
                      break;
                  }
                }
              }
              done=true;
              break;
            case 'n':
              switch (session->escape_string[2])
              {
                case '5':
                  {
                    char block[16];

                    /* terminal OK */
                    sprintf(block,"%s0n",csi_sequence);

                    nettle_senddata(session,block,strlen(block));
                  }
                  break;
                case '6':
                  {
                    char block[16];

                    sprintf(block,"%s%d;%dR",csi_sequence,
                                             session->pos.y-session->scrollback+1,
                     			     session->pos.x+1);

                    nettle_senddata(session,block,strlen(block));
                  }
                  break;
                case '?':
                  if (session->escape_string[3]=='1')
                  {
                    if (session->escape_string[4]=='5')
                    {
                      char block[16];

                      /* There is no printer */
                      sprintf(block,"%s?13n",csi_sequence);

                      nettle_senddata(session,block,strlen(block));
                    }
                  }
                  break;
              }
              done=true;
              break;
            case 'o':
              /* define area qualification */
              done = true;
              break;
            case 'p':
              switch (session->escape_string[session->escape_string_length-2])
              {
                case '!':
                  /* Soft Reset terminal */
                  reset_terminal(session);
                  break;
                case '\"':
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='\"')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 61:
                          /* Set terminal to level 1 compatibility (VT100 mode) */
                          session->terminal_mode=1;
                          break;
                        case 62:
                          /* Set terminal to level 2 compatibility (VT200 mode) */
                          session->terminal_mode=2;
                          break;
                        case 0: case 2:
                          /* Set terminal to 8-bit mode */
                          session->bit_controls=true;
                          break;
                        case 1:
                          /* Set terminal to 7-bit mode */
                          session->bit_controls=false;
                          break;
                      }
                    }
                  }
                  break;
              }
              done=true;
              break;
            case 'r':
              if (session->escape_string[2] == '?')
              {
                /* restore DEC private mode */
                done = true;
                break;
              }

              /* Specify scrolling region */
              if (esc_instr(session->escape_string,";",session->escape_string_length)>=0)
              {
                session->scroll_start=atoi(session->escape_string+2);

                session->scroll_end=atoi(session->escape_string+
                                                esc_instr(session->escape_string,
                                                ";",session->escape_string_length)
                                                +1);
              }
              else
              {
                session->scroll_start=1;
                session->scroll_end=session->terminal_size.y;
              }

              if (session->scroll_start<1)
                session->scroll_start=1;

              if (session->scroll_end>session->terminal_size.y)
                session->scroll_end=session->terminal_size.y;

              if (session->pos.y<session->scrollback+session->scroll_start-1)
              {
                session->pos.y=session->scrollback+session->scroll_start-1;
              }

              if (session->pos.y>session->scrollback+session->scroll_end-1)
              {
                session->pos.y=session->scrollback+session->scroll_end-1;
              }

              done=true;
              break;
            case 's':
              if (session->escape_string[2] == '?')
              {
                /* save DEC private mode */
              }
              else
              {
                /* set left, right margins */
              }
              done = true;
              break;
            case 'u':
              /* DEC set htabs */
              done = true;
              break;
            case 'x':
              /* DEC VT100 request terminal parameters */
              if (session->terminal_type == NETTLE_TERMINAL_VT100)
              {
                static const char response[] = "\x1B[2;1;1;120;120;1;0x";
                nettle_senddata (session, response, sizeof (response) - 1);
              }
              done = true;
              break;
            default:
              /* catch-all */
              done = true;
          }
          break;
        case ']':
          if (session->escape_string[session->escape_string_length-1]==7)
          {
            switch (atoi(session->escape_string+2))
            {
              case 0:
                /* Change Icon Name and Window Title to Pt */
                {
                  char string[256];
                  int loop=esc_instr(session->escape_string,
                                     ";", session->escape_string_length)+1;
                  int counter=0;

                  while (session->escape_string[loop]!=7 && counter < sizeof(string) - 1)
                  {
                    string[counter++]=session->escape_string[loop++];
                  }
                  string[counter]='\0';
                  set_title_bar(session->window_handle,string);
                }
                break;
              case 1:
                /* Change Icon Name to Pt */
                break;
              case 2:
                /* Change Window Title to Pt */
                {
                  char string[256];
                  int loop=esc_instr(session->escape_string,
                                     ";", session->escape_string_length)+1;
                  int counter=0;

                  while (session->escape_string[loop]!=7)
                  {
                    string[counter]=session->escape_string[loop];
                    counter++;
                    loop++;
                  }
                  string[counter]='\0';
                  set_title_bar(session->window_handle,string);
                }
                break;
              case 46:
                /* Change Log File to Pt */
                break;
              case 50:
                /* Set Font to Pt */
                break;
            }

            done=true;
          }
          break;
      }
      break;
    case TELNET_IAC:
      switch (session->escape_string[1])
      {
        case TELNET_SB:
          if (session->escape_string[session->escape_string_length-2]==TELNET_IAC
              &&
              session->escape_string[session->escape_string_length-1]==TELNET_SE)
          {
            switch (session->escape_string[2])
            {
              case TELOPT_TERMINAL_TYPE:
                if (session->escape_string[3]==1)
                {
                  char block[256];
                  block[0]=TELNET_IAC;
                  block[1]=TELNET_SB;
                  block[2]=TELOPT_TERMINAL_TYPE;
                  block[3]=TELOPT_SUB_IS;
                  strcpy(block+4,terminal_name[session->terminal_type]);
                  block[4+strlen(terminal_name[session->terminal_type])]=TELNET_IAC;
                  block[5+strlen(terminal_name[session->terminal_type])]=TELNET_SE;
                  nettle_senddata(session,block,6+strlen(terminal_name[session->terminal_type]));
                  done=true;
                }
                break;
              case TELOPT_TERMINAL_SPEED:
                if (session->escape_string[3]==1)
                {
                  char block[256];
                  block[0]=TELNET_IAC;
                  block[1]=TELNET_SB;
                  block[2]=TELOPT_TERMINAL_SPEED;
                  block[3]=TELOPT_SUB_IS;
                  strcpy(block+4,"9600");
                  block[4+strlen("9600")]=TELNET_IAC;
                  block[5+strlen("9600")]=TELNET_SE;
                  nettle_senddata(session,block,6+strlen("9600"));
                  done=true;
                }
            }
          }
          break;
      }
      break;
  }
  return done;
}


static bool process_escape(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string_length)
  {
    case 0: case 1:
      /* strings of length 0 or 1 */
      done=false;
      break;
    case 2:
      /* strings of length 2 */
      done=process_escape_length_2(session);
      break;
    case 3:
      /* strings of length 3 */
      done=process_escape_length_3(session);
    default:
      /* strings of length >= 3 */
      if (!done)
      {
        done=process_escape_length_x(session);
      }
      break;
  }

  if (done)
  {
    session->escape_string_length=0;
    session->escape_state=NETTLE_ESCAPE_NONE;
  }

  return done;
}


void process_data(struct session_struct *session, char byte)
{
  bool done=false;

  if (session->bit_controls)
    /* 8-bit */
    strcpy(csi_sequence,"\x9B");
  else
    /* 7-bit */
    strcpy(csi_sequence,"\x1B[");

  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length==255)
    {
      generror(lookup_static ("esctoolong"), false);
      session->escape_state=NETTLE_ESCAPE_NONE;
      session->escape_string_length=0;
    }
    else
    {
      if ((session->escape_string[0]==TELNET_IAC) ||
          (session->escape_string[0]==27 && (byte<8 || byte>13)))
      {
        session->escape_string[session->escape_string_length]=byte;
        session->escape_string_length++;
        done = process_escape(session);
      }
    }
  }

  if (session->spool_file_name!=NULL && session->spool_raw)
    spool_byte(session, byte);

  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string[0]==TELNET_IAC)
    {
      return;
    }
  }

  if (!done)
  {
    if (session->spool_file_name!=NULL && !(session->spool_raw))
    {
      if (byte>=10 && byte<=12)
      {
        spool_byte(session, byte);
      }
    }

    switch (byte)
    {
      /* VT codes */
      case 0:   byte_null                  (session); break;
      case 1:                                         break;
      case 2:                                         break;
      case 3:                                         break;
      case 4:                                         break;
      case 5:   byte_enquiry               (session); break;
      case 7:   byte_bell                  (session); break;
      case 8:   byte_backspace             (session); break;
      case 9:   byte_horizontal_tabulation (session); break;
      case 10:
      case 11:
      case 12:  byte_linefeed              (session); break;
      case 13:  byte_carriage_return       (session); break;
      case 14:  byte_shift_out             (session); break;
      case 15:  byte_shift_in              (session); break;
      case 16:                                        break;
      case 17:  byte_device_control_1      (session); break;
      case 18:                                        break;
      case 19:  byte_device_control_3      (session); break;
      case 20:                                        break;
      case 21:                                        break;
      case 22:                                        break;
      case 23:                                        break;
      case 24:  byte_cancel                (session); break;
      case 25:                                        break;
      case 26:  byte_substitute            (session); break;
      case 27:  byte_escape                (session); break;
      case 28:                                        break;
      case 29:                                        break;
      case 30:                                        break;
      case 31:                                        break;
      case 127: byte_delete                (session); break;

      /* VT C1 codes */
      case 128:                                       break;
      case 129:                                       break;
      case 130:                                       break;
      case 131:                                       break;
      case 132: byte_index		   (session); break;
      case 133: byte_next_line		   (session); break;
      case 134:                                       break;
      case 135:                                       break;
      case 136: byte_horizontal_tab_set    (session); break;
      case 137:                                       break;
      case 138:                                       break;
      case 139:                                       break;
      case 140:                                       break;
      case 141: byte_reverse_index         (session); break;
      case 142: byte_single_shift_g2       (session); break;
      case 143: byte_single_shift_g3       (session); break;
      case 144: byte_device_control_string (session); break;
      case 145:                                       break;
      case 146:                                       break;
      case 147:                                       break;
      case 148:                                       break;
      case 149:                                       break;
      case 150:                                       break;
      case 151:                                       break;
      case 152:                                       break;
      case 153:                                       break;
      case 154:                                       break;
      case 155: byte_control_sequence_intro(session); break;
      case 156: byte_string_terminator     (session); break;
      case 157:                                       break;
      case 158:                                       break;
      case 159:                                       break;
      case 160:                                       break;

      /* Telnet codes */
      case 255: byte_telnet                (session); break;

      /* Other codes */
      default:
        if (session->escape_state==NETTLE_ESCAPE_NONE)
        {
                byte_default          (session, byte);

          if (session->spool_file_name!=NULL && !(session->spool_raw))
          {
            spool_byte(session, byte);
          }
        }
        break;
    }
  }
}


void process_wimp_key(struct session_struct *session, int key, int extra)
{
  char block[256];
  int size_of_block=0;
  struct coords pos;
  char cursor_flags;

  if (session->other_session_flags & NETTLE_OTHER_KEYLOCK_MODE)
    return;

  pos=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session, pos.x, pos.y) &
                    (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  cursor_flags |= NETTLE_FLAG_CURSOR;

  /* remove the cursor from the position */
  changedbox_init (session);
  changedbox_update_char (pos.x, pos.y);
  write_assigned_flags(session, pos.x, pos.y,
                       read_assigned_flags(session, pos.x, pos.y)
		            & ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));

  force_redraw_changedbox ();

  changedbox_init (session);

  size_of_block = decode_key (session, key, extra, block);

  if (session->session_flags[1]==false)
  {
    int loop;

    for (loop=0; loop<size_of_block; loop++)
    {
      switch (block[loop])
      {
        case 7: byte_bell                  (session); break;
        case 8: byte_backspace             (session);

          changedbox_update_char (session->pos.x, session->pos.y);
          write_assigned(session, session->pos.x, session->pos.y,
                         session->current_fg,
          		 session->current_bg,
          		 session->current_flags,
          		 32);
         break;

        case 9:  byte_horizontal_tabulation(session); break;
        case 10: byte_linefeed             (session); break;
        case 13: byte_carriage_return      (session); break;

        default:
          reprocess_position(session);

          if (block[loop]<32)
          {
            changedbox_update_char (session->pos.x, session->pos.y);
            write_assigned(session, session->pos.x, session->pos.y,
                           session->current_fg,
            		   session->current_bg,
            		   session->current_flags,
            		   '^');
            session->pos.x++;
            reprocess_position(session);
          }

          /* write out the data */
          changedbox_update_char (session->pos.x, session->pos.y);
          write_assigned(session, session->pos.x, session->pos.y,
                         session->current_fg,
            		 session->current_bg,
            		 session->current_flags,
            		 '?');

          if (block[loop]<32)
          {
            write_assigned_character(session, session->pos.x, session->pos.y, block[loop]+64);
          }
          else
          {
            write_assigned_character(session, session->pos.x, session->pos.y, block[loop]);
          }
          session->pos.x++;

          break;
      }
    }
  }

  nettle_senddata(session,block,size_of_block);

  pos=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session, pos.x, pos.y,
                         read_assigned_flags(session, pos.x, pos.y) | cursor_flags);
  }

  /* redraw the window */
  force_redraw_changedbox ();

  /* force the selection back on (it may have got overwritten by new data) */
  force_redraw_selection();

  /* redraw the cursor, in case it isn't in the main redraw block */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    changedbox_init (session);
    changedbox_update_char (pos.x, pos.y);
    force_redraw_changedbox ();
  }
}

void process_line_editor(struct session_struct *session)
{
  char *icon_text;
  char data[512];
  int line_editor_icon=(session->line_editor_type==LINEEDIT_CHECKBOX ? 1 : 0);

  read_icon_data(session->pane_handle, line_editor_icon, data, sizeof(data));

  icon_text = malloc(strlen(data) + 3);
  assert(icon_text != NULL);

  strcpy(icon_text, data);
  strcat(icon_text, "\r");

  process_data_transmission(session, icon_text, strlen(icon_text));

  {
    int loop;

    for (loop=line_editor_size-1; loop>1; loop--)
    {
      strcpy(session->line_editor_history+(loop*512),
        	   session->line_editor_history+((loop-1)*512));
    }
  }

  strcpy(session->line_editor_history+(1*512),
         icon_text);

  set_icon_data(session->pane_handle,line_editor_icon,"");

  set_caret_position(session->pane_handle, line_editor_icon, -1, 0);

  session->line_editor_position=0;
  session->line_editor_total++;

  if (session->line_editor_total>line_editor_size)
  {
    session->line_editor_total=line_editor_size;
  }

  free(icon_text);
}

void process_data_transmission(struct session_struct *session,
                               const char *icon_text, int size_of_data)
{
  char block[256];
  int size_of_block=0;
  struct coords pos;
  char cursor_flags;
  char *send_block=0;
  int size_of_send_block=0;
  int icon_text_loop;

  if (session->other_session_flags & NETTLE_OTHER_KEYLOCK_MODE)
    return;

  /* Just for safety */
  if (session->socket_state!=NETTLE_SESSION_CONNECTED)
    return;

  pos=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session, pos.x, pos.y)
                    & (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  cursor_flags |= NETTLE_FLAG_CURSOR;

  /* remove the cursor from the position */
  changedbox_init (session);
  changedbox_update_char (pos.x, pos.y);
  write_assigned_flags(session, pos.x, pos.y, read_assigned_flags(session, pos.x, pos.y)
						 & ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));
  force_redraw_changedbox ();

  changedbox_init (session);

  for (icon_text_loop=0; icon_text_loop<size_of_data; icon_text_loop++)
  {
    int key=icon_text[icon_text_loop];

    size_of_block = decode_key (session, key, 0, block);

    if (session->session_flags[1]==false)
    {
      int loop;

      for (loop=0; loop<size_of_block; loop++)
      {
        switch (block[loop])
        {
          case 7: byte_bell                  (session); break;
          case 8: byte_backspace             (session);

            changedbox_update_char (session->pos.x, session->pos.y);
            write_assigned(session, session->pos.x, session->pos.y,
                           session->current_fg,
            		   session->current_bg,
            		   session->current_flags,
            		   32);
            break;

          case 9:  byte_horizontal_tabulation(session); break;
          case 10: byte_linefeed             (session); break;
          case 13: byte_carriage_return      (session); break;

          default:
            reprocess_position(session);

            if (block[loop]<32)
            {
              changedbox_update_char (session->pos.x, session->pos.y);
              write_assigned(session, session->pos.x, session->pos.y,
                             session->current_fg,
              		     session->current_bg,
              		     session->current_flags,
              		     '^');

              session->pos.x++;
              reprocess_position(session);
            }

            /* write out the data */
            changedbox_update_char (session->pos.x, session->pos.y);
            write_assigned(session, session->pos.x, session->pos.y,
                           session->current_fg,
              		   session->current_bg,
              		   session->current_flags,
              		   '?');

            if (block[loop]<32)
            {
              write_assigned_character(session, session->pos.x, session->pos.y ,block[loop]+64);
            }
            else
            {
              work_out_character(session, session->pos.x, session->pos.y, block[loop]);
            }
            session->pos.x++;

            break;
        }
      }
    }
    send_block=realloc(send_block,size_of_send_block+size_of_block); /* FIXME: Dangerous use of realloc() */
    strncpy(send_block+size_of_send_block,block,size_of_block);
    size_of_send_block+=size_of_block;
  }

  nettle_senddata(session,send_block,size_of_send_block);

  pos=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session, pos.x, pos.y,
                         read_assigned_flags(session, pos.x, pos.y) | cursor_flags);
  }

  /* redraw the window */
  force_redraw_changedbox ();

  /* force the selection back on (it may have got overwritten by new data) */
  force_redraw_selection();

  /* redraw the cursor, in case it isn't in the main redraw block */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    changedbox_init (session);
    changedbox_update_char (pos.x, pos.y);
    force_redraw_changedbox ();
  }

  free(send_block);
}


/* get the current cursor position */
struct coords get_cursor_position(struct session_struct *session)
{
  struct coords pos;

  pos.x = session->pos.x;
  pos.y = session->pos.y;

  /* get a sanitised x coordinate */
  if (pos.x >= session->terminal_size.x)
    pos.x = session->terminal_size.x - 1;

  /* return real offset or, if outside terminal, the last available offset */
  if (pos.y >= session->terminal_size.y + session->scrollback)
  {
    pos.x = session->terminal_size.x;
    pos.y = session->terminal_size.y + session->scrollback - 1;
  }

  return pos;
}
