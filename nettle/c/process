/**
 * Processing code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "graphics.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "wimp.h"
#include "zapredraw.h"

static char status_positive(char iac_type)
{
  switch (iac_type)
  {
    case 251: /* WILL */
      return 253; /* DO */
      break;

    case 252: /* WONT */
      return 254; /* DONT */
      break;

    case 253: /* DO */
      return 251; /* WILL */
      break;

    case 254: /* DONT */
      return 252; /* WONT */
      break;
  }

  generror("Invalid IAC type",false);
  return 0;
}

static int status_negative(int iac_type)
{
  switch (iac_type)
  {
    case 251: /* WILL */
      return 254; /* DONT */
      break;

    case 252: /* WONT */
      return 254; /* DONT */
      break;

    case 253: /* DO */
      return 252; /* WONT */
      break;

    case 254: /* DONT */
      return 252; /* WONT */
      break;
  }

  generror("Invalid IAC type",false);
  return 0;
}

static void reprocess_position_scroll(struct session_struct *session)
{
  int count,calc;

  /* scroll if y>scroll_end */

  while (session->ypos>(session->scroll_end+session->scrollback-1))
  {
    session->ypos--;

    if (selection_session)
    {
      selection_start-=session->terminal_size_x;
      selection_end-=session->terminal_size_x;
      if (selection_start<0)
      {
        selection_start=0;
      }
      if (selection_end<0)
      {
        selection_end=0;
      }
    }

    if (session->scroll_start==1)
    {
      /* scroll scrollback as well */

      _swi(ZapRedraw_MoveBytes, _INR(1,3),
           session->assigned_area+(session->terminal_size_x*4),

           session->assigned_area,

           (session->terminal_size_x*
            (session->scroll_end+session->scrollback-1))*4);
    }
    else
    {
      _swi(ZapRedraw_MoveBytes, _INR(1,3),
                                session->assigned_area+
      			        ((session->terminal_size_x*
      			        (session->scroll_start+
      			        session->scrollback))*4),

                                session->assigned_area+
      				((session->terminal_size_x*
      				(session->scroll_start+
      				session->scrollback-1))*4),

                                (session->terminal_size_x*
                                (session->scroll_end-
                                 session->scroll_start))*4);
    }

    /* and clear the new line */
    for (count=0; count<session->terminal_size_x; count++)
    {
       calc=(((session->scroll_end+session->scrollback-1)*
              session->terminal_size_x)+count)*4;

       write_assigned(session,calc,7,0,0,32);
    }
  }


  /* scroll if Y<scroll_start */

  while (session->ypos<(session->scroll_start+
                                        session->scrollback-1))
  {
    session->ypos++;

    if (selection_session)
    {
      selection_start+=session->terminal_size_x;
      selection_end+=session->terminal_size_x;
      if (selection_start>(session->terminal_size_x*
        		   (session->terminal_size_y+
        		    session->scrollback)))
      {
        selection_start=(session->terminal_size_x*
        		   (session->terminal_size_y+
        		    session->scrollback));
      }
      if (selection_end>(session->terminal_size_x*
        		   (session->terminal_size_y+
        		    session->scrollback)))
      {
        selection_end=(session->terminal_size_x*
        		   (session->terminal_size_y+
        		    session->scrollback));
      }
    }


    _swi(ZapRedraw_MoveBytes, _INR(1,3),
                              session->assigned_area+
      			      ((session->terminal_size_x*
      			      (session->scroll_start+
      			      session->scrollback-1))*4),

                              session->assigned_area+
      			      ((session->terminal_size_x*
      			      (session->scroll_start+
      			      session->scrollback))*4),

                              (session->terminal_size_x*
                              (session->scroll_end-
                              session->scroll_start))*4);

    /* and clear the new line */
    for (count=0; count<session->terminal_size_x; count++)
    {
       calc=(((session->scroll_start+session->scrollback-1)*
              session->terminal_size_x)+count)*4;

       write_assigned(session,calc,7,0,0,32);
    }
  }
}


static void reprocess_position(struct session_struct *session)
{
  /* this reshuffles everything so that everything is back on screen, this allows the cursor */
  /* to sit at  (81,24) without causing a newline (which would break pine and things) */
  /* It also shuffles up the selection areas */

  if (session->xpos>session->terminal_size_x-1)
  {
    if (session->other_session_flags & NETTLE_OTHER_WRAP_MODE)
    {
      session->xpos=0;
      session->ypos++;
      reprocess_position_scroll(session);
    }
    else
    {
      while (session->xpos>session->terminal_size_x-1)
      {
        session->xpos--;
      }
    }
  }
}


static void work_out_character(struct session_struct *session, int data, unsigned char byte)
{
  int character_set;

  switch (session->character_set)
  {
    case NETTLE_CHSET_G0:
    default:
      character_set=session->character_set_g0;
      break;

    case NETTLE_CHSET_G1:
      character_set=session->character_set_g1;
      break;

    case NETTLE_CHSET_G2:
      character_set=session->character_set_g2;
      break;

    case NETTLE_CHSET_G3:
      character_set=session->character_set_g3;
      break;
  }

  switch (character_set)
  {
    case NETTLE_CHSET_GRAPHICS:
      {
        int graphics_byte=dec_graphics_table[byte];

        if (graphics_byte<0x100)
        {
          write_assigned_character(session,data,(char) graphics_byte);
        }
        else
        {
          write_assigned_flags(session,data,read_assigned_flags(session,data) | NETTLE_FLAG_PLUS100);
          write_assigned_character(session,data,(char) graphics_byte-0x100);
        }
      }
      break;
    case NETTLE_CHSET_UK:
      if (byte!='#')
      {
        write_assigned_character(session,data,byte);
      }
      else
      {
        write_assigned_character(session,data,'£');
      }
      break;
    case NETTLE_CHSET_US: case NETTLE_CHSET_ALTROMSTD: case NETTLE_CHSET_ALTROMSPC:
      write_assigned_character(session,data,byte);
      break;
  }
}


static void byte_null(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_enquiry(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_bell(struct session_struct *session)
{
  NOT_USED(session);

  /* Bell */
  _swi(OS_WriteI + 7, 0);
}

static void byte_backspace(struct session_struct *session)
{
  /* Backspace */
  if (session->xpos>0)
    session->xpos--;
}

static void byte_horizontal_tabulation(struct session_struct *session)
{
  /* Tab */
  int loop;
  int current_tab=session->terminal_size_x;

  for (loop=0; loop<session->number_of_tabs; loop++)
  {
    if (session->tabs[loop]>session->xpos &&
        session->tabs[loop]<current_tab)
    {
      current_tab=session->tabs[loop];
    }
  }

  if (current_tab<session->terminal_size_x)
  {
    session->xpos=current_tab;
  }
}

static void byte_linefeed(struct session_struct *session)
{
  /* LF,VT,FF */
  session->ypos++;

  if (session->other_session_flags & NETTLE_OTHER_LINEFEED_MODE)
  {
    session->xpos=0;
  }

  reprocess_position(session);
  reprocess_position_scroll(session);
}

static void byte_carriage_return(struct session_struct *session)
{
  /* CR */
  session->xpos=0;
}

static void byte_shift_out(struct session_struct *session)
{
  session->character_set=NETTLE_CHSET_G1;
}

static void byte_shift_in(struct session_struct *session)
{
  session->character_set=NETTLE_CHSET_G0;
}

static void byte_device_control_1(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_device_control_3(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_cancel(struct session_struct *session)
{
  int data=((session->ypos*session->terminal_size_x)+
             session->xpos)*4;

  write_assigned(session,data,session->current_fg,
  				     session->current_bg,
  				     session->current_flags,
  				     '?');

  session->escape_state=NETTLE_ESCAPE_NONE;
  session->escape_string_length=0;
}

static void byte_substitute(struct session_struct *session)
{
  session->escape_state=NETTLE_ESCAPE_NONE;
  session->escape_string_length=0;
}

static void byte_escape(struct session_struct *session)
{
  /* ESCAPE */
  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length>=2)
    {
      if (session->escape_string[0]=='\x1B')
      {
        switch (session->escape_string[1])
        {
          case 'P': case '^': case '_': case ']':
            return;
            break;
        }
      }
    }
  }

  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string_length=1;
}

static void byte_delete(struct session_struct *session)
{
  NOT_USED(session);
}

static void byte_index(struct session_struct *session)
{
  /* Index */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='D';
  session->escape_string_length=2;
}

static void byte_next_line(struct session_struct *session)
{
  /* Next line */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='E';
  session->escape_string_length=2;
}

static void byte_horizontal_tab_set(struct session_struct *session)
{
  /* Horizontal tab set */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='H';
  session->escape_string_length=2;
}

static void byte_reverse_index(struct session_struct *session)
{
  /* Reverse index */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='M';
  session->escape_string_length=2;
}

static void byte_single_shift_g2(struct session_struct *session)
{
  /* Single shift G2 */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='N';
  session->escape_string_length=2;
}

static void byte_single_shift_g3(struct session_struct *session)
{
  /* Single shift G3 */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='O';
  session->escape_string_length=2;
}

static void byte_device_control_string(struct session_struct *session)
{
  /* Device control string */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='P';
  session->escape_string_length=2;
}

static void byte_control_sequence_intro(struct session_struct *session)
{
  /* Control sequence introducer */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\x1B';
  session->escape_string[1]='[';
  session->escape_string_length=2;
}

static void byte_string_terminator(struct session_struct *session)
{
  /* String terminator */
  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length>=2)
    {
      if (session->escape_string[0]=='\x1B')
      {
        if (session->escape_string[1]=='[')
        {
          session->escape_string[session->escape_string_length++]='\x1B';
          session->escape_string[session->escape_string_length++]='\\';
        }
      }
    }
  }
}


static void byte_telnet(struct session_struct *session)
{
  /* Telnet negotiation */
  session->escape_state=NETTLE_ESCAPE_ESCAPE;
  session->escape_string[0]='\xFF';
  session->escape_string_length=1;
}


static void byte_default(struct session_struct *session, char byte)
{
  int data;

  reprocess_position(session);

  if (session->other_session_flags & NETTLE_OTHER_INSERT_MODE)
  {
    int calc, calc2;
    /* If we're inserting a character, then shuffle all the characters along a byte */
    calc=(int) session->assigned_area+
           ((session->ypos*session->terminal_size_x)+
             session->xpos)*4;
    calc2=(int) session->assigned_area+
            ((session->ypos+1)*session->terminal_size_x)*4;

    /* Maybe... calc2-calc-4 might be wrong */
    _swi(ZapRedraw_MoveBytes, _INR(1,3), calc, calc+4, calc2-calc-4);
  }
  data=((session->ypos*session->terminal_size_x)+
             session->xpos)*4;

  /* write out the data */
  write_assigned(session,data,session->current_fg,
                                     session->current_bg,
                                     session->current_flags,
                                     '?');

  work_out_character(session,data,byte);

  session->xpos++;
}

static void clear_screen(struct session_struct *session, int calc, int calc2, char fg, char bg,
                         char flags, char character)
{
  int loop;

  /* clear the specified area withe the specified fg,bg,flags and character */
  for (loop=calc; loop<=calc2; loop+=4)
  {
    if (loop>0 && loop<(session->terminal_size_x*
             (session->terminal_size_y+session->scrollback)*4))
    {
      write_assigned(session,loop,fg,bg,flags,character);
    }
  }
}


static void snap_cursor_to_terminal(struct session_struct *session)
{
  /* snaps the cursor inside the terminal */
  if (session->xpos<0)
  {
    session->xpos=0;
  }
  if (session->xpos>=session->terminal_size_x)
  {
    session->xpos=session->terminal_size_x-1;
  }

  if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
  {
    if (session->ypos<session->scroll_start+
                                   session->scrollback-1)
    {
    session->ypos=session->scroll_start+
                                 session->scrollback-1;
    }
    if (session->ypos>session->scroll_end+
    				   session->scrollback-1)
    {
      session->ypos=session->scroll_end+
    				   session->scrollback-1;
    }
  }
  else
  {
    if (session->ypos<session->scrollback)
    {
    session->ypos=session->scrollback;
    }
    if (session->ypos>session->terminal_size_y+
    				   session->scrollback-1)
    {
      session->ypos=session->terminal_size_y+
    				   session->scrollback-1;
    }
  }
}


static bool process_escape_length_2(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case '=':
          /* Selects application keypad mode */
          session->other_session_flags=
          		session->other_session_flags | NETTLE_OTHER_APPLI_MODE;
          done=true;
          break;
        case '>':
          /* Selects numeric keypad mode */
          session->other_session_flags=
          		session->other_session_flags & ~NETTLE_OTHER_APPLI_MODE;
          done=true;
          break;
        case '<':
          /* Enter ANSI mode */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            session->other_session_flags=
          		session->other_session_flags & ~NETTLE_OTHER_VT52_MODE;
            done=true;
          }
          break;
        case '\\':
          /* End Device Control String (no effect here - this is to allow for variants of */
          /* title bar content changing) */
          done=true;
          break;
        case '7':
          /* Save cursor position */
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            session->old_xpos=session->xpos;
            session->old_ypos=session->ypos-
       						session->scrollback;
            session->old_current_flags=session->current_flags;
            session->old_current_fg=session->current_fg;
            session->old_current_bg=session->current_bg;
            session->old_other_session_flags=
       					     session->other_session_flags;
            session->old_character_set=session->character_set;
            session->old_character_set_g0=
            						session->character_set_g0;
            session->old_character_set_g1=
            						session->character_set_g1;
            session->old_character_set_g2=
            						session->character_set_g2;
            session->old_character_set_g3=
            						session->character_set_g3;
            done=true;
          }
          break;
        case '8':
          /* Restore cursor position */
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            session->xpos=session->old_xpos;
            session->ypos=session->old_ypos+
      						session->scrollback;
            session->current_flags=session->old_current_flags;
            session->current_fg=session->old_current_fg;
            session->current_bg=session->old_current_bg;
            session->other_session_flags=
      					session->old_other_session_flags;
            session->character_set=session->old_character_set;
            session->character_set_g0=
            					session->old_character_set_g0;
            session->character_set_g1=
            					session->old_character_set_g1;
            session->character_set_g2=
            					session->old_character_set_g2;
            session->character_set_g3=
            					session->old_character_set_g3;
            snap_cursor_to_terminal(session);
            done=true;
          }
          break;
        case 'A':
          /* Cursor up (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->ypos>session->scrollback)
              session->ypos--;

            done=true;
          }
          break;
        case 'B':
          /* Cursor down (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->ypos<session->terminal_size_y+
                                             session->scrollback+1)
              session->ypos++;

            done=true;
          }
          break;
       case 'C':
          /* Cursor right (in VT52 mode) */
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->xpos<session->terminal_size_x-1)
              session->xpos++;

            done=true;
          }
          break;
        case 'D':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Move cursor left (in VT52 mode) */
            if (session->xpos>0)
              session->xpos--;
          }
          else
          {
            /* Moves cursor down one line (in non-VT52 mode) */
            session->ypos++;
            reprocess_position_scroll(session);
          }
          done=true;
          break;
        case 'E':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            /* Carriage return and line feed */
            session->ypos++;
            session->xpos=0;
            reprocess_position(session);
            done=true;
          }
          break;
        case 'F':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Enter "graphics" Mode */
            done=true;
          }
          break;
        case 'G':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Exit "graphics" Mode */
            done=true;
          }
          break;
        case 'H':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Cursor to home (VT52 mode) */
            session->xpos=0;
            session->ypos=session->scrollback;
          }
          else
          {
            /* Set tab (non-VT52 mode) */
            if (session->number_of_tabs<MAX_TAB_NUMBER)
            {
              session->tabs[session->number_of_tabs]=
		            					session->xpos;
            }
            else
            {
              printf("Error: too many tabs, ignored\n");
            }
          }
          done=true;
          break;
        case 'I':
          /* Reverse line feed */
          session->ypos--;
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            reprocess_position_scroll(session);
          }
          done=true;
          break;
        case 'J':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Erase to end of screen */
            clear_screen(session,

                       ((session->ypos*session->terminal_size_x)+
                       session->xpos)*4,

                       (session->terminal_size_x*
                       (session->terminal_size_y+
                        session->scrollback))*4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);
            done=true;
          }
          break;
        case 'K':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            /* Erase to end of line */
            clear_screen(session,

                       ((session->ypos*session->terminal_size_x)+
                         session->xpos)*4,

                       (session->ypos+1)*
                       session->terminal_size_x*4-4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);
            done=true;
          }
          break;
        case 'M':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            session->ypos--;
            reprocess_position_scroll(session);
            done=true;
          }
          break;
        case 'c':
          if (!(session->other_session_flags & NETTLE_OTHER_VT52_MODE))
          {
            reset_terminal(session);
            session->xpos=0;
            session->ypos=session->scrollback;
            done=true;
          }
          break;
        case 'Z':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            char block[3];
            block[0]='\x1B';
            block[1]='/';
            block[2]='Z';
            nettle_senddata(session,block,3);
            done=true;
          }
          break;
      }
      break;
    case 255:
      switch (session->escape_string[1])
      {
        case 242:
          done=true;
          break;
        case 255:
          done=true;
          byte_default(session, 255);
          break;
      }
      break;
  }

  return done;
}


static bool process_escape_length_3(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case '(':
          session->character_set_g0=session->escape_string[2];
          done=true;
          break;
        case ')':
          session->character_set_g1=session->escape_string[2];
          done=true;
          break;
        case '*':
          session->character_set_g2=session->escape_string[2];
          done=true;
          break;
        case '+':
          session->character_set_g3=session->escape_string[2];
          done=true;
          break;
        case '#':
          done=true;
          switch (session->escape_string[2])
          {
            case '3': case '4': case '5': case '6':
              /* various font size alterations - not supported */
              break;
            case '8':
              /* Clear screen with E's */
              clear_screen(session,

                           session->scrollback*
                           session->terminal_size_x*4,

                           (session->terminal_size_x*
                           (session->terminal_size_y+
                            session->scrollback))*4,

                           session->current_fg,
                           session->current_bg,
                           0,
                           'E');
              break;
          }
          break;
      }
      break;
    case 255:
      {
        /* IAC */
        int iac_type=session->escape_string[1];


        switch (iac_type)
        {
          case 251: /* WILL */
          case 253: /* DO */
            done=true;

            switch (session->escape_string[2])
            {
              case 1:
              case 24:
              case 31:
                if (session->session_flags[(unsigned char) session->escape_string[2]]==false)
                {
                  char block[3];

                  block[0]=255; /* IAC */
                  block[1]=status_positive(iac_type);
                  block[2]=session->escape_string[2];
                  nettle_senddata(session,block,3);

                  {
                    char string[256];

                    sprintf(string, "<<Sending positive response %d to positive request %d, %d>>", status_positive(iac_type), iac_type, session->escape_string[2]);
                    log_string(string);
                  }
                }

                session->session_flags[(unsigned char) session->escape_string[2]]=true;

                if (session->escape_string[2]==31)
                {
                  char block[9];

                  block[0]=255; /* IAC */
                  block[1]=250; /* SB */
                  block[2]=31;  /* NAWS */
                  block[3]=session->terminal_size_x / 256;
                  block[4]=session->terminal_size_x % 256;
                  block[5]=session->terminal_size_y / 256;
                  block[6]=session->terminal_size_y % 256;
                  block[7]=255; /* IAC */
                  block[8]=240; /* SE */
                  nettle_senddata(session,block,9);
                }

                break;
              default:
                /* if (session->session_flags[(unsigned char) session->escape_string[2]]==true) */
                {
                  char block[3];

                  block[0]=255; /* IAC */
                  block[1]=status_negative(iac_type);
                  block[2]=session->escape_string[2];
                  nettle_senddata(session,block,3);

                  {
                    char string[256];

                    sprintf(string, "<<Sending negative response %d to positive request %d, %d>>", status_negative(iac_type), iac_type, session->escape_string[2]);
                    log_string(string);
                  }
                }
                session->session_flags[(unsigned char) session->escape_string[2]]=false;
                break;
            }
            break;
          case 252: /* WON'T */
          case 254: /* DON'T */
            done=true;

            if (session->session_flags[(unsigned char) session->escape_string[2]]==true)
            {
              char block[3];

              block[0]=255; /* IAC */
              block[1]=status_negative(iac_type);
              block[2]=session->escape_string[2];
              nettle_senddata(session,block,3);

              {
                char string[256];

                sprintf(string, "<<Sending negative response %d to negative request %d, %d>>", status_negative(iac_type), iac_type, session->escape_string[2]);
                log_string(string);
              }
            }
            session->session_flags[(unsigned char) session->escape_string[2]]=false;
            break;
        }
      }
      break;
  }

  return done;
}


static bool process_escape_length_x(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string[0])
  {
    case 27:
      switch (session->escape_string[1])
      {
        case 'Y':
          if (session->other_session_flags & NETTLE_OTHER_VT52_MODE)
          {
            if (session->escape_string_length==4)
            {
              session->xpos=session->escape_string[3]-32;
              session->ypos=session->escape_string[2]-32+session->scrollback;
              done=true;
            }
          }
          break;
        case '[':
          switch (session->escape_string[session->escape_string_length-1])
          {
            case 'A':
              /* Cursor up Pn lines */
              if (session->escape_string[2]!='A')
              {
                int move=atoi(session->escape_string+2);
                switch (move)
                {
                  case 0:
                    session->ypos--;
                    break;
                  default:
                    session->ypos-=move;
                    break;
                }
              }
              else
              {
                session->ypos--;
              }
              if (session->ypos<session->scrollback+session->scroll_start)
              {
                session->ypos=session->scrollback+session->scroll_start;
              }
              done=true;
              break;
            case 'B':
              /* Cursor down Pn lines */
              if (session->escape_string[2]!='B')
              {
                int move=atoi(session->escape_string+2);
                switch (move)
                {
                  case 0:
                    session->ypos++;
                    break;
                  default:
                    session->ypos+=move;
                    break;
                }
              }
              else
              {
                session->ypos++;
              }
              if (session->ypos>session->scrollback+session->scroll_end-1)
              {
                session->ypos=session->scrollback+session->scroll_end-1;
              }
              done=true;
              break;
            case 'C':
              /* Cursor right Pn chars */
              if (session->escape_string[2]!='C')
              {
                int move=atoi(session->escape_string+2);
                switch (move)
                {
                  case 0:
                    session->xpos++;
                    break;
                  default:
                    session->xpos+=move;
                    break;
                }
              }
              else
              {
                session->xpos++;
              }
              if (session->xpos>session->terminal_size_x-1)
              {
                session->xpos=session->terminal_size_x-1;
              }
              done=true;
              break;
            case 'D':
              /* Cursor left Pn chars */
              if (session->escape_string[2]!='D')
              {
                int move=atoi(session->escape_string+2);
                switch (move)
                {
                  case 0:
                    session->xpos--;
                    break;
                  default:
                    session->xpos-=move;
                    break;
                }
              }
              else
              {
                session->xpos--;
              }
              if (session->xpos<0)
              {
                session->xpos=0;
              }
              done=true;
              break;
            case 'H': case 'f':
              /* Direct cursor addressing */
              if (esc_instr(session->escape_string,";", session->escape_string_length)>=0)
              {
                session->xpos=atoi(session->escape_string+
                                                esc_instr(session->escape_string,
                                                ";",session->escape_string_length)
                                                +1)-1;

                if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
                {
                  session->ypos=session->scrollback+
                   			       session->scroll_start-1+
                                             atoi(session->escape_string+2)-1;
                }
                else
                {
                  session->ypos=session->scrollback+atoi(session->escape_string+2)-1;
                }
              }
              else
              {
                session->xpos=0;
                if (session->other_session_flags & NETTLE_OTHER_ORIGIN_MODE)
                {
                  session->ypos=session->scrollback+session->scroll_start-1;
                }
                else
                {
                  session->ypos=session->scrollback;
                }
              }
              snap_cursor_to_terminal(session);
              done=true;
              break;
            case 'J':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'J':
                  /* Clear screen from cursor to end of screen */
                  clear_screen(session,

                       ((session->ypos*session->terminal_size_x)+
                       session->xpos)*4,

                       (session->terminal_size_x*
                       (session->terminal_size_y+
                        session->scrollback))*4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);

                  break;
                case '1':
                  /* Clear screen from beginning of screen to cursor */
                  clear_screen(session,

                       (session->scrollback*
                         session->terminal_size_x)*4,

                       ((session->ypos*
                         session->terminal_size_x)+
                        session->xpos)*4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);

                  break;
                case '2':
                  /* Clear screen */
                  clear_screen(session,

                       (session->scrollback*
                         session->terminal_size_x)*4,

                       (session->terminal_size_x*
                        (session->terminal_size_y+
                         session->scrollback))*4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);

                  break;
              }
              break;
            case 'K':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'K':
                  /* Clear line from cursor to end of line */
                  clear_screen(session,

                       ((session->ypos*session->terminal_size_x)+
                         session->xpos)*4,

                       (session->ypos+1)*
                       session->terminal_size_x*4-4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);

                  break;
                case '1':
                  /* Clear from beginning of line to cursor */
                  clear_screen(session,

                       (session->ypos*session->terminal_size_x)*4,

                       ((session->ypos*session->terminal_size_x)+
                        session->xpos)*4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);

                  break;
                case '2':
                  /* Clear entire line */
                  clear_screen(session,

                       (session->ypos*session->terminal_size_x)*4,

                       ((session->ypos+1)*
                        session->terminal_size_x)*4-4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);

                  break;
              }
              break;
            case 'L':
              /* Insert line(s) */
              if (session->ypos-session->scrollback<session->scroll_end-1
                  &&
                  session->ypos-session->scrollback>session->scroll_start-1)
              {
                int calc, calc2;
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                calc=(int) session->assigned_area+
                            (session->ypos*session->terminal_size_x)*4;

                if (move>session->scroll_end-(session->ypos-session->scrollback-1))
                {
                  move=session->scroll_end-(session->ypos-session->scrollback-1);
                }

                calc2=(int) session->assigned_area+
                             ((session->ypos+move)*session->terminal_size_x)*4;

                _swi(ZapRedraw_MoveBytes, _INR(1,3), calc, calc2,
                                              move*session->terminal_size_x*4);

                clear_screen(session,
                             (session->ypos*session->terminal_size_x)*4,

                             ((session->ypos+move)*session->terminal_size_x)*4-4,

                             session->current_fg,
                             session->current_bg,
                             0,
                             32);
              }
              done=true;
              break;
            case 'P':
              {
                /* Delete character(s) */
                int calc, calc2;
                int move=atoi(session->escape_string+2);

                if (move==0)
                  move=1;

                calc=(int) session->assigned_area+
                           ((session->ypos*session->terminal_size_x)+
                           session->xpos)*4;
                calc2=(int) session->assigned_area+
                            ((session->ypos+1)*session->terminal_size_x)*4;

                _swi(ZapRedraw_MoveBytes, _INR(1,3), calc+(4*move), calc,
                                              calc2-calc-(4*move));

                clear_screen(session,

                             ((session->ypos*session->terminal_size_x)+
                              (session->xpos+move))*4,

                              ((session->ypos+1)*session->terminal_size_x)*4-4,

                              session->current_fg,
                              session->current_bg,
                              0,
                              32);

                done=true;
              }
              break;
            case 'X':
              /* Erase character(s) */
              clear_screen(session,

              	       ((session->ypos*session->terminal_size_x)+
                       session->xpos)*4,

              	       ((session->ypos*session->terminal_size_x)+
                       session->xpos+
                       atoi(session->escape_string+2))*4,

                       session->current_fg,
                       session->current_bg,
                       0,
                       32);

              done=true;
              break;
            case 'c':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'c':
                  {
                    char block[16];

                    strcpy(block,"\x1B[?6x;1;6c");

                    if (session->terminal_type<2)
                    {
                      block[4]='1';
                    }
                    else
                    {
                      block[4]='2';
                    }

                    nettle_senddata(session,block,strlen(block));
                  }
                  break;
              }
              break;
            case 'g':
              done=true;
              switch (session->escape_string[2])
              {
                case '0': case 'g':
                  /* Clear tab in current xpos */
                  {
                    int loop=0;
                    while (loop<session->number_of_tabs &&
                           session->xpos!=session->tabs[loop])
                    {
                      loop++;
                    }

                    if (session->xpos==session->tabs[loop])
                    {
                      int loop2;
                      for (loop2=loop+1; loop2<session->number_of_tabs; loop2++)
                      {
                        session->tabs[loop2-1]=
                        				     session->tabs[loop2];
                      }
                      session->number_of_tabs--;
                    }
                  }
                  break;
                case '3':
                  /* Clear all tabs */
                  session->number_of_tabs=0;
                  break;
              }
              break;
            case 'h':
              done=true;
              switch (session->escape_string[2])
              {
                case '?':
                  /* DIGITAL private modes */
                  {
                    int loop=3;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='h')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 1:
                          /* Cause the cursor to generate "application" control functions */
                          break;
                        case 3:
                          /* Selects 132 columns per line */
                          resize_terminal(session, 132,
                                                   session->terminal_size_y,
                                                   session->scrollback,
                                                   false);
                          break;
                        case 4:
                          /* Selects smooth scroll */
                          break;
                        case 5:
                          /* Selects reverse video */
                          session->other_session_flags=
                                       session->other_session_flags | NETTLE_OTHER_REVERSE_VIDEO;
                          break;
                        case 6:
                          /* Home position based in scrolling region */
                          session->other_session_flags=
                                         session->other_session_flags | NETTLE_OTHER_ORIGIN_MODE;

                          session->xpos=0;
                          session->ypos=session->scrollback+session->scroll_start-1;
                          break;
                        case 7:
                          /* Autowrap */
                          session->other_session_flags=
                                           session->other_session_flags | NETTLE_OTHER_WRAP_MODE;
                          break;
                        case 25:
                          /* Make cursor visible */
                          session->other_session_flags=
                                          session->other_session_flags | NETTLE_OTHER_CURSOR_VIS;
                          break;
                      }
                    }
                  }
                  break;
                default:
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='h')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 2:
                          /* Turn on keyboard lock */
                          session->other_session_flags=
                                        session->other_session_flags | NETTLE_OTHER_KEYLOCK_MODE;
                          break;
                        case 4:
                          /* Turn on insert mode */
                          session->other_session_flags=
                                         session->other_session_flags | NETTLE_OTHER_INSERT_MODE;
                          break;
                        case 8:
                          /* Turn on auto repeat */
                          break;
                        case 12:
                          /* Turn off local echo (NB. just using telnet's local echo stuff) */
                          session->session_flags[1]=true;
                          break;
                        case 20:
                          /* Make LF,FF,VT move to first column of next line */
                          session->other_session_flags=
                                       session->other_session_flags | NETTLE_OTHER_LINEFEED_MODE;
                          break;
                      }
                    }
                  }
                  break;
              }
              break;
            case 'l':
              done=true;

              switch (session->escape_string[2])
              {
                case '?':
                  /* DIGITAL private modes */
                  {
                    int loop=3;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='l')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 1:
                          /* Cause the cursor to generate ANSI cursor control sequences */
                          break;
                        case 2:
                          /* Sets the terminal to VT52 mode */
                          session->other_session_flags=
                                           session->other_session_flags | NETTLE_OTHER_VT52_MODE;
                          break;
                        case 3:
                          /* Selects 80 columns per line */
                          resize_terminal(session, 80,
                                                   session->terminal_size_y,
                                                   session->scrollback,
                                                   false);
                          break;
                        case 4:
                          /* Selects jump scroll */
                          break;
                        case 5:
                          /* Selects normal video */
                          session->other_session_flags=
                           session->other_session_flags &
                         					     ~NETTLE_OTHER_REVERSE_VIDEO;
                          break;
                        case 6:
                          /* Home position based in top-left of screen */
                          session->other_session_flags=
                           session->other_session_flags &
                           					       ~NETTLE_OTHER_ORIGIN_MODE;
                          break;
                        case 7:
                          /* No autowrap */
                          session->other_session_flags=
                           session->other_session_flags & ~NETTLE_OTHER_WRAP_MODE;
                          break;
                        case 8:
                          /* Turn off auto repeat */
                          break;
                        case 25:
                          /* Make cursor invisible */
                          session->other_session_flags=
                            session->other_session_flags &
                            						~NETTLE_OTHER_CURSOR_VIS;
                          break;
                      }
                    }
                  }
                  break;
                default:
                  {
                    int loop=2;
                    while (loop<session->escape_string_length-1)
                    {
                      char string[256]="";
                      while(session->escape_string[loop]!=';' &&
                            session->escape_string[loop]!='l')
                      {
                        string[strlen(string)+1]='\0';
                        string[strlen(string)]=session->escape_string[loop];
                        loop++;
                      }
                      loop++;

                      switch (atoi(string))
                      {
                        case 2:
                          /* Turn off keyboard lock */
                          session->other_session_flags=
                            session->other_session_flags
                            					    & ~NETTLE_OTHER_KEYLOCK_MODE;
                          break;
                        case 4:
                          /* Turn off insert mode */
                          session->other_session_flags=
                            session->other_session_flags
                            					     & ~NETTLE_OTHER_INSERT_MODE;
                          break;
                        case 12:
                          /* Turn on local echo (NB. just using telnet's echo stuff) */
                          session->session_flags[1]=false;
                          break;
                        case 20:
                          /* Make LF,FF,VT move to next line (normal behaviour) */
                          session->other_session_flags=
                            session->other_session_flags &
                         					~NETTLE_OTHER_LINEFEED_MODE;
                          break;
                      }
                    }
                  }
                  break;
              }
              break;
            case 'm':
              {
                bool status=false;
                int loop=2;

                done=true;

                if (session->current_fg & 8)
                {
                  status=true;
                }

                while (loop<session->escape_string_length)
                {
                  char string[256]="";
                  while(session->escape_string[loop]!=';' &&
                        session->escape_string[loop]!='m')
                  {
                    string[strlen(string)+1]='\0';
                    string[strlen(string)]=session->escape_string[loop];
                    loop++;
                  }
                  loop++;

	          switch (atoi(string))
	          {
	            case 0:
                      /* Clear all attributes */
                      status=false;
                      session->current_fg=7;
                      session->current_bg=0;
                      session->current_flags=0;
                      break;
                    case 1: case 5:
                      /* Bold, Blink */
                      session->current_fg=session->current_fg | 8;
                      status=true;
                      break;
                    case 27:
                      /* Cancel invert */
                      session->current_flags=
                      		session->current_flags & ~NETTLE_FLAG_INVERTED;
                      break;
                    case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
                      /* Foreground */
                      session->current_fg=atoi(string)-30;
                      if (status)
                      {
                        session->current_fg=
                                                          session->current_fg | 8;
                      }
                      break;
                    case 39:
                      session->current_fg=7;
                      break;
                    case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:
                      /* Background */
                      session->current_bg=atoi(string)-40;
                      break;
                    case 49:
                      session->current_bg=0;
                      break;
                    case 7:
                      /* Invert */
                      session->current_flags=
                              session->current_flags | (NETTLE_FLAG_INVERTED);
                      break;
                  }
                }
              }
              break;
            case 'n':
              done=true;
              switch (session->escape_string[2])
              {
                case '5':
                  {
                    char block[4];
                    block[0]=27;
                    block[1]='[';
                    block[2]='0'; /* terminal OK */
                    block[3]='n';
                    nettle_senddata(session,block,sizeof(block));
                  }
                  break;
                case '6':
                  {
                    char block[16];
                    sprintf(block,"\x1B[%d;%dR",session->ypos-
                    				session->scrollback+1,
                    				session->xpos+1);
                    nettle_senddata(session,block,strlen(block));
                  }
                  break;
                case '?':
                  if (session->escape_string[3]=='1')
                  {
                    if (session->escape_string[4]=='5')
                    {
                      char block[7];

                      /* There is no printer */
                      strcpy(block,"\x1B[?13n");
                      nettle_senddata(session,block,strlen(block));
                    }
                  }
                  break;
              }
              break;
            case 'p':
              done=true;
              switch (session->escape_string[2])
              {
                case '!':
                  /* Soft Reset terminal */
                  reset_terminal(session);
                  break;
              }
              break;
            case 'r':
              /* Specify scrolling region */
              done=true;

              if (esc_instr(session->escape_string,";",session->escape_string_length)>=0)
              {
                session->scroll_start=atoi(session->escape_string+2);

                session->scroll_end=atoi(session->escape_string+
                                                esc_instr(session->escape_string,
                                                ";",session->escape_string_length)
                                                +1);
              }
              else
              {
                session->scroll_start=1;
                session->scroll_end=session->terminal_size_y;
              }

              if (session->ypos<session->scrollback+session->scroll_start-1)
              {
                session->ypos=session->scrollback+session->scroll_start-1;
              }

              if (session->ypos>session->scrollback+session->scroll_end-1)
              {
                session->ypos=session->scrollback+session->scroll_end-1;
              }

              break;
          }
          break;
        case ']':
          if (session->escape_string[session->escape_string_length-1]==7)
          {
            switch (atoi(session->escape_string+2))
            {
              case 0:
                /* Change Icon Name and Window Title to Pt */
                {
                  char string[256];
                  int loop=esc_instr(session->escape_string,
                                     ";", session->escape_string_length)+1;
                  int counter=0;

                  while (session->escape_string[loop]!=7)
                  {
                    string[counter]=session->escape_string[loop];
                    counter++;
                    loop++;
                  }
                  string[counter]='\0';
                  set_title_bar(session->window_handle,string);
                }
                break;
              case 1:
                /* Change Icon Name to Pt */
                break;
              case 2:
                /* Change Window Title to Pt */
                {
                  char string[256];
                  int loop=esc_instr(session->escape_string,
                                     ";", session->escape_string_length)+1;
                  int counter=0;

                  while (session->escape_string[loop]!=7)
                  {
                    string[counter]=session->escape_string[loop];
                    counter++;
                    loop++;
                  }
                  string[counter]='\0';
                  set_title_bar(session->window_handle,string);
                }
                break;
              case 46:
                /* Change Log File to Pt */
                break;
              case 50:
                /* Set Font to Pt */
                break;
            }

            done=true;
          }
          break;
      }
      break;
    case 255:
      switch (session->escape_string[1])
      {
        case 250: /* SB */
          if (session->escape_string[session->escape_string_length-2]==255
              &&
              session->escape_string[session->escape_string_length-1]==240)
          {
            switch (session->escape_string[2])
            {
              case 24: /* TERMINAL-TYPE */
                if (session->escape_string[3]==1)
                {
                  /* SEND */
                  char block[256];
                  block[0]=255; /* IAC */
                  block[1]=250; /* SB */
                  block[2]=24;  /* TERMINAL-TYPE */
                  block[3]=0;   /* IS */
                  strcpy(block+4,terminal_name[session->terminal_type]);
                  block[4+strlen(terminal_name[session->terminal_type])]=255; /* IAC */
                  block[5+strlen(terminal_name[session->terminal_type])]=240; /* SE */
                  nettle_senddata(session,block,6+strlen(terminal_name[session->terminal_type]));
                  done=true;
                }
                break;
            }
          }
          break;
      }
      break;
  }
  return done;
}


static bool process_escape(struct session_struct *session)
{
  bool done=false;

  switch (session->escape_string_length)
  {
    case 0: case 1:
      /* strings of length 0 or 1 */
      done=false;
      break;
    case 2:
      /* strings of length 2 */
      done=process_escape_length_2(session);
      break;
    case 3:
      /* strings of length 3 */
      done=process_escape_length_3(session);
    default:
      /* strings of length >= 3 */
      if (!done)
      {
        done=process_escape_length_x(session);
      }
      break;
  }

  if (done)
  {
    session->escape_string_length=0;
    session->escape_state=NETTLE_ESCAPE_NONE;
  }

  return done;
}


void process_data(struct session_struct *session, char byte)
{
  bool done=false;

  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string_length==255)
    {
      generror("Escape sequence too long. This is probably due to an unsupported escape "
               "sequence. Please contact the author(s).", false);
      session->escape_state=NETTLE_ESCAPE_NONE;
      session->escape_string_length=0;
    }
    else
    {
      session->escape_string[session->escape_string_length]=byte;
      session->escape_string_length++;

      done = process_escape(session);
    }
  }

  if (session->escape_state==NETTLE_ESCAPE_ESCAPE)
  {
    if (session->escape_string[0]==255)
    {
      return;
    }
  }

  if (!done)
  {
    switch (byte)
    {
      /* VT codes */
      case 0:   byte_null                  (session); break;
      case 5:   byte_enquiry               (session); break;
      case 7:   byte_bell                  (session); break;
      case 8:   byte_backspace             (session); break;
      case 9:   byte_horizontal_tabulation (session); break;
      case 10:
      case 11:
      case 12:  byte_linefeed              (session); break;
      case 13:  byte_carriage_return       (session); break;
      case 14:  byte_shift_out             (session); break;
      case 15:  byte_shift_in              (session); break;
      case 17:  byte_device_control_1      (session); break;
      case 19:  byte_device_control_3      (session); break;
      case 24:  byte_cancel                (session); break;
      case 26:  byte_substitute            (session); break;
      case 27:  byte_escape                (session); break;
      case 127: byte_delete                (session); break;

      /* VT C1 codes */
      case 132: byte_index		   (session); break;
      case 133: byte_next_line		   (session); break;
      case 136: byte_horizontal_tab_set    (session); break;
      case 141: byte_reverse_index         (session); break;
      case 142: byte_single_shift_g2       (session); break;
      case 143: byte_single_shift_g3       (session); break;
      case 144: byte_device_control_string (session); break;
      case 155: byte_control_sequence_intro(session); break;
      case 156: byte_string_terminator     (session); break;

      /* Telnet codes */
      case 255: byte_telnet                (session); break;

      /* Other codes */
      default:
        if (session->escape_state==NETTLE_ESCAPE_NONE)
        {
                byte_default          (session, byte);
        }
        break;
    }
  }
}


static int decode_key(struct session_struct *session, int key, char *block)
{
  int size_of_block;

  switch (key)
  {
    case 0x00D:
      /* Return */
      if (session->other_session_flags & NETTLE_OTHER_LINEFEED_MODE)
      {
        strcpy(block,"\r\n\n");
        size_of_block=3;
      }
      else
      {
        strcpy(block,"\r\n");
        size_of_block=2;
      }
      break;
    case 0x01E:
      /* Home */
      strcpy(block,"\x1B[1~");
      size_of_block=4;
      break;
    case 0x07F:
      /* Delete */
      strcpy(block,"\x1B[3~");
      size_of_block=4;
      break;
    case 0x181:
      /* F1 */
      strcpy(block,"\x1BOP");
      size_of_block=3;
      break;
    case 0x182:
      /* F2 */
      strcpy(block,"\x1BOQ");
      size_of_block=3;
      break;
    case 0x183:
      /* F3 */
      strcpy(block,"\x1BOR");
      size_of_block=3;
      break;
    case 0x184:
      /* F4 */
      strcpy(block,"\x1BOS");
      size_of_block=3;
      break;
    case 0x185:
      /* F5 */
      strcpy(block,"\x1B[15~");
      size_of_block=5;
      break;
    case 0x186:
      /* F6 */
      strcpy(block,"\x1B[17~");
      size_of_block=5;
      break;
    case 0x187:
      /* F7 */
      strcpy(block,"\x1B[18~");
      size_of_block=5;
      break;
    case 0x188:
      /* F8 */
      strcpy(block,"\x1B[19~");
      size_of_block=5;
      break;
    case 0x189:
      /* F9 */
      strcpy(block,"\x1B[20~");
      size_of_block=5;
      break;
    case 0x18A:
      /* Tab */
      strcpy(block,"\t");
      size_of_block=1;
      break;
    case 0x18B:
      /* Copy */
      strcpy(block,"\x1B[4~");
      size_of_block=4;
      break;
    case 0x18C:
      /* Left */
      if (session->other_session_flags & NETTLE_OTHER_APPLI_MODE)
      {
        strcpy(block,"\x1BOD");
        size_of_block=3;
      }
      else
      {
        strcpy(block,"\x1B[D");
        size_of_block=3;
      }
      break;
    case 0x18D:
      /* Right */
      if (session->other_session_flags & NETTLE_OTHER_APPLI_MODE)
      {
        strcpy(block,"\x1BOC");
        size_of_block=3;
      }
      else
      {
        strcpy(block,"\x1B[C");
        size_of_block=3;
      }
      break;
    case 0x18E:
      /* Down */
      if (session->other_session_flags & NETTLE_OTHER_APPLI_MODE)
      {
        strcpy(block,"\x1BOB");
        size_of_block=3;
      }
      else
      {
        strcpy(block,"\x1B[B");
        size_of_block=3;
      }
      break;
    case 0x18F:
      /* Up */
      if (session->other_session_flags & NETTLE_OTHER_APPLI_MODE)
      {
        strcpy(block,"\x1BOA");
        size_of_block=3;
      }
      else
      {
        strcpy(block,"\x1B[A");
        size_of_block=3;
      }
      break;
    case 0x191:
      /* Shift+F1 */
      strcpy(block,"\x1B[23~");
      size_of_block=5;
      break;
    case 0x192:
      /* Shift+F2 */
      strcpy(block,"\x1B[24~");
      size_of_block=5;
      break;
    case 0x193:
      /* Shift+F3 */
      strcpy(block,"\x1B[25~");
      size_of_block=5;
      break;
    case 0x194:
      /* Shift+F4 */
      strcpy(block,"\x1B[26~");
      size_of_block=5;
      break;
    case 0x195:
      /* Shift+F5 */
      strcpy(block,"\x1B[28~");
      size_of_block=5;
      break;
    case 0x196:
      /* Shift+F6 */
      strcpy(block,"\x1B[29~");
      size_of_block=5;
      break;
    case 0x197:
      /* Shift+F7 */
      strcpy(block,"\x1B[31~");
      size_of_block=5;
      break;
    case 0x198:
      /* Shift+F8 */
      strcpy(block,"\x1B[32~");
      size_of_block=5;
      break;
    case 0x199:
      /* Shift+F9 */
      strcpy(block,"\x1B[33~");
      size_of_block=5;
      break;
    case 0x19E:
      /* Page down */
      strcpy(block,"\x1B[6~");
      size_of_block=4;
      break;
    case 0x19F:
      /* Page up */
      strcpy(block,"\x1B[5~");
      size_of_block=4;
      break;
    case 0x1CA:
      /* F10 */
      strcpy(block,"\x1B[21~");
      size_of_block=5;
      break;
    case 0x1CB:
      /* F11 */
      strcpy(block,"\x1B[23~");
      size_of_block=5;
      break;
    case 0x1CC:
      /* F12 */
      strcpy(block,"\x1B[24~");
      size_of_block=5;
      break;
    case 0x1CD:
      /* Insert */
      strcpy(block,"\x1B[2~");
      size_of_block=4;
      break;
    case 0x1DA:
      /* Shift+F10 */
      strcpy(block,"\x1B[34~");
      size_of_block=5;
      break;
    case 0x1DB:
      /* Shift+F11 */
      strcpy(block,"\x1B[23~");
      size_of_block=5;
      break;
    case 0x1DC:
      /* Shift+F12 */
      strcpy(block,"\x1B[24~");
      size_of_block=5;
      break;
    default:
      if (key<0x100)
      {
        sprintf(block,"%c",key);
        size_of_block=1;
      }
      else
      {
        size_of_block=0;
      }
      break;
  }

  return size_of_block;
}


void process_wimp_key(struct session_struct *session, int key)
{
  char block[256];
  int size_of_block=0;
  int calc;
  char cursor_flags;
  int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  if (session->other_session_flags & NETTLE_OTHER_KEYLOCK_MODE)
    return;

  calc=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session,calc) & (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  if ((cursor_flags & (NETTLE_FLAG_CURSOR))==0)
  {
    cursor_flags=(cursor_flags | (NETTLE_FLAG_CURSOR));
  }

  /* remove the cursor from the position */
  write_assigned_flags(session,calc,read_assigned_flags(session,calc)
						 & ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));

  size_of_block=decode_key(session,key,block);

  if (session->session_flags[1]==false)
  {
    int loop;
    int data;

    for (loop=0; loop<size_of_block; loop++)
    {
      switch (block[loop])
      {
        case 7: byte_bell                  (session); break;
        case 8: byte_backspace             (session);

          data=((session->ypos*session->terminal_size_x)+
             session->xpos)*4;

          write_assigned(session,data,session->current_fg,
          				     session->current_bg,
          				     session->current_flags,
          				     32);
         break;

        case 9:  byte_horizontal_tabulation(session); break;
        case 10: byte_linefeed             (session); break;
        case 13: byte_carriage_return      (session); break;

        default:
          reprocess_position(session);

          data=((session->ypos*session->terminal_size_x)+
             session->xpos)*4;

          if (block[loop]<32)
          {
            write_assigned(session,data,session->current_fg,
            				       session->current_bg,
            				       session->current_flags,
            				       '^');
            session->xpos++;
            reprocess_position(session);

            data=((session->ypos*session->terminal_size_x)+
                 session->xpos)*4;
          }

          /* write out the data */
          write_assigned(session,data,session->current_fg,
            				     session->current_bg,
            				     session->current_flags,
            				     '?');

          if (block[loop]<32)
          {
            write_assigned_character(session,data,block[loop]+64);
          }
          else
          {
            write_assigned_character(session,data,block[loop]);
          }
          session->xpos++;

          break;
      }
    }
  }

  nettle_senddata(session,block,size_of_block);

  calc=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session,calc,read_assigned_flags(session,calc) | cursor_flags);
  }

  /* force the selection back on (it may have got overwritten by new data) */
  refresh_selection_set();

  /* and redraw the window */
  force_redraw(session->window_handle,0,
               (-session->terminal_size_y-session->scrollback)*
               redraw.r_charh*2*zap_yeig,
                      session->terminal_size_x*redraw.r_charw*2,0);
}


void process_line_editor(struct session_struct *session)
{
  char *icon_text;
  char block[256];
  int size_of_block=0;
  int calc;
  char cursor_flags;
  char *send_block=0;
  int size_of_send_block=0;
  int icon_text_loop;
  int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  {
    char data[512];

    read_icon_data(session->pane_handle, 1, data, sizeof(data));

    icon_text = malloc(strlen(data) + 3);
    assert(icon_text != NULL);

    strcpy(icon_text, data);
    strcat(icon_text, "\r");
  }

  if (session->other_session_flags & NETTLE_OTHER_KEYLOCK_MODE)
    return;

  calc=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session,calc) &
                                 		     (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  if ((cursor_flags & (NETTLE_FLAG_CURSOR))==0)
  {
    cursor_flags=(cursor_flags | (NETTLE_FLAG_CURSOR));
  }

  /* remove the cursor from the position */
  write_assigned_flags(session,calc,read_assigned_flags(session,calc)
						 & ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));

  for (icon_text_loop=0; icon_text_loop<strlen(icon_text); icon_text_loop++)
  {
    int key=icon_text[icon_text_loop];

    size_of_block=decode_key(session,key,block);

    if (session->session_flags[1]==false)
    {
      int data;
      int loop;

      for (loop=0; loop<size_of_block; loop++)
      {
        switch (block[loop])
        {
          case 7: byte_bell                  (session); break;
          case 8: byte_backspace             (session);

            data=((session->ypos*session->terminal_size_x)+
               session->xpos)*4;

            write_assigned(session,data,session->current_fg,
            				       session->current_bg,
            				       session->current_flags,
            				       32);
            break;

          case 9:  byte_horizontal_tabulation(session); break;
          case 10: byte_linefeed             (session); break;
          case 13: byte_carriage_return      (session); break;

          default:
            reprocess_position(session);

            data=((session->ypos*session->terminal_size_x)+
               session->xpos)*4;

            if (block[loop]<32)
            {
              write_assigned(session,data,session->current_fg,
              					 session->current_bg,
              					 session->current_flags,
              					 '^');
              session->xpos++;
              reprocess_position(session);

              data=((session->ypos*session->terminal_size_x)+
                   session->xpos)*4;
            }

            /* write out the data */
              write_assigned(session,data,session->current_fg,
              					 session->current_bg,
              					 session->current_flags,
              					 '?');

            if (block[loop]<32)
            {
              write_assigned_character(session,data,block[loop]+64);
            }
            else
            {
              work_out_character(session,data,block[loop]);
            }
            session->xpos++;

            break;
        }
      }
    }
    send_block=realloc(send_block,size_of_send_block+size_of_block); /* FIXME: Dangerous use of realloc() */
    strncpy(send_block+size_of_send_block,block,size_of_block);
    size_of_send_block+=size_of_block;
  }

  nettle_senddata(session,send_block,size_of_send_block);


  calc=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session,calc,read_assigned_flags(session,calc) | cursor_flags);
  }

  /* force the selection back on (it may have got overwritten by new data) */
  refresh_selection_set();

  /* and redraw the window */
  force_redraw(session->window_handle,0,
               (-session->terminal_size_y-session->scrollback)*
               redraw.r_charh*2*zap_yeig,
                      session->terminal_size_x*redraw.r_charw*2,0);

  {
    int loop;

    for (loop=line_editor_size-1; loop>1; loop--)
    {
      strcpy(session->line_editor_history+(loop*512),
        	   session->line_editor_history+((loop-1)*512));
    }
  }

  strcpy(session->line_editor_history+(1*512),
         icon_text);

  set_icon_data(session->pane_handle,1,"");

  set_caret_position(session->pane_handle, 1, -1, 0);

  session->line_editor_position=0;
  session->line_editor_total++;

  if (session->line_editor_total>line_editor_size)
  {
    session->line_editor_total=line_editor_size;
  }

  free(send_block);
  free(icon_text);
}


/* get the current cursor position */
int get_cursor_position(struct session_struct *session)
{
  int xpos;
  int calc;

  xpos=session->xpos;

  while (xpos>=session->terminal_size_x)
  {
    xpos--;
  }

  calc=((session->ypos*session->terminal_size_x)+
         xpos)*4;

  while (calc>=((session->terminal_size_y+session->scrollback)*
    			session->terminal_size_x)*4)
  {
    calc-=4;
  }

  return calc;
}
