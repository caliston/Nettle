/**
 * Nettle specific code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "lineedit.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "socket.h"
#include "wimp.h"
#include "zapredraw.h"



#ifdef DEBUG
typedef struct assigned_data
{
  char fg;
  char bg;
  char flags;
  char character;
}
assigned_data;

void dumptermdata(struct session_struct *session)
{
  int x;
  int y;

  for (y = 0; y < session->terminal_size_y; y++)
  {
    for (x = 0; x < session->terminal_size_x; x++)
    {
      assigned_data *ptr;

      ptr = (assigned_data *) session->assigned_area;
      ptr += y * session->terminal_size_x + x;
      printf("[%02d,%02d]: ", x, y);
      printf("'%c' (bg %d, fg %d, flags %x)\n",
             ptr->character, ptr->bg, ptr->fg, ptr->flags);
    }
  }
}

#endif /* DEBUG */



void start_connection(void)
{
  char string[1024];
  int loop;
  int connection_type;
  enum nettle_terminal terminal_type;
  int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);
  struct session_struct *session;

  session = malloc(sizeof(struct session_struct));
  if (session == NULL)
  {
    generror("TooMany", true); /* ought to give a different message, really */
    return;
  }

  /* Insert into list */
  session->prev = NULL;
  session->next = sessions;
  if (sessions)
  {
    sessions->prev = session;
  }
  sessions = session;

  /* clear all the session flags */
  for (loop=0; loop<256; loop++)
  {
    session->session_flags[loop]=false;
  }

  read_icon_data(win_open, 4, string, sizeof(string));

  {
    char connection[MESSAGE_MAX_CONNECTION];

    if (strcmp(string, lookup("SSH", connection, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_SSH;
    else if (strcmp(string, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_TASKWINDOW;
    else
      connection_type=NETTLE_TELNET;
  }

  read_icon_data(win_open, 9, string, sizeof(string));

  terminal_type = NETTLE_TERMINAL_VT100;
  for (loop=0; loop<8; loop++)
  {
    char type[MESSAGE_MAX_TERMINAL];
    char term[7];
    sprintf(term,"Term%d",loop);
    if (strcmp(string,lookup(term, type, MESSAGE_MAX_TERMINAL))==0)
      terminal_type = (enum nettle_terminal)loop;
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
      read_icon_data(win_open, 0, string, sizeof(string));

      if (strlen(string)==0)
      {
        generror("InvalidAddr", true);
        sessions = session->next;
        if (sessions)
        {
          sessions->prev = NULL;
        }
        free(session);
        return;
      }

      /* strip off telnet: if it's there */
      if (strncmp(string,"telnet:",strlen("telnet:"))==0)
      {
        strcpy(string,string+strlen("telnet:")+1);
      }

      /* strip out any /s anywhere in the string */
      loop=0;
      while (loop<strlen(string))
      {
        char temp_string[256];

        if (string[loop]=='/')
        {
          if (loop>0)
          {
            strncpy(temp_string,string,loop-1);
            temp_string[loop]='\0';
          }
          else
          {
            strcpy(temp_string,"");
          }

          strcat(temp_string,string+loop+1);
          strcpy(string,temp_string);
        }
        else
        {
          loop++;
        }
      }

      /* look at the string to find a port if any (separated by colon or comma) */
      if (instr(string,",")>=0)
      {
        strncpy(session->socket_host,string,instr(string,","));
        session->socket_host[instr(string,",")]='\0';
        session->socket_port=atoi(string+instr(string,",")+1);
      }
      else
      {
        if (instr(string,":")>=0)
        {
          strncpy(session->socket_host,string,instr(string,":"));
          session->socket_host[instr(string,":")]='\0';
          session->socket_port=atoi(string+instr(string,":")+1);
        }
        else
        {
          strcpy(session->socket_host,string);
          session->socket_port=23;
        }
      }

      /* if the port is <1, then it's either invalid or was too big and got wrapped */
      if (session->socket_port<1)
      {
        generror("InvalidPort", true);
        sessions = session->next;
        if (sessions)
        {
          sessions->prev = NULL;
        }
        free(session);
        return;
      }

      session->socket_handle=0;
      session->socket_state=NETTLE_SESSION_RESOLVE;

      close_window(win_open);

      break;
    case NETTLE_TASKWINDOW:
      read_icon_data(win_open, 7, string, sizeof(string));
      if (strlen(string)==0)
      {
        generror("InvalidComm", true);
        sessions = session->next;
        if (sessions)
        {
          sessions->prev = NULL;
        }
        free(session);
        return;
      }

      /* start the task window */
      {
        char temp_string[1024];
        sprintf(temp_string,"%%TaskWindow \"%s\" -ctrl -name \"Nettle task\" -quit -task &%X \
        		     -txt &%X",string,task_handle,(int)session);

        _swi(Wimp_StartTask, _IN(0), temp_string);
      }

      /* set ECHO bit to true */
      session->session_flags[1]=true;

      close_window(win_open);

      break;
  }

  /* set all the attributes to their defaults */
  session->terminal_size_x=80;
  session->terminal_size_y=24;
  session->scrollback=96;
  session->title=malloc(256);
  assert(session->title != NULL);
  strcpy(session->title,"");
  session->assigned_area=malloc(session->terminal_size_x*
                                                (session->terminal_size_y+
                                                 session->scrollback)*4);
  assert(session->assigned_area);
  session->xpos=0;
  session->ypos=session->scrollback;
  session->connection_type=connection_type;
  session->terminal_type=terminal_type;
  reset_terminal(session);

  /* clear out the assigned area with black bg, white fg, no flags and ' ' */
  {
    int loop_limit=((session->terminal_size_x)*
                   (session->terminal_size_y+
                    session->scrollback)*4);

    for (loop=0; loop<loop_limit; loop+=4)
    {
      write_assigned(session,loop,7,0,0,32);
    }
  }

  /* create tabs */
  session->number_of_tabs=0;
  for (loop=0; loop<session->terminal_size_x; loop+=8)
  {
    session->tabs[session->number_of_tabs]=loop;
    session->number_of_tabs++;
  }

  /* if line editor is turned on, allocate all the lineeditor space */
  if (line_editor)
  {
    session->line_editor_history=malloc(line_editor_size*512*sizeof(char));
    assert(session->line_editor_history != NULL);
    session->line_editor_position=0;
    session->line_editor_total=1;

    for (loop=0; loop<line_editor_size; loop++)
    {
      strcpy(session->line_editor_history+(loop*512),"");
    }

    strcpy(session->line_editor_buffer,"");
  }

  /* make new terminal window */
  {
    struct wimp_createwindow_block block;

    block.minx         =102;
    block.miny         =1088-(session->terminal_size_y*redraw.r_charh*2*zap_yeig);
    block.maxx         =102+(session->terminal_size_x*redraw.r_charw*2);
    block.maxy         =1088;
    block.scroll_x     =0;
    block.scroll_y     =-((session->terminal_size_y+
                           session->scrollback)
                          *(redraw.r_charh*2*zap_yeig));
    block.handle_behind=-1;
    block.window_flags =0xff000002;
    block.title_fg     =7;
    block.title_bg     =2;
    block.work_fg      =7;
    block.work_bg      =0xFF;

    block.scroll_outer_colour=3;
    block.scroll_inner_colour=1;
    block.title_focus_colour =12;
    block.flags              =0;

    block.work_minx=0;
    block.work_miny=-((session->terminal_size_y+
                       session->scrollback)
                      *(redraw.r_charh*2*zap_yeig));
    block.work_maxx=session->terminal_size_x*redraw.r_charw*2;
    block.work_maxy=0;

    block.icon_flags    =0x00000119;
    block.workarea_flags=6<<12;
    block.sprite_area   =(struct os_spriteop_area *) 1;
    block.min_width     =4;
    block.min_height    =4;

    block.title.it.text      =session->title;
    block.title.it.validation=0;
    block.title.it.text_len  =256;

    block.number_of_icons    =0;

    session->window_handle = _swi(Wimp_CreateWindow, _IN(1)|_RETURN(0), &block);

    set_title_bar(session->window_handle,"nettle");
  }

  if (line_editor)
  {
    /* Create new pane window */
    struct wimp_createwindow_block block;

    block.minx=102;
    block.miny=1088-(session->terminal_size_y*redraw.r_charh*2*zap_yeig)-40;
    block.maxx=102+(session->terminal_size_x*redraw.r_charw*2);
    block.maxy=1088-(session->terminal_size_y*redraw.r_charh*2*zap_yeig);

    block.scroll_x=0;
    block.scroll_y=0;

    block.handle_behind=-1;
    block.window_flags =0x80080162;

    block.title_fg     =7;
    block.title_bg     =2;
    block.work_fg      =7;
    block.work_bg      =1;

    block.scroll_outer_colour=3;
    block.scroll_inner_colour=1;
    block.title_focus_colour =12;
    block.flags              =0;

    block.work_minx=0;
    block.work_miny=-48;
    block.work_maxx=session->terminal_size_x*redraw.r_charw*2;
    block.work_maxy=0;

    block.icon_flags    =0x00000000;
    block.workarea_flags=0<<12;

    block.sprite_area=(struct os_spriteop_area *) 1;
    block.min_width  =4;
    block.min_height =4;

    block.title.it.text      =0;
    block.title.it.validation=0;
    block.title.it.text_len  =0;

    block.number_of_icons    =0;

    session->pane_handle=_swi(Wimp_CreateWindow, _IN(1)|_RETURN(0), &block);
  }

  open_window(session->window_handle,false);

  if (line_editor)
  {
    set_caret_position(session->pane_handle,1,-1,
				strlen(read_icon_data(session->pane_handle, 1, string, 1024)));
  }
  else
  {
    set_caret_position(session->window_handle,-1,-1,-1);
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
      set_title_bar(session->window_handle,"nettle (Connecting)");
      write_out_string(session,"nettle: Looking up host ");
      write_out_string(session,session->socket_host);
      write_out_string(session,"...\r\n");
      break;
  }

  /* make a ZapRedraw area big enough - note: the assembly is quite
   * inefficient, so writes out the stuff to change the colour every
   * 'character', which means typically each character takes up 5 bytes, so 6
   * is a number >5. Basically if you start getting screens full of graphics
   * characters and stuff, 6 isn't enough. Possibly the draw routine should
   * stop writing when it falls outside the area, and the number returned at
   * the end - it could  make a larger buffer, but not done yet.
   */

  if (size_of_zapredraw_area < session->terminal_size_x *
    (session->terminal_size_y + session->scrollback) * 8) /* 8 is 'some value' */
  {
    int *new_zapredraw_area;

    size_of_zapredraw_area = session->terminal_size_x *
      (session->terminal_size_y + session->scrollback) * 8; /* same here */

    new_zapredraw_area = realloc(zapredraw_area, size_of_zapredraw_area);
    assert(new_zapredraw_area != NULL);
    zapredraw_area = new_zapredraw_area;
  }
}

void write_out_string(struct session_struct *session, const char *string)
{
  write_out_data(session, string, strlen(string));
}

void write_out_data(struct session_struct *session, const char *data, int length_data)
{
  int loop, calc;
  char cursor_flags;
  int zap_yeig;

  if (length_data == 0) {
    return;
  }

  zap_yeig = _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  calc=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session, calc) &
        (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  if ((cursor_flags & (NETTLE_FLAG_CURSOR))==0)
  {
    cursor_flags=(cursor_flags | (NETTLE_FLAG_CURSOR));
  }

  /* remove the cursor from the position */
  write_assigned_flags(session, calc, read_assigned_flags(session, calc) &
      ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));

  for (loop = 0; loop < length_data; loop++)
  {
    /* log the byte */
    log_byte(data[loop]);

    /*fclose(log_file); */
    /*log_file=0; */

    /* process the current byte at this position */
    process_data(session, data[loop]);
  }

  calc=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session, calc, read_assigned_flags(session, calc) | cursor_flags);
  }

  /* force the selection back on (it may have got overwritten by new data) */
  refresh_selection_set();

  /* and redraw the window */
  force_redraw(session->window_handle,0,
               (-session->terminal_size_y-session->scrollback)*
               redraw.r_charh*2*zap_yeig,
                      session->terminal_size_x*redraw.r_charw*2,0);
}


void remove_session(struct session_struct *session)
{
  if (session->socket_handle != 0)
  {
    switch (session->connection_type)
    {
      case NETTLE_TELNET:
        socket_close(session->socket_handle);
        break;
      case NETTLE_TASKWINDOW:
        {
          /* terminate the taskwindow */
          union wimp_poll_block block;

          block.user_message.length      =20;
          block.user_message.my_ref      =0;
          block.user_message.message_code=0x808C4;

          _swi(Wimp_SendMessage, _INR(0,2), 17, &block, session->socket_handle);
        }
        break;
    }
  }

  {
    /* delete the windows */
    struct wimp_deletewindow_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_DeleteWindow, _IN(1), &block);

    if (line_editor)
    {
      block.window_handle=session->pane_handle;

      _swi(Wimp_DeleteWindow, _IN(1), &block);
    }
  }

  /* free lineeditor space */
  if (line_editor)
  {
    free(session->line_editor_history);
  }

  /* free the assigned area and title */
  free(session->assigned_area);
  free(session->title);

  if (session->prev)
  {
    session->prev->next = session->next;
  }
  else
  {
    sessions = session->next;
  }

  if (session->next)
  {
    session->next->prev = session->prev;
  }

  /* cancel the selection if there was one in this session */
  if (selection_session == session)
  {
    selection_session = NULL;
  }

  if (current_session == session)
  {
    current_session = session->next;
  }

  free(session);
}

void nettle_senddata(struct session_struct *session, char *data, int length)
{
  switch (session->connection_type)
  {
    case NETTLE_TELNET:
      /* just use socket_senddata */
      socket_senddata(session->socket_handle,data,length);
      break;
    case NETTLE_TASKWINDOW:
      {
        /* send a WIMP message */
        int loop=0;
        union wimp_poll_block block;

        while (loop<length)
        {
          block.user_message.contents.task_window_input.data[loop]=data[loop];
          loop++;
        }

        block.user_message.length                         =(27+length) & ~3;
        block.user_message.my_ref                         =0;
        block.user_message.message_code                   =0x808C0;
        block.user_message.contents.task_window_input.size=length;

        _swi(Wimp_SendMessage, _INR(0,2), 17, &block, session->socket_handle);
      }
      break;
  }
}

void reset_terminal(struct session_struct *session)
{
  session->other_session_flags=NETTLE_OTHER_CURSOR_VIS | NETTLE_OTHER_WRAP_MODE
  						/*| NETTLE_OTHER_LINEFEED_MODE*/;
  session->current_fg=7;
  session->current_bg=0;
  session->current_flags=0;
  session->escape_string_length=0;
  session->escape_state=NETTLE_ESCAPE_NONE;
  session->scroll_start=1;
  session->scroll_end=session->terminal_size_y;
  session->character_set=NETTLE_CHSET_G0;

  session->character_set_g0=NETTLE_CHSET_US;
  session->character_set_g1=NETTLE_CHSET_US;
  session->character_set_g2=NETTLE_CHSET_US;
  session->character_set_g3=NETTLE_CHSET_US;
}

void write_assigned(struct session_struct *session ,int pointer, char fg, char bg, char flags, char character)
{
  if (pointer<0 || pointer>(session->terminal_size_y+
    			    session->scrollback)*
    			    session->terminal_size_x*4)
  {
    printf("Attempt to write to outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return;
  }

  *(session->assigned_area+(pointer+0))=fg;
  *(session->assigned_area+(pointer+1))=bg;
  *(session->assigned_area+(pointer+2))=flags;
  *(session->assigned_area+(pointer+3))=character;
}

char read_assigned_fg(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>(session->terminal_size_y+
    			    session->scrollback)*
    			    session->terminal_size_x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+0));
}

char read_assigned_bg(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>(session->terminal_size_y+
    			    session->scrollback)*
    			    session->terminal_size_x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+1));
}

char read_assigned_flags(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>(session->terminal_size_y+
    			    session->scrollback)*
    			    session->terminal_size_x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+2));
}

char read_assigned_character(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>(session->terminal_size_y+
    			    session->scrollback)*
    			    session->terminal_size_x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+3));
}

void write_assigned_flags(struct session_struct *session, int pointer, char flags)
{
  if (pointer<0 || pointer>(session->terminal_size_y+
    			    session->scrollback)*
    			    session->terminal_size_x*4)
  {
    printf("Attempt to write to outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return;
  }

  *(session->assigned_area+(pointer+2))=flags;
}

void write_assigned_character(struct session_struct *session, int pointer, char character)
{
  if (pointer<0 || pointer>(session->terminal_size_y+
    			    session->scrollback)*
    			    session->terminal_size_x*4)
  {
    printf("Attempt to write to outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return;
  }

  *(session->assigned_area+(pointer+3))=character;
}

void resize_terminal(struct session_struct *session, int terminal_size_x, int terminal_size_y,
                     int scrollback, bool use_naws)
{
  char *old_assigned_area=session->assigned_area;
  int old_terminal_size_x=session->terminal_size_x;
  int old_terminal_size_y=session->terminal_size_y;

  session->assigned_area  =malloc(terminal_size_x*(terminal_size_y+scrollback)*4);
  assert(session->assigned_area != NULL);
  session->terminal_size_x=terminal_size_x;
  session->terminal_size_y=terminal_size_y;
  session->scrollback     =scrollback;

  /* Blank area */
  /* remove once move is implemented */
  {
    int loop;

    for (loop=0; loop<terminal_size_x*(terminal_size_y+scrollback)*4; loop+=4)
    {
      write_assigned(session, loop, 7, 0, 0, 32);
    }
  }

  /* move old data to new area */
  /* Implement... */

  free(old_assigned_area);

  if (size_of_zapredraw_area < session->terminal_size_x *
    (session->terminal_size_y + session->scrollback) * 8) /* 8 is 'some
    value' */
  {
    int *new_zapredraw_area;

    size_of_zapredraw_area = session->terminal_size_x *
      (session->terminal_size_y + session->scrollback) * 8; /* same here */

    new_zapredraw_area = realloc(zapredraw_area, size_of_zapredraw_area);
    assert(new_zapredraw_area != NULL);
    zapredraw_area = new_zapredraw_area;
  }

  reopen_and_size_window(session, old_terminal_size_x, old_terminal_size_y,
                         redraw.r_charw, redraw.r_charh);

  if (use_naws)
  {
    if (session->session_flags[31])
    {
      /* NAWS is on */
      char block[9];

      block[0]=255; /* IAC */
      block[1]=250; /* SB */
      block[2]=31;  /* NAWS */
      block[3]=session->terminal_size_x / 256;
      block[4]=session->terminal_size_x % 256;
      block[5]=session->terminal_size_y / 256;
      block[6]=session->terminal_size_y % 256;
      block[7]=255; /* IAC */
      block[8]=240; /* SE */
      nettle_senddata(session, block, 9);
    }
  }
}

void reopen_and_size_window(struct session_struct *session, int old_terminal_size_x,
                            int old_terminal_size_y, int old_charw, int old_charh)
{
  int zap_yeig=_swi(OS_ReadModeVariable, _IN(0)|_IN(1)|_RETURN(2), -1, 5);

  {
    struct wimp_setextent_block block;

    block.minx=0;
    block.miny=-((session->terminal_size_y+session->scrollback)*redraw.r_charh*2*zap_yeig);
    block.maxx=session->terminal_size_x*redraw.r_charw*2;
    block.maxy=0;

    _swi(Wimp_SetExtent, _INR(0,1), session->window_handle, &block);

    if (line_editor)
    {
      block.minx=0;
      block.miny=-48;
      block.maxx=session->terminal_size_x*redraw.r_charw*2;
      block.maxy=0;

      _swi(Wimp_SetExtent, _INR(0,1), session->pane_handle, &block);
    }
  }

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    /* If terminal at fullsize, then reopen window at fullsize, otherwise leave it */
    if (block.maxx-block.minx==(old_terminal_size_x*old_charw*2))
    {
      block.maxx=block.minx+(session->terminal_size_x*redraw.r_charw*2);
    }
    if (block.maxy-block.miny==(old_terminal_size_y*old_charh*2*zap_yeig))
    {
      block.miny=block.maxy-(session->terminal_size_y*redraw.r_charh*2*zap_yeig);
    }

    /* wimp_openwindow_block is essentially the same as wimp_getwindowstate_block */
    _swi(Wimp_OpenWindow, _IN(1), &block);

    force_redraw(session->window_handle,0,
                 (-session->terminal_size_y-session->scrollback)*
                 redraw.r_charh*2*zap_yeig,
                        session->terminal_size_x*redraw.r_charw*2,0);
    if (line_editor)
      open_pane_window(session, (struct wimp_openwindow_block *) &block);
  }
}
