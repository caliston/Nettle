/**
 * Nettle specific code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "lineedit.h"
#include "main.h"
#include "messages.h"
#include "misc.h"
#include "mouse.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "socket.h"
#include "spool.h"
#include "templ.h"
#include "wimp.h"
#include "wimputil.h"
#include "zapredraw.h"


static void allocate_zapredraw_area(int, int, int);
static void start_connection_int (struct connection_params *params );


static void rehash_blink(void)
{
  struct session_struct *session = sessions;
  want_blink = false;

  for(;session;session=session->next)
  {
    if (session->want_blink)
    {
      want_blink = true;
      return;
    }
  }
}

int get_host_port (char *string, int *port)
/* modifies string, returns true on error */
{
  int loop;
  char *sptr;

  if (! *string)
  {
    generror("InvalidAddr", true);
    return true;
  }

  /* strip off telnet: if it's there */
  if (strncmp (string, "telnet:", 7) == 0)
    strcpy (string, string + 7);

  /* strip out any /s anywhere in the string */
  loop=0;
  while (string[loop])
  {
    if (string[loop] == '/')
      memmove (string + loop, string + loop + 1, strlen (string + loop));
    loop++;
  }

  /* look at the string to find a port if any (separated by colon, space or comma) */
  sptr = strpbrk (string, ": ,");
  if (sptr)
  {
    *sptr = '\0';
    *port = atoi (sptr + 1);
  }
  else
    *port = 23;

  /* if the port is <1, then it's either invalid or was too big and got wrapped */
  if (*port < 1)
  {
    generror("InvalidPort", true);
    return true;
  }

  /* success */
  return false;
}

bool start_connection_friedport(struct connection_params *params )
{
  int port;
  char host[256];

  if (params->connection_type != NETTLE_TASKWINDOW)
  {
    if (!params->host)
      return false;

    strcpy(host,params->host);
    if (get_host_port (host, &port))
      return false;

    params->host = host;
    params->port = port;
  }

  start_connection_int(params);

  return true;
}


bool nettle_start_telnet_connection(const char *host, int port)
{
  struct connection_params params;

  params.connection_type  = NETTLE_TELNET;
  params.terminal_type    = default_terminal;
  params.host             = host;
  params.port             = port;
  params.command          = NULL;
  params.width            = defaultsize.x;
  params.height           = defaultsize.y;
  params.scrollback       = defaultscroll;
  params.line_editor_type = line_editor;
  sprintf(params.label, "%.*s:%d", (int)sizeof(params.label) - 16, host, port);

  start_connection_int(&params);

  return true;
}



bool nettle_start_taskwindow(const char *cmd)
{
  struct connection_params params;

  params.connection_type  = NETTLE_TASKWINDOW;
  params.terminal_type    = default_terminal;
  params.host             = NULL;
  params.port             = 0;
  params.command          = cmd;
  params.width            = defaultsize.x;
  params.height           = defaultsize.y;
  params.scrollback       = defaultscroll;
  params.line_editor_type = line_editor;
  params.label[0]         = '\0';
  strncat(params.label, cmd, sizeof(params.label) - 1);

  start_connection_int(&params);

  return true;
}



bool start_connection(void)
{
  struct connection_params params;
  char string[1024];
  int loop;
  int connection_type;
  enum nettle_terminal terminal_type;
  int port;

  read_icon_data(win_open, icon_open_contype, string, sizeof(string));

  {
    char connection[MESSAGE_MAX_CONNECTION];

    if (strcmp(string, lookup("SSH", connection, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_SSH;
    else if (strcmp(string, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_TASKWINDOW;
    else
      connection_type=NETTLE_TELNET;
  }

  terminal_type = read_terminal_type (win_open, icon_open_termtype);

  params.connection_type  = connection_type;
  params.terminal_type    = terminal_type;
  params.host             = NULL;
  params.port             = 0;
  params.command          = NULL;
  params.width            = defaultsize.x;
  params.height           = defaultsize.y;
  params.scrollback       = defaultscroll;
  params.line_editor_type = line_editor;
  params.label[0]         = '\0';

  switch (connection_type)
  {
    case NETTLE_TELNET:
      read_icon_data(win_open, icon_open_host, string, sizeof(string));
      if (get_host_port (string, &port))
        return false;

      params.host = string;
      params.port = port;
      start_connection_int (&params);
      break;

    case NETTLE_TASKWINDOW:
      read_icon_data (win_open, icon_open_command, string, sizeof (string));
      loop = strlen (string);
      while (string[loop - 1] == ' ')
	loop--;
      string[loop] = '\0';		/* trim trailing spaces */
      loop = strspn (string, " ");	/* number of leading spaces */

      params.command = string+loop;
      start_connection_int (&params);
      break;

    default:
      break;
  }
  return true;
}


static void start_connection_int (struct connection_params *params )
{
#define INITIAL_MAX_Y (1088)
  static int max_y = INITIAL_MAX_Y; /* the top of the next window to be opened */
  int loop;
  struct session_struct *session;

  if (params->connection_type == NETTLE_SSH)
    return; /* Not implemented yet! */

  if (params->label[0]=='\0')
  {
    switch(params->connection_type)
    {
    case NETTLE_TASKWINDOW:
      if (params->command)
        strcpy(params->label, params->command);
      else
        sprintf(params->label, "<%s>", lookup_static("taskwindow"));
      break;

    case NETTLE_TELNET:
      if (!params->host)
        return;
      if (params->port!=23)
        sprintf(params->label, "%s:%d", params->host, params->port);
      else
        strcpy(params->label, params->host);
      break;

    case NETTLE_SSH:
      if (!params->host)
        return;
      if (params->port!=22)
        sprintf(params->label, "%s:%d", params->host, params->port);
      else
        strcpy(params->label, params->host);
      break;
    }
  }

  session = malloc(sizeof(struct session_struct));
  if (session == NULL)
  {
    generror("TooMany", true); /* ought to give a different message, really */
    return;
  }

  /* Insert into list */
  session->prev = NULL;
  session->next = sessions;
  if (sessions)
  {
    sessions->prev = session;
  }
  sessions = session;

  /* clear all the session flags */
  for (loop=0; loop<256; loop++)
  {
    session->session_flags[loop]=false;
  }
  session->local_echo = true;
  session->want_blink = false;
  session->socket_state = NETTLE_SESSION_NONE;

  session->dns = NULL; /* Should be null for non telnet/ssh sessions */

  switch (params->connection_type)
  {
    case NETTLE_TELNET:
      /* host, port already parsed */
      session->socket_handle=0;
      session->socket_state=NETTLE_SESSION_RESOLVE;
      session->socket_port = params->port;
      strcpy (session->socket_host, params->host);
      session->dns = dns_gethostbyname(session->socket_host);
      assert(session->dns != NULL);
      break;

    case NETTLE_TASKWINDOW:
      /* start the task window */
      {
        char temp_string[1024];

        sprintf(temp_string, "%d", params->height);
        _swi(OS_SetVarVal, _INR(0,4), "LINES", temp_string, strlen(temp_string), 0, 4);
        _swi(OS_SetVarVal, _INR(0,4), "ROWS", temp_string, strlen(temp_string), 0, 4); /* for old unixlib progs */
        sprintf(temp_string, "%d", params->width);
        _swi(OS_SetVarVal, _INR(0,4), "COLUMNS", temp_string, strlen(temp_string), 0, 4);

        if (params->command && params->command[0]!='\0')
        {
           FILE *pipefile;

          /* To disable escape in ANSI TaskWindows, we need to execute
             *FX 229,1 before the task proper is run.  Make an Obey file
             in Pipe: to achieve this */

           pipefile = fopen("Pipe:$.NettleTask", "w");
           if (!pipefile)
           {
             generror("NoStartTask", true);
             return;
           }
           else
           {
             fprintf(pipefile, "fx 229 1\n%s\n", params->command);
             fclose(pipefile);
             misc_setfiletype("Pipe:$.NettleTask", 0xfeb);

             sprintf (temp_string, "%%TaskWindow \"%%Obey -c Pipe:$.NettleTask\" -ctrl -name \"Nettle task - %s\"" \
                        " -quit -task &%X -txt &%X", params->command, task_handle, (int)session);
           }
        }
        else
        {
          sprintf (temp_string, "%%TaskWindow -ctrl -name \"Nettle task\"" \
                     " -task &%X -txt &%X", task_handle, (int)session);
        }



        _swi(Wimp_StartTask, _IN(0), temp_string);
      }

      /* set ECHO bit to true */
      session->session_flags[1]=true;
      session->local_echo = false;

      break;
  }

  /* set all the attributes to their defaults */
  strcpy(session->label, params->label);
  session->terminal_size.x = params->width;
  session->terminal_size.y = params->height;
  session->scrollback = params->scrollback;
  session->title=malloc(256);
  assert(session->title != NULL);
  strcpy(session->title,"");

  create_terminal(session, session->terminal_size, session->scrollback);

  session->pos.x=0;
  session->pos.y=session->scrollback;
  session->connection_type=params->connection_type;
  session->terminal_type=params->terminal_type;
  session->paste=NULL;
  session->paste_head=NULL;
  session->window_needs_resized=false;
  reset_terminal(session);

  /* clear out the assigned area with black bg, white fg, no flags and ' ' */
  clear_screen(session,
               0,
               session->terminal_size.x*(session->terminal_size.y+session->scrollback),
               7,
               0,
               0,
               ' ');

  copy_main_alternate(session);

  /* create tabs */
  session->number_of_tabs=0;
  for (loop=0; loop<session->terminal_size.x; loop+=8)
  {
    session->tabs[session->number_of_tabs]=loop;
    session->number_of_tabs++;
  }

  session->line_editor_type=params->line_editor_type;

  session->spool_file_name=NULL; /* make sure filename is undefined */

  /* if line editor is turned on, allocate all the lineeditor space */
  if (session->line_editor_type==LINEEDIT_NONE)
    session->pane_handle=0;
  else
    lineedit_allocate_space(session);

  /* make new terminal window */
  {
    struct wimp_createwindow_block block;

    block.min.x         =102;
    block.min.y         =max_y-(session->terminal_size.y*redraw.r_charh << eig.y);
    block.max.x         =102+(session->terminal_size.x*redraw.r_charw << eig.x);
    block.max.y         =max_y;
    block.scroll.x      =0;
    block.scroll.y      =-((session->terminal_size.y+
                           session->scrollback)
                          *(redraw.r_charh << eig.y));
    block.handle_behind =-1;
    block.window_flags  =0xff000002;
    block.title_fg      =7;
    block.title_bg      =2;
    block.work_fg       =7;
    block.work_bg       =0xFF;

    block.scroll_outer_colour=3;
    block.scroll_inner_colour=1;
    block.title_focus_colour =12;
    block.flags              =0;

    block.work_min.x=0;
    block.work_min.y=-((session->terminal_size.y+
                       session->scrollback)
                      *(redraw.r_charh << eig.y));
    block.work_max.x=session->terminal_size.x*redraw.r_charw << eig.x;
    block.work_max.y=0;

    block.icon_flags    =0x00000119;
    block.workarea_flags=10<<12; /* clicks (*256), drags (*16),
                                  * double clicks (*1) */
    block.sprite_area   =(struct os_spriteop_area *) 1;
    block.min_width     =4;
    block.min_height    =4;

    block.title.it.text      =session->title;
    block.title.it.validation=0;
    block.title.it.text_len  =256;

    block.number_of_icons    =0;

    session->window_handle = _swi(Wimp_CreateWindow, _IN(1)|_RETURN(0), &block);

    set_title_bar(session->window_handle,"nettle");
  }

  open_window(NULL, session->window_handle);

  {
    /* update the next window position */
    struct wimp_getwindowstate_block window;
    window.window_handle = session->window_handle;
    _swi (Wimp_GetWindowState, _IN(1), (int) &window);

    max_y = (window.min.y < 256) ? INITIAL_MAX_Y : window.max.y - 40;
  }

  switch (session->line_editor_type)
  {
    case LINEEDIT_NONE:
      set_caret_position(session->window_handle,-1,-1,-1);
      break;
    case LINEEDIT_CHECKBOX:
    {
      char string[1024];
      set_caret_position(session->pane_handle,1,-1,
                         strlen(read_icon_data(session->pane_handle, 1, string, sizeof(string))));
      break;
    }
    case LINEEDIT_ANTTERM:
    {
      char string[1024];
      set_caret_position(session->pane_handle,0,-1,
			 strlen(read_icon_data(session->pane_handle, 0, string, sizeof(string))));
      break;
    }
  }

  switch (params->connection_type)
  {
    case NETTLE_TELNET:
      set_title_bar(session->window_handle, lookup_static ("title_conn"));
      write_out_strings (session, lookup_static ("lookup"),
                         session->socket_host, "...\r\n", 0);
      main_requirenull = true;
      break;
  }

  allocate_zapredraw_area(session->terminal_size.x, session->terminal_size.y, session->scrollback);
}

void write_out_string(struct session_struct *session, const char *string)
{
  write_out_data(session, string, strlen(string));
}

void write_out_strings (struct session_struct *session, ...)
{
  va_list va;
  const char *str;
  va_start (va, session);

  while ((str = va_arg (va, const char *)) != 0)
  {
    write_out_data(session, str, strlen (str));
  }
}

void write_out_data(struct session_struct *session, const char *data, int length_data)
{
  int loop;
  struct coords pos;
  char cursor_flags;

  if (length_data == 0) {
    return;
  }

  pos=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session, pos.x, pos.y) &
        (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  cursor_flags |= NETTLE_FLAG_CURSOR;

  /* remove the cursor from the position */
  changedbox_init (session);
  changedbox_update_char (pos.x, pos.y);
  write_assigned_flags(session, pos.x, pos.y,
                       read_assigned_flags(session, pos.x, pos.y) &
                            ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));
  force_redraw_changedbox ();

  changedbox_init (session);

  for (loop = 0; loop < length_data; loop++)
  {
    /* log the byte */
    log_byte(data[loop]);

    /*close_log(true);*/


    /* process the current byte at this position */
    process_data(session, data[loop]);

  }

  pos=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session, pos.x, pos.y,
                         read_assigned_flags(session, pos.x, pos.y) | cursor_flags);
  }

  /* redraw the window */
  force_redraw_changedbox();

  /* force the selection back on (it may have got overwritten by new data) */
  force_redraw_selection();

  /* redraw the cursor, in case it isn't in the main redraw block */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    changedbox_init (session);
    changedbox_update_char (pos.x, pos.y);
    force_redraw_changedbox ();
  }

  nextcursortime = _swi (OS_ReadMonotonicTime, 0) + CURSOR_BLINK_DELAY;
  cursor_state = true;
}


void remove_session(struct session_struct *session)
{
  if (session->socket_handle != 0)
  {
    switch (session->connection_type)
    {
      case NETTLE_TELNET:
        socket_close(session->socket_handle);
        break;
      case NETTLE_TASKWINDOW:
        {
          /* terminate the taskwindow */
          union wimp_poll_block block;

          block.user_message.length      =20;
          block.user_message.my_ref      =0;
          block.user_message.message_code=WIMP_MESSAGE_TASKWINDOW_MORITE;

          _swi(Wimp_SendMessage, _INR(0,2), 17, &block, session->socket_handle);
        }
        break;
    }
  }
  if (session->dns != NULL)
  {
    dns_dispose(session->dns);
    session->dns = NULL;
  }

  {
    /* delete the window */
    struct wimp_deletewindow_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_DeleteWindow, _IN(1), &block);

  }

  /* free any paste buffers */
  {
    struct paste_buffer *paste = session->paste;
    while (paste)
    {
      struct paste_buffer *next_paste = paste->next;
      free (paste);
      paste = next_paste;
    }
  }

  /* free lineeditor space */
  if (session->line_editor_type!=LINEEDIT_NONE)
  {
    lineedit_free_space(session);
  }

  /* free the data area and title */
  delete_terminal(session);
  free(session->title);

  /* close the spool if any */
  if (session->spool_file_name!=NULL)
  {
    spool_close(session, true);
  }

  if (session->prev)
  {
    session->prev->next = session->next;
  }
  else
  {
    sessions = session->next;
  }

  if (session->next)
  {
    session->next->prev = session->prev;
  }

  /* cancel the selection if there was one in this session */
  if (selection_session == session)
  {
    selection_session = NULL;
  }

  if (cursor_session == session)
    cursor_session = NULL;

  free(session);

  rehash_blink();
}

int nettle_senddata(struct session_struct *session, const char *data, int length)
{
  /*int ret = length;*/

  switch (session->connection_type)
  {
    case NETTLE_TELNET:
      /* just use socket_senddata */
      return socket_senddata(session->socket_handle,data,length);
      break;
    case NETTLE_TASKWINDOW:
      /*while (length)*/
      {
        /* send a WIMP message */
        union wimp_poll_block block;
        int copy = (length > 63) ? 63 : length;

        memcpy (block.user_message.contents.task_window_input.data, data, copy);

        block.user_message.length                         =(27+copy) & ~3;
        block.user_message.my_ref                         =0;
        block.user_message.message_code                   =WIMP_MESSAGE_TASKWINDOW_INPUT;
        block.user_message.contents.task_window_input.size=length;

        _swi(Wimp_SendMessage, _INR(0,2), 17, &block, session->socket_handle);

        /*data += copy;*/
        /*length -= copy;*/
        return copy;
      }
      /*return ret;*/
      break;
  }
  return 0;
}

void reset_terminal(struct session_struct *session)
{
  session->other_session_flags=NETTLE_OTHER_CURSOR_VIS | NETTLE_OTHER_WRAP_MODE;
  session->current_fg=7;
  session->current_bg=0;
  session->current_flags=0;
  session->escape_string_length=0;
  session->escape_state=NETTLE_ESCAPE_NONE;
  session->scroll_start=1;
  session->scroll_end=session->terminal_size.y;
  session->character_set_gl=NETTLE_CHSET_G0;
  session->character_set_gr=NETTLE_CHSET_G3;

  session->character_set_g0=NETTLE_CHSET_ASCII;
  session->character_set_g1=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;
  session->character_set_g2=NETTLE_CHSET_ASCII;
  session->character_set_g3=NETTLE_CHSET_DEC_SUPPLEMENTAL_GRAPHICS;

  session->cursor_saved=false;

  switch (session->terminal_type)
  {
    case NETTLE_TERMINAL_VT100: case NETTLE_TERMINAL_VT102:
      session->terminal_mode=1;
      break;
    default:
      session->terminal_mode=2;
      break;
  }

  session->bit_controls=false;
  session->want_blink = false;
  rehash_blink();

  session->mouse_terminal_attached=true;
  session->mouse_mode=MOUSE_MODE_OFF;
}

bool valid_x(struct session_struct *session, int xpos)
{
  if (xpos<0 || xpos>=session->terminal_size.x)
  {
    printf("Attempt to write outside alternate line, X position %d\n", xpos);
    return false;
  }
  return true;
}

bool valid_y(struct session_struct *session, int ypos)
{
  if (ypos<0 || ypos>=session->terminal_size.y+session->scrollback)
  {
    printf("Attempt to write outside assigned area %p, Y position %d\n", session, ypos);
    return false;
  }
  return true;
}

bool valid_alt_y(struct session_struct *session, int ypos)
{
  if (ypos<0 || ypos>=session->terminal_size.y)
  {
    printf("Attempt to write outside alternate area %p, Y position %d\n", session, ypos);
    return false;
  }
  return true;
}

void write_assigned(struct session_struct *session, int xpos, int ypos,
                    char fg, char bg, char flags, char character)
{
  if (valid_x(session, xpos) && valid_y(session, ypos))
  {
    session->assigned_area[ypos][xpos].fg = fg;
    session->assigned_area[ypos][xpos].bg = bg;
    session->assigned_area[ypos][xpos].flags = flags;
    session->assigned_area[ypos][xpos].chr = character;
  }
}

void write_alt_assigned(struct session_struct *session, int xpos, int ypos,
                        char fg, char bg, char flags, char character)
{
  if (valid_x(session, xpos) && valid_alt_y(session, ypos))
  {
    session->alternate_area[ypos][xpos].fg = fg;
    session->alternate_area[ypos][xpos].bg = bg;
    session->alternate_area[ypos][xpos].flags = flags;
    session->alternate_area[ypos][xpos].chr = character;
  }
}

char read_assigned_fg(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_y(session, ypos))
  {
    return session->assigned_area[ypos][xpos].fg;
  }

  return 0;
}

char read_assigned_bg(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_y(session, ypos))
  {
    return session->assigned_area[ypos][xpos].bg;
  }

  return 0;
}

char read_assigned_flags(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_y(session, ypos))
  {
    return session->assigned_area[ypos][xpos].flags;
  }

  return 0;
}

char read_assigned_character(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_y(session, ypos))
  {
    return session->assigned_area[ypos][xpos].chr;
  }

  return 0;
}

char read_alt_assigned_fg(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_alt_y(session, ypos))
  {
    return session->alternate_area[ypos][xpos].fg;
  }

  return 0;
}

char read_alt_assigned_bg(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_alt_y(session, ypos))
  {
    return session->alternate_area[ypos][xpos].bg;
  }

  return 0;
}

char read_alt_assigned_flags(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_alt_y(session, ypos))
  {
    return session->alternate_area[ypos][xpos].flags;
  }

  return 0;
}

char read_alt_assigned_character(struct session_struct *session, int xpos, int ypos)
{
  if (valid_x(session, xpos) && valid_alt_y(session, ypos))
  {
    return session->alternate_area[ypos][xpos].chr;
  }

  return 0;
}

void write_assigned_flags(struct session_struct *session, int xpos, int ypos, char flags)
{
  if (valid_x(session, xpos) && valid_y(session, ypos))
  {
    session->assigned_area[ypos][xpos].flags = flags;
  }
}

void write_assigned_character(struct session_struct *session, int xpos, int ypos, char character)
{
  if (valid_x(session, xpos) && valid_y(session, ypos))
  {
    session->assigned_area[ypos][xpos].chr = character;
  }
}

void create_terminal(struct session_struct *session, struct coords terminal_size,
                     int scrollback)
{
  int loop;

  session->assigned_area=malloc((terminal_size.y+scrollback)*sizeof (int *));
  assert(session->assigned_area);

  for (loop=0; loop<terminal_size.y+scrollback; loop++)
  {
    session->assigned_area[loop]=malloc(terminal_size.x*sizeof (struct term_char));
    assert(session->assigned_area[loop]);
  }

  session->alternate_area=malloc(terminal_size.y*sizeof (int *));

  if (session->alternate_area)
  {
    for (loop=0; loop<terminal_size.y; loop++)
    {
      session->alternate_area[loop]=malloc(terminal_size.x*sizeof (struct term_char));
      assert(session->alternate_area[loop]);
    }
  }
}

void delete_terminal(struct session_struct *session)
{
  int loop;

  for (loop=0; loop<session->terminal_size.y+session->scrollback; loop++)
  {
    free(session->assigned_area[loop]);
  }

  free(session->assigned_area);

  if (session->alternate_area)
  {
    for (loop=0; loop<session->terminal_size.y; loop++)
    {
      free(session->alternate_area[loop]);
    }

    free(session->alternate_area);
  }
}

void resize_terminal(struct session_struct *session, int terminal_size_x, int terminal_size_y,
                     int scrollback, bool use_naws)
{
  struct coords old_terminal_size;
  int old_scrollback;

  old_terminal_size.x = session->terminal_size.x;
  old_terminal_size.y = session->terminal_size.y;
  old_scrollback      = session->scrollback;

  if (terminal_size_x != old_terminal_size.x || terminal_size_y !=
      old_terminal_size.y || old_scrollback != scrollback)
  {
    struct coords terminal_size;
    char temp_string[12];

    terminal_size.x=terminal_size_x;
    terminal_size.y=terminal_size_y;

    if (session->connection_type == NETTLE_TASKWINDOW)
    {
      sprintf(temp_string, "%d", terminal_size_y);
      _swi(OS_SetVarVal, _INR(0,4), "LINES", temp_string, strlen(temp_string), 0, 4);
      _swi(OS_SetVarVal, _INR(0,4), "ROWS", temp_string, strlen(temp_string), 0, 4); /* for old unixlib progs */
      sprintf(temp_string, "%d", terminal_size_x);
      _swi(OS_SetVarVal, _INR(0,4), "COLUMNS", temp_string, strlen(temp_string), 0, 4);
    }

    /* NB - this need fixed in order to allow copying of data from old to new */
    delete_terminal(session);
    create_terminal(session, terminal_size, scrollback);

    session->scroll_start   = 1;
    session->scroll_end     = terminal_size_y;
    session->terminal_size.x=terminal_size_x;
    session->terminal_size.y=terminal_size_y;
    session->scrollback     =scrollback;

    /* clear out the assigned area with black bg, white fg, no flags and ' ' */
    clear_screen(session,
                 0,
                 session->terminal_size.x*(session->terminal_size.y+session->scrollback),
                 7,
                 0,
                 0,
                 ' ');

    copy_main_alternate(session);

    allocate_zapredraw_area(terminal_size_x, terminal_size_y, scrollback);
  }

  /* This should put the cursor back in the right place... */
  session->pos.y=session->pos.y-old_scrollback+scrollback;

  reopen_and_size_window(session, old_terminal_size.x, old_terminal_size.y, old_scrollback,
                         redraw.r_charw, redraw.r_charh);

  if (use_naws)
  {
    if (session->session_flags[TELOPT_NAWS])
    {
      /* NAWS is on */
      char block[9];

      block[0]=TELNET_IAC;
      block[1]=TELNET_SB;
      block[2]=TELOPT_NAWS;
      block[3]=session->terminal_size.x / 256;
      block[4]=session->terminal_size.x % 256;
      block[5]=session->terminal_size.y / 256;
      block[6]=session->terminal_size.y % 256;
      block[7]=TELNET_IAC;
      block[8]=TELNET_SE;
      nettle_senddata(session, block, 9);
    }
  }
}

void reopen_and_size_window(struct session_struct *session, int old_terminal_size_x,
                            int old_terminal_size_y, int old_scrollback,
                            int old_charw, int old_charh)
{
  {
    struct wimp_setextent_block block;

    block.min.x=0;
    block.min.y=-((session->terminal_size.y+session->scrollback)*redraw.r_charh << eig.y);
    block.max.x=session->terminal_size.x*redraw.r_charw << eig.x;
    block.max.y=0;

    _swi(Wimp_SetExtent, _INR(0,1), session->window_handle, &block);

    if (session->line_editor_type!=LINEEDIT_NONE)
    {
      block.min.x=0;
      block.min.y=-48;
      block.max.x=session->terminal_size.x*redraw.r_charw << eig.x;
      block.max.y=0;

      _swi(Wimp_SetExtent, _INR(0,1), session->pane_handle, &block);
    }
  }

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=session->window_handle;
    _swi(Wimp_GetWindowState, _IN(1), &block);

    /* If terminal at fullsize, then reopen window at fullsize, otherwise leave it */
    if (block.max.x-block.min.x==(old_terminal_size_x*old_charw << eig.x))
    {
      block.max.x=block.min.x+(session->terminal_size.x*redraw.r_charw << eig.x);
    }
    if (block.max.y-block.min.y==(old_terminal_size_y*old_charh << eig.y))
    {
      block.min.y=block.max.y-(session->terminal_size.y*redraw.r_charh << eig.y);
    }

    /* If terminal is bigger than fullsize in the new font shrink it down to fullsize */
    if ((block.max.x-block.min.x)>(session->terminal_size.x*redraw.r_charw << eig.x))
    {
      block.max.x=block.min.x+(session->terminal_size.x*redraw.r_charw << eig.x);
    }
    if ((block.max.y-block.min.y)>(session->terminal_size.y*redraw.r_charh << eig.y))
    {
      block.min.y=block.max.y-(session->terminal_size.y*redraw.r_charh << eig.y);
    }

    /* If scrollback has changed, then shift the scroll offset */
    if (old_scrollback!=session->scrollback)
    {
      block.scroll.y-=(session->scrollback-old_scrollback)*old_charh << eig.y;
    }

    {
      int screen_x=(_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 11)+1) <<
                         _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
      int screen_y=(_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 12)+1) <<
                         _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

      if (block.max.x>screen_x)
      {
        block.min.x-=(block.max.x-screen_x);
        block.max.x-=(block.max.x-screen_x);
      }

      if (block.max.y>screen_y)
      {
        block.min.y-=(block.max.y-screen_y);
        block.max.y-=(block.max.y-screen_y);
      }
    }

    /* Scale the scroll offset according to the old font size/new font size */
    block.scroll.x=(block.scroll.x*redraw.r_charw/old_charw);
    block.scroll.y=(block.scroll.y*redraw.r_charh/old_charh);

    /* wimp_openwindow_block starts the same way as wimp_getwindowstate_block */
    _swi(Wimp_OpenWindow, _IN(1), &block);

    force_redraw(session->window_handle,0,
                 (-session->terminal_size.y-session->scrollback)*
                 redraw.r_charh << eig.y,
                        session->terminal_size.x*redraw.r_charw << eig.x,0);

    if (session->line_editor_type!=LINEEDIT_NONE)
      open_pane_window(session, (struct wimp_openwindow_block *) &block);
  }
}

static void allocate_zapredraw_area(int terminal_size_x, int terminal_size_y, int scrollback)
{
    /* make a ZapRedraw area big enough - note: the assembly is quite
   * inefficient, so writes out the stuff to change the colour every
   * 'character', which means typically each character takes up 5 bytes, so 6
   * is a number >5. Basically if you start getting screens full of graphics
   * characters and stuff, 6 isn't enough. Possibly the draw routine should
   * stop writing when it falls outside the area, and the number returned at
   * the end - it could  make a larger buffer, but not done yet.
   */

  if (size_of_zapredraw_area < terminal_size_x * (terminal_size_y + scrollback) * 8)
  {
    int *new_zapredraw_area;

    size_of_zapredraw_area = terminal_size_x * (terminal_size_y + scrollback) * 8; /* 8 is some value */

    if (dynamic_areas_available())
    {
      if (zapredraw_area_number==0)
      {
        char string[]="Nettle ZapRedraw area";

        /* Note maximum size is -1 since potentially could be any size */
        _swi(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, size_of_zapredraw_area,
                             -1, 0x80, -1, 0, -1, string, &zapredraw_area_number,
                             &new_zapredraw_area);

        assert(new_zapredraw_area != NULL);
        zapredraw_area = new_zapredraw_area;
      }
      else
      {
        int current_size;

        _swi(OS_DynamicArea, _INR(0,1)|_OUT(2), 2, zapredraw_area_number, &current_size);

        if (size_of_zapredraw_area-current_size!=0)
        {
          _swi(OS_ChangeDynamicArea, _INR(0,1), zapredraw_area_number, size_of_zapredraw_area-current_size);
        }
      }
    }
    else
    {
      new_zapredraw_area = realloc(zapredraw_area, size_of_zapredraw_area);
      assert(new_zapredraw_area != NULL);
      zapredraw_area = new_zapredraw_area;
    }
  }
}

void
scroll_term (struct session_struct *session, int direction)
{
  struct wimp_getwindowstate_block block;

  block.window_handle = session->window_handle;
  _swi (Wimp_GetWindowState, _IN(1), (int) &block);
  block.scroll.y += direction * (block.max.y - block.min.y);
  _swi (Wimp_OpenWindow, _IN(1), (int) &block);
}
