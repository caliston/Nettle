/**
 * Nettle specific code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "lineedit.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "socket.h"
#include "wimp.h"
#include "zapredraw.h"
#include "messages.h"

#include "stdarg.h"


static void allocate_zapredraw_area(int, int, int);


#ifdef DEBUG
typedef struct assigned_data
{
  char fg;
  char bg;
  char flags;
  char character;
}
assigned_data;

void dumptermdata(struct session_struct *session)
{
  int x;
  int y;

  for (y = 0; y < session->terminal_size.y; y++)
  {
    for (x = 0; x < session->terminal_size.x; x++)
    {
      assigned_data *ptr;

      ptr = (assigned_data *) session->assigned_area;
      ptr += y * session->terminal_size.x + x;
      printf("[%02d,%02d]: ", x, y);
      printf("'%c' (bg %d, fg %d, flags %x)\n",
             ptr->character, ptr->bg, ptr->fg, ptr->flags);
    }
  }
}

#endif /* DEBUG */


int get_host_port (char *string, int *port)
/* modifies string, returns true on error */
{
  int loop;
  char *sptr;

  if (! *string)
  {
    generror("InvalidAddr", true);
    return true;
  }

  /* strip off telnet: if it's there */
  if (strncmp (string, "telnet:", 7) == 0)
    strcpy (string, string + 7);

  /* strip out any /s anywhere in the string */
  loop=0;
  while (string[loop])
  {
    if (string[loop] == '/')
      memmove (string + loop, string + loop + 1, strlen (string + loop));
    loop++;
  }

  /* look at the string to find a port if any (separated by colon or comma) */
  sptr = strpbrk (string, ":,");
  if (sptr)
  {
    *sptr = '\0';
    *port = atoi (sptr + 1);
  }
  else
    *port = 23;

  /* if the port is <1, then it's either invalid or was too big and got wrapped */
  if (*port < 1)
  {
    generror("InvalidPort", true);
    return true;
  }

  /* success */
  return false;
}


void start_connection(void)
{
  char string[1024];
  int loop;
  int connection_type;
  enum nettle_terminal terminal_type;
  int port;

  read_icon_data(win_open, 4, string, sizeof(string));

  {
    char connection[MESSAGE_MAX_CONNECTION];

    if (strcmp(string, lookup("SSH", connection, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_SSH;
    else if (strcmp(string, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_TASKWINDOW;
    else
      connection_type=NETTLE_TELNET;
  }

  read_icon_data(win_open, 9, string, sizeof(string));

  terminal_type = NETTLE_TERMINAL_VT100;
  for (loop=0; loop<8; loop++)
  {
    char type[MESSAGE_MAX_TERMINAL];
    char term[7];
    sprintf(term,"Term%d",loop);
    if (strcmp(string,lookup(term, type, MESSAGE_MAX_TERMINAL))==0)
      terminal_type = (enum nettle_terminal)loop;
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
      read_icon_data(win_open, 0, string, sizeof(string));
      if (get_host_port (string, &port))
        return;
      start_connection_int (connection_type, terminal_type, string, port, 0);
      close_window(win_open);
      break;

    case NETTLE_TASKWINDOW:
      read_icon_data (win_open, 7, string, sizeof (string));
      loop = strlen (string);
      while (string[loop - 1] == ' ')
	loop--;
      string[loop] = '\0';		/* trim trailing spaces */
      loop = strspn (string, " ");	/* number of leading spaces */
      if (! string[loop])
      {
	generror("InvalidComm", true);
	return;
      }
      start_connection_int (connection_type, terminal_type, 0, 0, string);
      close_window(win_open);
      break;

    default:
      break;
  }
}


void start_connection_int (int connection_type, enum nettle_terminal terminal_type,
			   char *host, int port, char *command)
{
#define INITIAL_MAX_Y (1088)
  static int max_y = INITIAL_MAX_Y; /* the top of the next window to be opened */
  int loop;
  struct session_struct *session;

  session = malloc(sizeof(struct session_struct));
  if (session == NULL)
  {
    generror("TooMany", true); /* ought to give a different message, really */
    return;
  }

  /* Insert into list */
  session->prev = NULL;
  session->next = sessions;
  if (sessions)
  {
    sessions->prev = session;
  }
  sessions = session;

  /* clear all the session flags */
  for (loop=0; loop<256; loop++)
  {
    session->session_flags[loop]=false;
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
      /* host, port already parsed */
      session->socket_handle=0;
      session->socket_state=NETTLE_SESSION_RESOLVE;
      session->socket_port = port;
      strcpy (session->socket_host, host);
      break;

    case NETTLE_TASKWINDOW:
      /* start the task window */
      {
        char temp_string[1024];
        sprintf (temp_string, "%%TaskWindow \"%s\" -ctrl -name \"Nettle task\" -quit -task &%X -txt &%X", command, task_handle, (int)session);

        _swi(Wimp_StartTask, _IN(0), temp_string);
      }

      /* set ECHO bit to true */
      session->session_flags[1]=true;

      break;
  }

  /* set all the attributes to their defaults */
  session->terminal_size.x = defaultsize.x;
  session->terminal_size.y = defaultsize.y;
  session->scrollback = defaultscroll;
  session->title=malloc(256);
  assert(session->title != NULL);
  strcpy(session->title,"");
  session->assigned_area=malloc(session->terminal_size.x*
                                                (session->terminal_size.y+
                                                 session->scrollback)*4);
  assert(session->assigned_area);
  session->pos.x=0;
  session->pos.y=session->scrollback;
  session->connection_type=connection_type;
  session->terminal_type=terminal_type;
  reset_terminal(session);

Fortify_CheckAllMemory();
  /* clear out the assigned area with black bg, white fg, no flags and ' ' */
  {
    int loop_limit=((session->terminal_size.x)*
                   (session->terminal_size.y+
                    session->scrollback)*4);

    for (loop=0; loop<loop_limit; loop+=4)
    {
      write_assigned(session,loop,7,0,0,32);
    }
  }

  /* create tabs */
  session->number_of_tabs=0;
  for (loop=0; loop<session->terminal_size.x; loop+=8)
  {
    session->tabs[session->number_of_tabs]=loop;
    session->number_of_tabs++;
  }
Fortify_CheckAllMemory();

  session->line_editor_type=line_editor;

  /* if line editor is turned on, allocate all the lineeditor space */
  if (session->line_editor_type==LINEEDIT_NONE)
    session->pane_handle=0;
  else
    lineedit_allocate_space(session);

Fortify_CheckAllMemory();
  /* make new terminal window */
  {
    struct wimp_createwindow_block block;

    block.min.x         =102;
    block.min.y         =max_y-(session->terminal_size.y*redraw.r_charh << eig.y);
    block.max.x         =102+(session->terminal_size.x*redraw.r_charw << eig.x);
    block.max.y         =max_y;
    block.scroll.x      =0;
    block.scroll.y      =-((session->terminal_size.y+
                           session->scrollback)
                          *(redraw.r_charh << eig.y));
    block.handle_behind =-1;
    block.window_flags  =0xff000002;
    block.title_fg      =7;
    block.title_bg      =2;
    block.work_fg       =7;
    block.work_bg       =0xFF;

    block.scroll_outer_colour=3;
    block.scroll_inner_colour=1;
    block.title_focus_colour =12;
    block.flags              =0;

    block.work_min.x=0;
    block.work_min.y=-((session->terminal_size.y+
                       session->scrollback)
                      *(redraw.r_charh << eig.y));
    block.work_max.x=session->terminal_size.x*redraw.r_charw << eig.x;
    block.work_max.y=0;

    block.icon_flags    =0x00000119;
    block.workarea_flags=6<<12;
    block.sprite_area   =(struct os_spriteop_area *) 1;
    block.min_width     =4;
    block.min_height    =4;

    block.title.it.text      =session->title;
    block.title.it.validation=0;
    block.title.it.text_len  =256;

    block.number_of_icons    =0;

    session->window_handle = _swi(Wimp_CreateWindow, _IN(1)|_RETURN(0), &block);

    set_title_bar(session->window_handle,"nettle");
  }
Fortify_CheckAllMemory();

  open_window(NULL, session->window_handle);

  {
    /* update the next window position */
    struct wimp_getwindowstate_block window;
    window.window_handle = session->window_handle;
    _swi (Wimp_GetWindowState, _IN(1), (int) &window);
    max_y = (window.min.y < 64) ? INITIAL_MAX_Y : window.max.y - 40;
  }

  switch (session->line_editor_type)
  {
    case LINEEDIT_NONE:
      set_caret_position(session->window_handle,-1,-1,-1);
      break;
    case LINEEDIT_CHECKBOX:
    {
      char string[1024];
      set_caret_position(session->pane_handle,1,-1,
                         strlen(read_icon_data(session->pane_handle, 1, string, sizeof(string))));
      break;
    }
    case LINEEDIT_ANTTERM:
    {
      char string[1024];
      set_caret_position(session->pane_handle,0,-1,
			 strlen(read_icon_data(session->pane_handle, 0, string, sizeof(string))));
      break;
    }
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
      set_title_bar(session->window_handle, lookup_static ("title_conn"));
      write_out_strings (session, lookup_static ("lookup"),
                         session->socket_host, "...\r\n", 0);
      break;
  }

  allocate_zapredraw_area(session->terminal_size.x, session->terminal_size.y, session->scrollback);
Fortify_CheckAllMemory();

}

void write_out_string(struct session_struct *session, const char *string)
{
  write_out_data(session, string, strlen(string));
}

void write_out_strings (struct session_struct *session, ...)
{
  va_list va;
  const char *str;
  va_start (va, session);

  while ((str = va_arg (va, const char *)) != 0)
  {
    write_out_data(session, str, strlen (str));
  }
}

void write_out_data(struct session_struct *session, const char *data, int length_data)
{
  int loop, calc;
  char cursor_flags;

  if (length_data == 0) {
    return;
  }

  calc=get_cursor_position(session);

  /* get the cursor flags */
  cursor_flags=read_assigned_flags(session, calc) &
        (NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT);

  /* if the cursor flags don't have cursor set, make it so */
  cursor_flags |= NETTLE_FLAG_CURSOR;

  /* remove the cursor from the position */
  changedbox_init (session);
  changedbox_update_offset (calc);
  write_assigned_flags(session, calc, read_assigned_flags(session, calc) &
      ~(NETTLE_FLAG_CURSOR | NETTLE_FLAG_NO_INPUT));
  force_redraw_changedbox ();

  changedbox_init (session);

  for (loop = 0; loop < length_data; loop++)
  {
    /* log the byte */
    log_byte(data[loop]);

    /* process the current byte at this position */
    process_data(session, data[loop]);
  }

  calc=get_cursor_position(session);

  /* OR back in the cursor flags */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    write_assigned_flags(session, calc, read_assigned_flags(session, calc) | cursor_flags);
  }

  /* redraw the window */
  force_redraw_changedbox();

  /* force the selection back on (it may have got overwritten by new data) */
  refresh_selection_set();
  force_redraw_selection();

  /* redraw the cursor, in case it isn't in the main redraw block */
  if (session->other_session_flags & NETTLE_OTHER_CURSOR_VIS)
  {
    changedbox_init (session);
    changedbox_update_offset (calc);
    force_redraw_changedbox ();
  }
}


void remove_session(struct session_struct *session)
{
  if (session->socket_handle != 0)
  {
    switch (session->connection_type)
    {
      case NETTLE_TELNET:
        socket_close(session->socket_handle);
        break;
      case NETTLE_TASKWINDOW:
        {
          /* terminate the taskwindow */
          union wimp_poll_block block;

          block.user_message.length      =20;
          block.user_message.my_ref      =0;
          block.user_message.message_code=0x808C4;

          _swi(Wimp_SendMessage, _INR(0,2), 17, &block, session->socket_handle);
        }
        break;
    }
  }

  {
    /* delete the window */
    struct wimp_deletewindow_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_DeleteWindow, _IN(1), &block);

  }

  /* free lineeditor space */
  if (session->line_editor_type!=LINEEDIT_NONE)
  {
    lineedit_free_space(session);
  }

  /* free the assigned area and title */
  free(session->assigned_area);
  free(session->title);

  if (session->prev)
  {
    session->prev->next = session->next;
  }
  else
  {
    sessions = session->next;
  }

  if (session->next)
  {
    session->next->prev = session->prev;
  }

  /* cancel the selection if there was one in this session */
  if (selection_session == session)
  {
    selection_session = NULL;
  }

  free(session);
}

void nettle_senddata(struct session_struct *session, char *data, int length)
{
  switch (session->connection_type)
  {
    case NETTLE_TELNET:
      /* just use socket_senddata */
      socket_senddata(session->socket_handle,data,length);
      break;
    case NETTLE_TASKWINDOW:
      {
        /* send a WIMP message */
        int loop=0;
        union wimp_poll_block block;

        while (loop<length)
        {
          block.user_message.contents.task_window_input.data[loop]=data[loop];
          loop++;
        }

        block.user_message.length                         =(27+length) & ~3;
        block.user_message.my_ref                         =0;
        block.user_message.message_code                   =0x808C0;
        block.user_message.contents.task_window_input.size=length;

        _swi(Wimp_SendMessage, _INR(0,2), 17, &block, session->socket_handle);
      }
      break;
  }
}

void reset_terminal(struct session_struct *session)
{
  session->other_session_flags=NETTLE_OTHER_CURSOR_VIS | NETTLE_OTHER_WRAP_MODE
  						/*| NETTLE_OTHER_LINEFEED_MODE*/;
  session->current_fg=7;
  session->current_bg=0;
  session->current_flags=0;
  session->escape_string_length=0;
  session->escape_state=NETTLE_ESCAPE_NONE;
  session->scroll_start=1;
  session->scroll_end=session->terminal_size.y;
  session->character_set=NETTLE_CHSET_G0;

  session->character_set_g0=NETTLE_CHSET_US;
  session->character_set_g1=NETTLE_CHSET_US;
  session->character_set_g2=NETTLE_CHSET_US;
  session->character_set_g3=NETTLE_CHSET_US;
}

void write_assigned(struct session_struct *session ,int pointer, char fg, char bg, char flags, char character)
{
  if (pointer<0 || pointer>=(session->terminal_size.y+
    			    session->scrollback)*
    			    session->terminal_size.x*4)
  {
    printf("Attempt to write to outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return;
  }

  *(session->assigned_area+(pointer+0))=fg;
  *(session->assigned_area+(pointer+1))=bg;
  *(session->assigned_area+(pointer+2))=flags;
  *(session->assigned_area+(pointer+3))=character;
}

char read_assigned_fg(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>=(session->terminal_size.y+
    			    session->scrollback)*
    			    session->terminal_size.x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+0));
}

char read_assigned_bg(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>=(session->terminal_size.y+
    			    session->scrollback)*
    			    session->terminal_size.x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+1));
}

char read_assigned_flags(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>=(session->terminal_size.y+
    			    session->scrollback)*
    			    session->terminal_size.x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+2));
}

char read_assigned_character(struct session_struct *session, int pointer)
{
  if (pointer<0 || pointer>=(session->terminal_size.y+
    			    session->scrollback)*
    			    session->terminal_size.x*4)
  {
    printf("Attempt to read from outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return 0;
  }

  return *(session->assigned_area+(pointer+3));
}

void write_assigned_flags(struct session_struct *session, int pointer, char flags)
{
  if (pointer<0 || pointer>=(session->terminal_size.y+
    			    session->scrollback)*
    			    session->terminal_size.x*4)
  {
    printf("Attempt to write to outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return;
  }

  *(session->assigned_area+(pointer+2))=flags;
}

void write_assigned_character(struct session_struct *session, int pointer, char character)
{
  if (pointer<0 || pointer>=(session->terminal_size.y+
    			    session->scrollback)*
    			    session->terminal_size.x*4)
  {
    printf("Attempt to write to outside assigned area: session %p, pointer %d\n",session,pointer);
    generror("Erk", false);
    return;
  }

  *(session->assigned_area+(pointer+3))=character;
}

void resize_terminal(struct session_struct *session, int terminal_size_x, int terminal_size_y,
                     int scrollback, bool use_naws)
{
  char *old_assigned_area=session->assigned_area;
  struct coords old_terminal_size;

  old_terminal_size.x = session->terminal_size.x;
  old_terminal_size.y = session->terminal_size.y;

  if (terminal_size_x != old_terminal_size.x || terminal_size_y !=
      old_terminal_size.y || scrollback != session->scrollback)
  {
    session->assigned_area  =malloc(terminal_size_x*(terminal_size_y+scrollback)*4);
    assert(session->assigned_area != NULL);
    session->scroll_start   = 1;
    session->scroll_end     = terminal_size_y;
    session->terminal_size.x=terminal_size_x;
    session->terminal_size.y=terminal_size_y;
    session->scrollback     =scrollback;

    /* Blank area */
    /* remove once move is implemented */
    {
      int loop;

      for (loop=0; loop<terminal_size_x*(terminal_size_y+scrollback)*4; loop+=4)
      {
        write_assigned(session, loop, 7, 0, 0, 32);
      }
    }

    /* move old data to new area */
    /* Implement... */

    free(old_assigned_area);

    allocate_zapredraw_area(terminal_size_x, terminal_size_y, scrollback);
  }

  reopen_and_size_window(session, old_terminal_size.x, old_terminal_size.y,
                         redraw.r_charw, redraw.r_charh);

  if (use_naws)
  {
    if (session->session_flags[31])
    {
      /* NAWS is on */
      char block[9];

      block[0]=255; /* IAC */
      block[1]=250; /* SB */
      block[2]=31;  /* NAWS */
      block[3]=session->terminal_size.x / 256;
      block[4]=session->terminal_size.x % 256;
      block[5]=session->terminal_size.y / 256;
      block[6]=session->terminal_size.y % 256;
      block[7]=255; /* IAC */
      block[8]=240; /* SE */
      nettle_senddata(session, block, 9);
    }
  }
}

void reopen_and_size_window(struct session_struct *session, int old_terminal_size_x,
                            int old_terminal_size_y, int old_charw, int old_charh)
{
  {
    struct wimp_setextent_block block;

    block.min.x=0;
    block.min.y=-((session->terminal_size.y+session->scrollback)*redraw.r_charh << eig.y);
    block.max.x=session->terminal_size.x*redraw.r_charw << eig.x;
    block.max.y=0;

    _swi(Wimp_SetExtent, _INR(0,1), session->window_handle, &block);

    if (line_editor)
    {
      block.min.x=0;
      block.min.y=-48;
      block.max.x=session->terminal_size.x*redraw.r_charw << eig.x;
      block.max.y=0;

      _swi(Wimp_SetExtent, _INR(0,1), session->pane_handle, &block);
    }
  }

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    /* If terminal at fullsize, then reopen window at fullsize, otherwise leave it */
    if (block.max.x-block.min.x==(old_terminal_size_x*old_charw << eig.x))
    {
      block.max.x=block.min.x+(session->terminal_size.x*redraw.r_charw << eig.x);
    }
    if (block.max.y-block.min.y==(old_terminal_size_y*old_charh << eig.y))
    {
      block.min.y=block.max.y-(session->terminal_size.y*redraw.r_charh << eig.y);
    }

    /* wimp_openwindow_block is essentially the same as wimp_getwindowstate_block */
    _swi(Wimp_OpenWindow, _IN(1), &block);

    force_redraw(session->window_handle,0,
                 (-session->terminal_size.y-session->scrollback)*
                 redraw.r_charh << eig.y,
                        session->terminal_size.x*redraw.r_charw << eig.x,0);
    if (line_editor)
      open_pane_window(session, (struct wimp_openwindow_block *) &block);
  }
}

static void allocate_zapredraw_area(int terminal_size_x, int terminal_size_y, int scrollback)
{
    /* make a ZapRedraw area big enough - note: the assembly is quite
   * inefficient, so writes out the stuff to change the colour every
   * 'character', which means typically each character takes up 5 bytes, so 6
   * is a number >5. Basically if you start getting screens full of graphics
   * characters and stuff, 6 isn't enough. Possibly the draw routine should
   * stop writing when it falls outside the area, and the number returned at
   * the end - it could  make a larger buffer, but not done yet.
   */

  if (size_of_zapredraw_area < terminal_size_x * (terminal_size_y + scrollback) * 8)
  {
    int *new_zapredraw_area;

    size_of_zapredraw_area = terminal_size_x * (terminal_size_y + scrollback) * 8; /* 8 is some value */

    if (dynamic_areas_available())
    {
      if (zapredraw_area_number==0)
      {
        char string[]="Nettle ZapRedraw area";

        /* Note maximum size is -1 since potentially could be any size */
        _swi(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, size_of_zapredraw_area,
                             -1, 0x80, -1, 0, -1, string, &zapredraw_area_number,
                             &new_zapredraw_area);

        assert(new_zapredraw_area != NULL);
        zapredraw_area = new_zapredraw_area;
      }
      else
      {
        int current_size;

        _swi(OS_DynamicArea, _INR(0,1)|_OUT(2), 2, zapredraw_area_number, &current_size);

        if (size_of_zapredraw_area-current_size!=0)
        {
          _swi(OS_ChangeDynamicArea, _INR(0,1), zapredraw_area_number, size_of_zapredraw_area-current_size);
        }
      }
    }
    else
    {
      new_zapredraw_area = realloc(zapredraw_area, size_of_zapredraw_area);
      assert(new_zapredraw_area != NULL);
      zapredraw_area = new_zapredraw_area;
    }
  }
}
