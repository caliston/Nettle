/**
 * Socket code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "sys/types.h"

#ifndef USE_TCPIPLIB
#include "sys/byteorder.h"
#endif

#include "sys/errno.h"
#include "sys/ioctl.h"
#include "sys/socket.h"
#include "sys/select.h"
#include "sys/time.h"

#include "netinet/in.h"
#include "arpa/inet.h"

#include "netdb.h"

#include "sockwatch.h"
#include "socket.h"



/* this is only needed for NetLib */
extern int close(int /*s*/);



char socket_resolvehost(const char *host_name, unsigned int *address)
{
  int status;
  struct hostent *hostent;

  if (_swix(Resolver_GetHost, _IN(0)|_OUTR(0,1), host_name, &status, &hostent)==0)
  {
    switch (status)
    {
      case -1: case -2:
        return RESOLVER_FAILED;
        break;
      case 0:
        *address=(unsigned int) *((int *)(void *)(*hostent).h_addr);
        return RESOLVER_SUCCESS;
        break;
    }
  }
  else
  {
    return RESOLVER_FAILED;
  }
  return RESOLVER_INPROGRESS;
}

int socket_connecttoip(int ip_address,int port_number)
{
  int socket_handle;
  int data=1;
  struct sockaddr_in address;

  socket_handle=socket(AF_INET,SOCK_STREAM, PF_UNSPEC);
  if (socket_handle==-1)
    return -1;

  if (ioctl(socket_handle,FIONBIO,&data))
  {
    close(socket_handle);
    return -1;
  }

  socketwatch_register(socket_handle);

  address.sin_family=AF_INET;
  address.sin_port=htons(port_number);
  address.sin_addr.s_addr=ip_address;

  connect(socket_handle,(struct sockaddr *) &address, sizeof(address));

  return socket_handle;
}


void socket_close(int socket_handle)
{
  socketwatch_deregister(socket_handle);
  close(socket_handle);
}

int socket_connected(int socket_handle)
{
  fd_set fds;
  struct timeval timeout = { 0, 0 };
  int numready;
  
  FD_ZERO(&fds);
  FD_SET(socket_handle, &fds);
  numready = select(socket_handle+1, NULL, &fds, NULL, &timeout);
  printf("numready = %d\n", numready);
  fflush(stdout);
  if (numready == -1 || (numready > 0 && FD_ISSET(socket_handle, &fds)))
  {
    int result;
    int size = sizeof(errno);

    if (getsockopt(socket_handle, SOL_SOCKET, SO_ERROR, (char *) &result, &size) == -1)
      return errno;
    
    if (result == 0)
      /* connected! */
      return 0;
    
    if (result != 0)
      /* error occurred */
      return errno;
  }

  /* still connecting */
  return -1;
}

int socket_readdata(int socket_handle, char * buffer, int length)
{
  int result;

  result=recv(socket_handle,buffer,length,0);

  if (result==-1)
    return 0;

  if (result==0)
    return -1;

  return result;
}


int socket_senddata(int socket_handle, const char * buffer, int length)
{
  return send(socket_handle, (const void *) buffer, length, 0);
}


char *socket_ip_string(int address) {
  struct in_addr saddr;

  saddr.s_addr = address;

  return inet_ntoa(saddr);
}



