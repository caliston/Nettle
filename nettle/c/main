/**
 * Nettle main code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "choices.h"
#include "hotlist.h"
#include "init.h"
#include "main.h"
#include "misc.h"
#include "quit.h"
#include "sockwatch.h"
#include "wimp.h"

int main(void)
{
#ifdef FORTIFY
  Fortify_EnterScope();
#endif

  /* Turn on hourglass */
  _swi(Hourglass_On, 0);

  /* Initialise application */
  initialise_wimp();

  /* load things in */
  load_choices();
  load_hotlist();
  load_messages();
  load_sprites();
  load_templates();
  load_zap_fonts();

  create_log();

  /* create the iconbar icon */
  create_icon_bar_icon();
  
#ifdef SOCKETWATCH
  socketwatch_initialise();
#endif /*SOCKETWATCH*/

  /* Turn off hourglass */
  _swi(Hourglass_Smash, 0);

  while (!quit_flag)
  {
    union wimp_poll_block wimp_block;
    int event;
    int nextpolltime;
    int mask = (1<<4)  | /* pointer enter window */
               (1<<5)  | /* pointer leave window */
               0;

    if (socketwatch_pollword != NULL)
    {
      mask |= (1<<22); /* R3 is pointer to pollword */
      /* FIXME: need to set nextpolltime shorter if dns or connect in
       * progress (and selection too?) */
      nextpolltime = _swi(OS_ReadMonotonicTime, _RETURN(0)) + 500;
    }
    else
    {
      nextpolltime = _swi(OS_ReadMonotonicTime, _RETURN(0)) + 5;
    }

    /* Provide a suitable default in case DeepKeys isn't available */
    wimp_block.key_pressed.extra = 0;
    
    event = _swi(Wimp_PollIdle, _INR(0,3) | _RETURN(0),
                 mask, &wimp_block, nextpolltime, socketwatch_pollword);

    if (socketwatch_pollword != NULL)
      *socketwatch_pollword = 0;

    switch (event)
    {
      case 0:
        /* null reason code */
        wimp_nullreasoncode();
        break;
      case 1:
        /* redraw request */
        redraw_window(&wimp_block);
        break;
      case 2:
        /* open window request - call with window handle and whether this */
        /* is a wimp poll or not */
        open_window((struct wimp_openwindow_block*)&wimp_block, wimp_block.open_window.window_handle);
        break;
      case 3:
        /* close window request - call with window handle  */
        close_window(wimp_block.close_window.window_handle);
        break;
      case 6:
        /* mouse click request, call with x, y, buttons, window handle and icon_handle */
        mouse_click(wimp_block.mouse_click.pos.x,
                    wimp_block.mouse_click.pos.y,
                    wimp_block.mouse_click.buttons,
                    wimp_block.mouse_click.window_handle,
                    wimp_block.mouse_click.icon_handle);
        break;
      case 7:
        /* drag finished */
        drag_finished();
        break;
      case 8:
        /* key press, call with window handle, icon handle and key */
        key_pressed(wimp_block.key_pressed.window_handle,
                    wimp_block.key_pressed.icon_handle,
                    wimp_block.key_pressed.code,
                    wimp_block.key_pressed.extra);
        /* check the sockets for data, in case someone is holding down a key
         * and we're not getting null events. */
        wimp_nullreasoncode();
        break;
      case 9:
        /* menu selection */
        menu_choice(wimp_block.menu_selection.menu);
        break;
      case 11:
        /* lose caret */
        lose_caret(wimp_block.caret.window_handle);
        break;
      case 12:
        /* gain caret */
        gain_caret(wimp_block.caret.window_handle);
        break;
      case 13:
        /* pollword non-zero - ie. data on a socket */
        wimp_nullreasoncode();
        break;
      case 17:
      case 18:
        /* wimp message */
        wimp_message(&wimp_block);
        break;
    }
  }

  /* close down application */
  closedown_application();

  return 0;
}
