/**
 * Nettle Choices code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "choices.h"
#include "messages.h"
#include "misc.h"
#include "wimp.h"

#include <errno.h>
#include <time.h>

static void read_choice(char *variable, const char *line, const char *lookfor)
{
  int len=strlen(lookfor);

  if (strncmp(line,lookfor,len)==0)
  {
    strcpy(variable, line+len);
  }
}



static void read_boolean_choice(bool *var, const char *line, const char *lookfor)
{
  int len = strlen(lookfor);

  if (strncmp(line,lookfor,len)==0)
  {
    if (strncmp(line+len,"1",1) == 0)
    {
      *var=true;
    }
    else
    {
      *var=false;
    }
  }
}



static void read_integer_choice(int *var, const char *line, const char *lookfor)
{
  int len=strlen(lookfor);

  if (strncmp(line,lookfor,len)==0)
  {
    *var=atoi(line+len);
  }
}


static void read_character_choice(char *var, const char *line, const char *lookfor)
{
  int len=strlen(lookfor);

  if (strncmp(line,lookfor,len)==0)
  {
    *var=atoi(line+len);
  }
}


void load_choices(void)
{
  FILE *file_handle;
  char choices_path[256];
  char string[256];
  struct coords new_termsize = defaultsize;
  int new_scrollback = defaultscroll;
  int new_line_editor_size = line_editor_size;
  colour_t new_palette[16];

  memcpy(new_palette, default_palette, sizeof(default_palette));

  get_system_variable(choices_path, "Choices$Write", sizeof(choices_path));

  if (choices_path[0]=='\0')
  {
    sprintf(string, "<%s$Dir>.Choices.Choices", application_name);
  }
  else
  {
    sprintf(string, "Choices:%s.Choices", application_name);
  }

  file_handle=fopen(string,"r");
  if (file_handle==NULL)
  {
    /* If the file doesn't exist, drop back to using default choices file */
    sprintf(string, "<%s$Dir>.Choices.Default", application_name);
    file_handle=fopen(string, "r");
    if (file_handle==NULL)
      return;
  }

  while (true)
  {
    char *str=fgets(string, sizeof(string), file_handle);
    int len;

    if (!str)
      break;

    len=strlen(string);
    if (string[len-1]=='\n')
      string[len-1]='\0';

    read_choice(zap_font, string, "ZapFontHi:");
    read_choice(zap_lowres_font, string, "ZapFontLo:");

    read_boolean_choice(&logging, string, "Logging:");
    read_character_choice(&line_editor, string, "LineEditor:");
    read_boolean_choice(&pass_f12, string, "PassF12:");

    read_integer_choice(&new_termsize.x, string, "TerminalWidth:");
    read_integer_choice(&new_termsize.y, string, "TerminalHeight:");
    read_integer_choice(&new_scrollback, string, "TerminalScroll:");
    read_integer_choice(&new_line_editor_size, string, "LineEditorSize:");

    /* Maybe I'm wrong but I don't think this works... */
    if (!strncmp(string, "Palette:", 8))
    {
      int loop;
      str = string+8;
      for (loop=0; loop<16; loop++)
      {
        errno=0;
        new_palette[loop]=strtoul(str, &str, 16) << 8;
        if (errno)
        {
          new_palette[0]=1; /* invalid */
          break;
        }
      }
    }
  }

  fclose(file_handle);

  /* sanity checking in case of breakage through direct edit */
  /* May sanity check fonts, although if they're wrong, it'll default back to 08x16/08x08 */
  if (new_termsize.x >= MIN_TERMINAL_WIDTH && new_termsize.x <= MAX_TERMINAL_WIDTH)
    defaultsize.x = new_termsize.x;

  if (new_termsize.y >= MIN_TERMINAL_HEIGHT && new_termsize.y <= MAX_TERMINAL_HEIGHT)
    defaultsize.y = new_termsize.y;

  if (new_scrollback >= 0 && new_scrollback <= MAX_SCROLLBACK_SIZE)
    defaultscroll=new_scrollback;

  if (new_line_editor_size > 0 && new_line_editor_size <= MAX_LINE_EDITOR_SIZE)
    line_editor_size = new_line_editor_size;

  /* May redo this as potentially '1' is a valid palette entry (I believe) */
  if (new_palette[0] != 1)
    memcpy(palette, new_palette, sizeof(palette));
}

bool save_choices(void)
{
  char choices_path[256];
  char string[512];
  time_t current_time;

  get_system_variable(choices_path, "Choices$Write", sizeof(choices_path));

  if (choices_path[0]=='\0')
  {
    sprintf(string, "<%s$Dir>.Choices.Choices", application_name);
  }
  else
  {
    sprintf(string, "<Choices$Write>.%s.Choices", application_name);
  }

  _kernel_last_oserror();

  {
    bool error=false;
    FILE *file_handle=fopen(string, "w");

    if (file_handle==NULL)
    {
      /* Couldn't open the file for writing */
      error=true;
    }
    else
    {
      int loop;
      time_t current_time;

      time(&current_time);

      fprintf(file_handle, "# Nettle choices file\n");
      fprintf(file_handle, "# Created on %s\n", ctime(&current_time));
      fprintf(file_handle, "ZapFontHi:%s\n", zap_font);
      fprintf(file_handle, "ZapFontLo:%s\n", zap_lowres_font);

      fprintf(file_handle, "Logging:%d\n", (logging==true) ? 1 : 0);
      fprintf(file_handle, "PassF12:%d\n", (pass_f12==true) ? 1 : 0);

      fprintf(file_handle, "TerminalWidth:%d\n", defaultsize.x);
      fprintf(file_handle, "TerminalHeight:%d\n", defaultsize.y);
      fprintf(file_handle, "TerminalScroll:%d\n", defaultscroll);
      fprintf(file_handle, "LineEditor:%d\n", line_editor);
      fprintf(file_handle, "LineEditorSize:%d\n", line_editor_size);

      fputs("Palette:", file_handle);

      for (loop=0; loop<16; loop++)
        fprintf(file_handle, "%06lX ", palette[loop] >> 8);

      fputc('\n', file_handle);

      if (!ferror(file_handle))
      {
        if (fclose(file_handle))
          error=true;

        file_handle=NULL;

    }

    while (error)
    {
      /* An error - report it */
      _kernel_oserror *err = _kernel_last_oserror();

      lookup("CantSaveChoices", string, 256);
      strcat(string, err ? err->errmess : strerror(errno));
      string[251]='\0'; /* Terminate to fit error block (just in case it went further) */

      generror(string, false);

      error=false;

      if (file_handle)
      {
        if (fclose(file_handle))
          error=true; /* Possible second I/O error */
        file_handle=NULL;
      }

      if (!error)
        return false;
    }

    return true;
  }
}
