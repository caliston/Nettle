/**
 * Initialisation code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "chardefn.h"
#include "init.h"
#include "misc.h"
#include "nettle.h"
#include "wimp.h"
#include "zapredraw.h"
#include "sockwatch.h"
#include "quit.h"
#include "messages.h"
#include "choices.h"
#include "hotlist.h"

#define MAX_TEMPLATES 10
#define LOAD_TEMPLATE_NO_FONTS          (int *)(-1)
#define LOAD_TEMPLATE_WIMP_SPRITE_AREA  (struct os_spriteop_area *)(1)

static int zapredraw_block[128];
static int maxindirected=0;
static int *indirected[MAX_TEMPLATES];

static void initialise_wimp(void)
{
  static const int messages[] =
  {
    WIMP_MESSAGE_DATASAVEACK,
    WIMP_MESSAGE_MENUWARNING,
    WIMP_MESSAGE_MENUSDELETED,
    WIMP_MESSAGE_MODECHANGE,
    COLOURPICKER_COLOUR_CHOICE,
    COLOURPICKER_CLOSE_REQUEST,
    WIMP_MESSAGE_TASKWINDOW_OUTPUT,
    WIMP_MESSAGE_TASKWINDOW_EGO,
    WIMP_MESSAGE_TASKWINDOW_MORIO,
    WIMP_MESSAGE_QUIT
  };

  _swi(Wimp_Initialise, _INR(0,3)|_OUT(1), 310, 0x4b534154,
    application_name, messages, &task_handle);
}

static void load_sprites(void)
{
  int yeig;
  char file_name[1024];
  int obj_type;
  int obj_size;

  /* find out what sprites we need to load */
  yeig = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  sprintf(file_name, "<%s$Dir>.Resources.Sprites", application_name);

  /* if we're in a 2 high pixel mode, append 22 */
  /* FIXME: strictly this should be using the appropriate Wimp_ReadSysInfo
   * call */
  if (yeig == 2)
    strcat(file_name, "22");

  _swi(OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 17, file_name, &obj_type, &obj_size);
  if (obj_type == 1)
  {
    obj_size += 16;

    /* malloc a block big enough for it */
    sprite_area = malloc(obj_size);
    assert(sprite_area != NULL);

    /* set up the block */
    sprite_area->total_size = obj_size;
    sprite_area->offset_to_1st_sprite = 16;

    /* initialise area */
    _swi(OS_SpriteOp, _INR(0,1), 0x109, sprite_area);

    /* load sprites into it */
    _swi(OS_SpriteOp, _INR(0,2), 0x10a, sprite_area, file_name);
  }
  else
  {
    generror("NoSprites", true);
    closedown_application();
  }
}


static void open_template(void)
{
  int use_3d_templates=false;
  char country[16];
  char template_filename[1024];
  FILE *file_handle;

  /* Check 3D bit of CMOS RAM */
  if (_swi(OS_Byte, _INR(0,1)|_RETURN(2), 161, 0x8c) & 1)
    use_3d_templates=true;

  /* Again, set country to UK if we don't know */
  if (strlen(get_country(country, sizeof(country)))==0)
    strcpy(country,"UK");

  /* Put together filename */
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  /* append filename according to 3D flag */
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  /* If we fail to open, change to UK */
  if (file_handle==0)
  {
    strcpy(country,"UK");
  }
  else
  {
    fclose(file_handle);
  }

  /* Put together filename */
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  /* append correct filename */
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  /* this time, if we fail to open, moan about lack of templates and quit */
  if (file_handle==0)
  {
    generror("NoTemplates", true);
    closedown_application();
  }
  else
  {
    fclose(file_handle);
  }

  _swi(Wimp_OpenTemplate, _IN(1), template_filename);
}


static int load_template(int *font_array, const char *window_name, struct os_spriteop_area *templ_sprite)
{
  char window_name_copy[12];
  struct wimp_createwindow_block *template_data;
  int *indirected_data;
  int size_of_template_data;
  int size_of_indirected_data;
  int window_handle;

  assert(maxindirected<MAX_TEMPLATES);

  /* template name must be in a writable 12-byte buffer */
  strcpy(window_name_copy, window_name);

  /* get sizes of template data and indirected_data */
  _swi(Wimp_LoadTemplate, _IN(1)|_INR(5,6)|_OUTR(1,2), 0, window_name_copy,
    0, &size_of_template_data, &size_of_indirected_data);

  /* malloc this amount, indirected first to be heap friendly */
  indirected_data = malloc(size_of_indirected_data);
  assert(indirected_data != NULL);
  template_data = malloc(size_of_template_data);
  assert(template_data != NULL);

  indirected[maxindirected++]=indirected_data;

  /* load the template */
  _swi(Wimp_LoadTemplate, _INR(1,6), template_data, indirected_data,
    indirected_data+size_of_indirected_data, font_array, window_name_copy,
    0);

  /* set the sprite area pointer */
  template_data->sprite_area=templ_sprite;

  window_handle = _swi(Wimp_CreateWindow, _IN(1)|_RETURN(0), template_data);

  /* free the template data (indirected is still needed) */
  free(template_data);

  return window_handle;
}


static void close_template(void)
{
  _swi(Wimp_CloseTemplate, 0);
}


void lose_templates(void)
{
  int i;
  for(i=0; i<maxindirected; i++)
    free(indirected[i]);
}

static void load_templates(void)
{
  char info_data[60];

  /* open the templates file */
  open_template();

  /* read template definitions */
  win_info=load_template(LOAD_TEMPLATE_NO_FONTS,"info",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(win_info,0,lookup("AppName", info_data, sizeof(info_data)));
  set_icon_data(win_info,1,lookup("AppAuthor", info_data, sizeof(info_data)));
  set_icon_data(win_info,5,lookup("AppVersion", info_data, sizeof(info_data)));
  set_icon_data(win_info,6,lookup("AppPurpose", info_data, sizeof(info_data)));

  win_choices=load_template(LOAD_TEMPLATE_NO_FONTS,"choices",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_state(win_choices, 5, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
  set_icon_state(win_choices, 6, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);

  win_paneterm=load_template(LOAD_TEMPLATE_NO_FONTS,"paneterm",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  win_panefonts=load_template(LOAD_TEMPLATE_NO_FONTS,"panecols",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  win_panehot=load_template(LOAD_TEMPLATE_NO_FONTS,"panehot",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  win_open=load_template(LOAD_TEMPLATE_NO_FONTS,"open",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(win_open,4,lookup("Telnet", info_data, sizeof(info_data)));
  /* set_icon_data(win_open,9,terminal_name[default_terminal]);*/

  win_resize=load_template(LOAD_TEMPLATE_NO_FONTS,"resize",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  win_save=load_template(LOAD_TEMPLATE_NO_FONTS,"save",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  /* close the templates file */
  close_template();
}


static int *load_font(char *font)
{
  char string[5]="ZFLK";
  int *zap_load_area;
  int width;
  int height;
  int last_char;
  int first_char;
  int char_size;
  FILE *file_handle=0;
  char file_end[256];
  char file_start[256];
  char file_name[1024];
  int object_type;

  get_system_variable(file_name,"ZapFontsSource$Path",sizeof(file_name));
  if (strlen(file_name)!=0)
  {
    strcpy(file_start,"ZapFontsSource:");
  }
  else
  {
    strcpy(file_start,"<Nettle$Dir>.Fonts.");
  }

  strcpy(file_end, font);

  /* if string is ZFLK, then this is a redirection font */
  while (strcmp(string,"ZFLK")==0)
  {
    sprintf(file_name,"%s%s",file_start,file_end);

    /* if it's there, what sort of object is it */
    if (_swix(OS_File, _INR(0,1)|_OUT(0), 17, file_name, &object_type)==0)
    {
      if (object_type == 0)
      {
          strcpy(string,"");
      }
      else if (object_type == 2)
      {
          /* If it's a directory, plonk .0 on the end */
          strcat(file_end,".0");
          strcat(file_name,".0");

	  /* and pretend it's a file */
	  object_type = 1;
      }

      if (object_type == 1)
      {
      	file_handle=fopen(file_name,"rb");

      	if (file_handle != NULL)
      	{
      	  fread(&string[0],1,5,file_handle);
	  string[4]='\0';

      	  /* if it's redirection then */
      	  if (strcmp(string,"ZFLK")==0)
      	  {
	    size_t chrs;

      	    /* get the redirection font */
      	    chrs = fread(&file_end[0], 1, sizeof(file_end)-1, file_handle);
	    file_end[chrs]='\0';

      	    fclose(file_handle);
      	  }
      	}
      }
    }
    else
    {
      strcpy(string,"");
    }
  }

  if (file_handle==0)
  {
    /* if we didn't find a font, use Nettle's internal ones */
    /* (This may not be necessary if it uses <Nettle$Dir>.Fonts from above, but leave it for */
    /* now) */

    if (eig.y >1)
      strcpy(file_name,"<Nettle$Dir>.Fonts.08x08.System.0");
    else
      strcpy(file_name,"<Nettle$Dir>.Fonts.08x16.Default.0");
    file_handle=fopen(file_name,"rb");
  }

  assert(file_handle);

  fseek(file_handle,8,SEEK_SET);

  /* Get font information */
  fread((char *) &width, 1, 4, file_handle);
  fread((char *) &height, 1, 4, file_handle);
  fread((char *) &first_char, 1, 4, file_handle);
  fread((char *) &last_char, 1, 4, file_handle);

  fclose(file_handle);

  /* Set real character size (will be needed to implement graphics characters) */
  char_size=((width+ 7) & ~7)*height/8;

  zap_load_area=malloc(char_size*(0x11D-first_char)+0x20);
  assert(zap_load_area != NULL);

  _swi(OS_File, _INR(0,3), 16, file_name, zap_load_area, 0);

  /* fill in graphics chars */
  define_zap_chars(zap_load_area+8+(char_size*(0x40-(zap_load_area[4]))),
                   char_size, width, height, zap_load_area+8);

  return zap_load_area;
}


static void load_zap_fonts(void)
{
  redraw.r_workarea=zapredraw_block;

  /* load in hires and lores zap fonts */
  zap_font_area=load_font(zap_font);
  zap_lowres_font_area=load_font(zap_lowres_font);

  /* do mode_change to set things up */
  mode_change();
}


static void create_icon_bar_icon(void)
{
  struct wimp_createicon_block block;

  block.window_handle=-1; /* window handle */
  block.min.x         =0;  /* min x */
  block.min.y         =0;  /* min y */
  block.max.x         =68; /* max x */
  block.max.y         =68; /* max y */
  block.icon_flags   =WIMP_ICON_BGCOL(1) | WIMP_ICON_FGCOL(7) | WIMP_ICON_TYPE(3) | \
                      WIMP_ICON_VCENT_BIT | WIMP_ICON_HCENT_BIT | WIMP_ICON_SPRITE_BIT ;

  strcpy(block.contents.t.text, application_icon_name);

  iconbar_handle=_swi(Wimp_CreateIcon, _IN(1)|_RETURN(0), &block);
}


void initialise_application(void)
{
#ifdef FORTIFY
  Fortify_EnterScope();
#endif

  /* Turn on hourglass */
  _swi(Hourglass_On, 0);

  /* Initialise application */
  initialise_wimp();

  /* load things in */
  load_choices();
  load_hotlist();
  load_messages();
  load_sprites();
  load_templates();
  load_zap_fonts();

  create_log();

  /* create the iconbar icon */
  create_icon_bar_icon();

  socketwatch_initialise();

  /* Turn off hourglass */
  _swi(Hourglass_Smash, 0);

}
