/**
 * Initialisation code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "chardefn.h"
#include "init.h"
#include "misc.h"
#include "nettle.h"
#include "quit.h"
#include "wimp.h"
#include "zapredraw.h"

void initialise_wimp(void)
{
  static int messages[] =
  {
    WIMP_MESSAGE_DATASAVEACK,
    WIMP_MESSAGE_MODECHANGE,
    WIMP_MESSAGE_TASKWINDOW_OUTPUT,
    WIMP_MESSAGE_TASKWINDOW_EGO,
    WIMP_MESSAGE_TASKWINDOW_MORIO,
    WIMP_MESSAGE_QUIT
  };

  _swi(Wimp_Initialise, _INR(0,3)|_OUT(1), 310, 0x4b534154,
    application_name, messages, &task_handle);
}


void load_messages(void)
{
  char country[16];
  char messages_file_name[1024];
  FILE *file_handle;
  int size_of_messagetrans_buffer;

  /* Get the country - if it has null length, then default to UK */
  if (strlen(get_country(country, sizeof(country))) == 0)
    strcpy(country, "UK");

  /* put together filename */
  sprintf(messages_file_name, "<%s$Dir>.Resources.%s.Messages",
    application_name, country);

  /* open the file */
  file_handle = fopen(messages_file_name, "r");

  /* if we don't open it, then definitely set country to UK */
  if (file_handle == 0)
    strcpy(country,"UK");
  else
    fclose(file_handle);

  sprintf(messages_file_name, "<%s$Dir>.Resources.%s.Messages",
    application_name, country);

  /* Now re-open it */
  size_of_messagetrans_buffer = _swi(MessageTrans_FileInfo,
    _IN(1)|_RETURN(2), messages_file_name);

  messagetrans_buffer = malloc(size_of_messagetrans_buffer);
  assert(messagetrans_buffer != NULL);

  _swi(MessageTrans_OpenFile, _INR(0,2), messagetrans_area,
    messages_file_name, messagetrans_buffer);
}


void load_sprites(void)
{
  int yeig;
  char file_name[1024];
  int obj_type;
  int obj_size;

  /* find out what sprites we need to load */
  yeig = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  sprintf(file_name, "<%s$Dir>.Resources.Sprites", application_name);

  /* if we're in a 2 high pixel mode, append 22 */
  /* FIXME: strictly this should be using the appropriate Wimp_ReadSysInfo
   * call */
  if (yeig == 2)
    strcat(file_name, "22");

  _swi(OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 17, file_name, &obj_type, &obj_size);
  if (obj_type == 1)
  {
    obj_size += 16;

    /* malloc a block big enough for it */
    sprite_area = malloc(obj_size);
    assert(sprite_area != NULL);

    /* set up the block */
    sprite_area->total_size = obj_size;
    sprite_area->offset_to_1st_sprite = 16;

    /* initialise area */
    _swi(OS_SpriteOp, _INR(0,1), 0x109, sprite_area);

    /* load sprites into it */
    _swi(OS_SpriteOp, _INR(0,2), 0x10a, sprite_area, file_name);
  }
  else
  {
    generror("NoSprites", true);
    closedown_application();
  }
}


static void open_template(void)
{
  int use_3d_templates=false;
  char country[16];
  char template_filename[1024];
  FILE *file_handle;

  /* Check 3D bit of CMOS RAM */
  if (_swi(OS_Byte, _INR(0,1)|_RETURN(2), 161, 0x8c) & 1)
    use_3d_templates=true;

  /* Again, set country to UK if we don't know */
  if (strlen(get_country(country, sizeof(country)))==0)
    strcpy(country,"UK");

  /* Put together filename */
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  /* append filename according to 3D flag */
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  /* If we fail to open, change to UK */
  if (file_handle==0)
  {
    strcpy(country,"UK");
  }
  else
  {
    fclose(file_handle);
  }

  /* Put together filename */
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  /* append correct filename */
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  /* this time, if we fail to open, moan about lack of templates and quit */
  if (file_handle==0)
  {
    generror("NoTemplates", true);
    closedown_application();
  }
  else
  {
    fclose(file_handle);
  }

  _swi(Wimp_OpenTemplate, _IN(1), template_filename);
}


static int load_template(int *font_array, const char *window_name, struct os_spriteop_area *templ_sprite)
{
  char window_name_copy[12];
  struct wimp_createwindow_block *template_data;
  int *indirected_data;
  int size_of_template_data;
  int size_of_indirected_data;
  int window_handle;

  /* template name must be in a writable 12-byte buffer */
  strcpy(window_name_copy, window_name);

  /* get sizes of template data and indirected_data */
  _swi(Wimp_LoadTemplate, _IN(1)|_INR(5,6)|_OUTR(1,2), 0, window_name_copy,
    0, &size_of_template_data, &size_of_indirected_data);

  /* malloc this amount, indirected first to be heap friendly */
  indirected_data = malloc(size_of_indirected_data);
  assert(indirected_data != NULL);
  template_data = malloc(size_of_template_data);
  assert(template_data != NULL);

  /* load the template */
  _swi(Wimp_LoadTemplate, _INR(1,6), template_data, indirected_data,
    indirected_data+size_of_indirected_data, font_array, window_name_copy,
    0);

  /* set the sprite area pointer */
  template_data->sprite_area=templ_sprite;

  window_handle = _swi(Wimp_CreateWindow, _IN(1)|_RETURN(0), template_data);

  /* free the template data (indirected is still needed) */
  free(template_data);

  return window_handle;
}


static void close_template(void)
{
  _swi(Wimp_CloseTemplate, 0);
}


void load_templates(void)
{
  char info_data[60];

  /* open the templates file */
  open_template();

  /* read template definitions */
  win_info=load_template(LOAD_TEMPLATE_NO_FONTS,"info",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(win_info,0,lookup("AppName", info_data, sizeof(info_data)));
  set_icon_data(win_info,1,lookup("AppAuthor", info_data, sizeof(info_data)));
  set_icon_data(win_info,5,lookup("AppVersion", info_data, sizeof(info_data)));
  set_icon_data(win_info,6,lookup("AppPurpose", info_data, sizeof(info_data)));

  win_choices=load_template(LOAD_TEMPLATE_NO_FONTS,"choices",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  win_open=load_template(LOAD_TEMPLATE_NO_FONTS,"open",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(win_open,4,lookup("Telnet", info_data, sizeof(info_data)));
  set_icon_data(win_open,9,terminal_name[NETTLE_TERMINAL_VT220]);

  win_resize=load_template(LOAD_TEMPLATE_NO_FONTS,"resize",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  win_save=load_template(LOAD_TEMPLATE_NO_FONTS,"save",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  /* close the templates file */
  close_template();
}


static int *load_font(char *font)
{
  char string[5]="ZFLK";
  char character;
  int *zap_load_area;
  int width;
  int height;
  int last_char;
  int first_char;
  int char_size;
  FILE *file_handle=0;
  char file_end[256];
  char file_start[256];
  char file_name[1024];
  int object_type;

  get_system_variable(file_name,"ZapFontsSource$Path",sizeof(file_name));
  if (strlen(file_name)!=0)
  {
    strcpy(file_start,"ZapFontsSource:");
  }
  else
  {
    strcpy(file_start,"<Nettle$Dir>.Fonts.");
  }

  strcpy(file_end, font);

  /* if string is ZFLK, then this is a redirection font */
  while (strcmp(string,"ZFLK")==0)
  {
    sprintf(file_name,"%s%s",file_start,file_end);

    /* if it's there, what sort of object is it */
    if (_swix(OS_File, _INR(0,1)|_OUT(0), 17, file_name, &object_type)==0)
    {
      if (object_type == 0)
      {
          strcpy(string,"");
      }
      else if (object_type == 2)
      {
          /* If it's a directory, plonk .0 on the end */
          strcat(file_end,".0");
          strcat(file_name,".0");
      }

      file_handle=fopen(file_name,"r");

      if (file_handle != NULL)
      {
        fgets(string,5,file_handle);

        /* if it's redirection then */
        if (strcmp(string,"ZFLK")==0)
        {
          /* get the new line character */
          character=fgetc(file_handle);

          /* get the redirection font */
          fgets(file_end, sizeof(file_end), file_handle);

          fclose(file_handle);
        }
      }
    }
    else
    {
      strcpy(string,"");
    }
  }

  if (file_handle==0)
  {
    /* if we didn't find a font, use Nettle's internal one */
    strcpy(file_name,"<Nettle$Dir>.Fonts.08x16.Default.0");
    file_handle=fopen(file_name,"r");
  }

  fseek(file_handle,8,SEEK_SET);

  /* Get font information */
  width=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
         ((fgetc(file_handle))<<24);
  height=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
          ((fgetc(file_handle))<<24);
  first_char=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
              ((fgetc(file_handle))<<24);
  last_char=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
             ((fgetc(file_handle))<<24);

  /* Set real character size (will be needed to implement graphics characters) */
  if ((width % 8)==0)
  {
    char_size=width*height/8;
  }
  else
  {
    char_size=(width+(8-(width % 8)))*height/8;
  }
  zap_load_area=malloc(char_size*(0x11D-first_char)+0x20);
  assert(zap_load_area != NULL);

  fclose(file_handle);

  _swi(OS_File, _INR(0,3), 16, file_name, zap_load_area, 0);

  /* fill in graphics chars */
  define_zap_chars(zap_load_area+8+(char_size*(0x40-(zap_load_area[4]))),char_size,width,height);

  return zap_load_area;
}


void load_zap_fonts(void)
{
  redraw.r_workarea=zapredraw_block;

  /* load in hires and lores zap fonts */
  zap_font_area=load_font(zap_font);
  zap_lowres_font_area=load_font(zap_lowres_font);

  /* do mode_change to set things up */
  mode_change();
}


void create_icon_bar_icon(void)
{
  struct wimp_createicon_block block;

  block.window_handle=-1; /* window handle */
  block.minx         =0;  /* min x */
  block.miny         =0;  /* min y */
  block.maxx         =68; /* max x */
  block.maxy         =68; /* max y */
  block.icon_flags   =WIMP_ICON_BGCOL(1) | WIMP_ICON_FGCOL(7) | WIMP_ICON_TYPE(3) | \
                      WIMP_ICON_VCENT_BIT | WIMP_ICON_HCENT_BIT | WIMP_ICON_SPRITE_BIT ;

  strcpy(block.contents.t.text, application_icon_name);

  iconbar_handle=_swi(Wimp_CreateIcon, _IN(1)|_RETURN(0), &block);
}
