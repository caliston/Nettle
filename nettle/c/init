// Initialisation code
// by A. Macfarlane Smith
// (C) Archifishal Software 2001

#include "generic.h"
#include "globals.h"

#include "chardefn.h"
#include "init.h"
#include "misc.h"
#include "nettle.h"
#include "quit.h"
#include "wimp.h"
#include "zapredraw.h"

int *initialise_messages(void)
{
  // Set up the messages we want to get
  int *message_list=malloc(6*sizeof(int));

  message_list[0]=2;	   // DataSaveAck
  message_list[1]=0x400C1; // ModeChange
  message_list[2]=0x808C1; // TW_Output
  message_list[3]=0x808C2; // TW_Ego
  message_list[4]=0x808C3; // TW_Morio
  message_list[5]=0x0;     // Quit

  return message_list;
}

void load_messages(void)
{
  char country[16];
  char messages_file_name[1024];
  FILE *file_handle;
  int size_of_messagetrans_buffer;

  // Get the country - if it has null length, then default to UK
  if (strlen(get_country(country, sizeof(country)))==0)
    strcpy(country,"UK");

  // put together filename
  sprintf(messages_file_name,"<%s$Dir>.Resources.%s.Messages",application_name,country);

  // open the file
  file_handle=fopen(messages_file_name,"r");

  // if we don't open it, then definitely set country to UK
  if (file_handle==0)
    strcpy(country,"UK");
  else
    fclose(file_handle);

  sprintf(messages_file_name,"<%s$Dir>.Resources.%s.Messages",application_name,country);

  // Now re-open it
  regs.r[1]=(int) messages_file_name;
  _kernel_swi(MessageTrans_FileInfo, &regs, &regs);
  size_of_messagetrans_buffer=regs.r[2];

  messagetrans_buffer=malloc(size_of_messagetrans_buffer);

  regs.r[0]=(int) messagetrans_area;
  regs.r[1]=(int) messages_file_name;
  regs.r[2]=(int) messagetrans_buffer;
  _kernel_swi(MessageTrans_OpenFile, &regs, &regs);
}

void load_sprites(void)
{
  int yeig;
  char file_name[1024];
  FILE *file_handle;

  // find out what sprites we need to load
  regs.r[0]=-1;
  regs.r[1]=5;
  _kernel_swi(OS_ReadModeVariable, &regs, &regs);
  yeig=(int) pow(2,regs.r[2]);

  sprintf(file_name,"<%s$Dir>.Resources.Sprites",application_name);

  // if we're in a 2 high pixel mode, append 22
  if (yeig==2)
    strcat(file_name,"22");

  file_handle=fopen(file_name,"r");
  if (file_handle==0)
  {
    generror(lookup("NoSprites"));
    closedown_application();
  }
  else
  {
    int size;
    fclose(file_handle);

    // get the sprite file size
    regs.r[0]=5;
    regs.r[1]=(int) file_name;
    _kernel_swi(OS_File, &regs, &regs);
    size=regs.r[4]+64;

    // malloc a block big enough for it
    sprite_area=malloc(size);

    // set up the block
    sprite_area[0]=size;
    sprite_area[2]=16;

    // initialise area
    regs.r[0]=256+9;
    regs.r[1]=(int) sprite_area;
    _kernel_swi(OS_SpriteOp, &regs, &regs);

    // load sprites into it
    regs.r[0]=256+10;
    regs.r[1]=(int) sprite_area;
    regs.r[2]=(int) file_name;
    _kernel_swi(OS_SpriteOp, &regs, &regs);
  }
}

void load_templates(void)
{
  // open the templates file
  open_template();

  // read template definitions
  info=load_template(LOAD_TEMPLATE_NO_FONTS,"info",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(info,0,lookup("AppName"));
  set_icon_data(info,1,lookup("AppAuthor"));
  set_icon_data(info,5,lookup("AppVersion"));
  set_icon_data(info,6,lookup("AppPurpose"));

  choices=load_template(LOAD_TEMPLATE_NO_FONTS,"choices",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  open=load_template(LOAD_TEMPLATE_NO_FONTS,"open",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(open,4,lookup("Telnet"));
  set_icon_data(open,9,terminal_name[NETTLE_TERMINAL_VT220]);

  resize=load_template(LOAD_TEMPLATE_NO_FONTS,"resize",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  save=load_template(LOAD_TEMPLATE_NO_FONTS,"save",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  // close the templates file
  close_template();
}

void open_template(void)
{
  int use_3d_templates=false;
  char country[16];
  char template_filename[1024];
  FILE *file_handle;

  // Check 3D bit of CMOS RAM
  regs.r[0]=161;
  regs.r[1]=0x8C;
  _kernel_swi(OS_Byte, &regs, &regs);

  if (regs.r[2] & 1)
    use_3d_templates=true;

  // Again, set country to UK if we don't know
  if (strlen(get_country(country, sizeof(country)))==0)
    strcpy(country,"UK");

  // Put together filename
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  // append filename according to 3D flag
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  // If we fail to open, change to UK
  if (file_handle==0)
  {
    strcpy(country,"UK");
  }
  else
  {
    fclose(file_handle);
  }

  // Put together filename
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  // append correct filename
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  // this time, if we fail to open, moan about lack of templates and quit
  if (file_handle==0)
  {
    generror(lookup("NoTemplates"));
    closedown_application();
  }
  else
  {
    fclose(file_handle);
  }

  regs.r[1]=(int) template_filename;
  _kernel_swi(Wimp_OpenTemplate, &regs, &regs);
}

int load_template(int *font_array,char *window_name,int *sprite_area)
{
  int *template_data;
  int *indirected_data;
  int size_of_template_data;
  int size_of_indirected_data;
  int window_handle;

  // get sizes of template data and indirected_data
  regs.r[1]=0;
  regs.r[5]=(int) window_name;
  regs.r[6]=0;
  _kernel_swi(Wimp_LoadTemplate, &regs, &regs);
  size_of_template_data=regs.r[1];
  size_of_indirected_data=regs.r[2];

  // malloc this amount
  template_data=malloc(size_of_template_data);
  indirected_data=malloc(size_of_indirected_data);

  // load the template
  regs.r[1]=(int) template_data;
  regs.r[2]=(int) indirected_data;
  regs.r[3]=(int) indirected_data+size_of_indirected_data;
  regs.r[4]=(int) font_array;
  regs.r[5]=(int) window_name;
  regs.r[6]=0;
  _kernel_swi(Wimp_LoadTemplate, &regs, &regs);

  // set the sprite area pointer
  template_data[16]=(int) sprite_area;

  regs.r[1]=(int) template_data;
  _kernel_swi(Wimp_CreateWindow, &regs, &regs);
  window_handle=regs.r[0];

  // free the template data (indirected is still needed)
  free(template_data);

  return window_handle;
}

void close_template(void)
{
  _kernel_swi(Wimp_CloseTemplate, &regs, &regs);
}

void load_zap_fonts(void)
{
  redraw.r_workarea=zapredraw_block;

  // load in hires and lores zap fonts
  zap_font_area=load_font(zap_font);
  zap_lowres_font_area=load_font(zap_lowres_font);

  // do mode_change to set things up
  mode_change();
}

int *load_font(char *zap_font)
{
  char string[5]="ZFLK";
  char character;
  int *zap_load_area;
  int width;
  int height;
  int last_char;
  int first_char;
  int char_size;
  FILE *file_handle=0;
  char file_end[256];
  char file_start[256];
  char file_name[1024];
  int object_type;

  get_system_variable(file_name,"ZapFontsSource$Path");
  if (strlen(file_name)!=0)
  {
    strcpy(file_start,"ZapFontsSource:");
  }
  else
  {
    strcpy(file_start,"<Nettle$Dir>.Fonts.");
  }

  strcpy(file_end,zap_font);

  // if string is ZFLK, then this is a redirection font
  while (strcmp(string,"ZFLK")==0)
  {
    sprintf(file_name,"%s%s",file_start,file_end);

    regs.r[0]=17;
    regs.r[1]=(int) file_name;

    // if it's there, what sort of object is it
    if (_kernel_swi(OS_File,&regs,&regs)==0)
    {
      object_type=regs.r[0];
      switch (object_type)
      {
        case 0:
          strcpy(string,"");
          break;
        case 2:
          // If it's a directory, plonk .0 on the end
          strcat(file_end,".0");
          strcat(file_name,".0");
          break;
      }

      file_handle=fopen(file_name,"r");

      if (file_handle!=0)
      {
        fgets(string,5,file_handle);

        // if it's redirection then
        if (strcmp(string,"ZFLK")==0)
        {
          // get the new line character
          character=fgetc(file_handle);

          // get the redirection font
          fgets(file_end,256,file_handle);

          fclose(file_handle);
        }
      }
    }
    else
    {
      strcpy(string,"");
    }
  }

  if (file_handle==0)
  {
    // if we didn't find a font, use Nettle's internal one
    strcpy(file_name,"<Nettle$Dir>.Fonts.08x16.Default.0");
    file_handle=fopen(file_name,"r");
  }

  fseek(file_handle,8,SEEK_SET);

  // Get font information
  width=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
         ((fgetc(file_handle))<<24);
  height=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
          ((fgetc(file_handle))<<24);
  first_char=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
              ((fgetc(file_handle))<<24);
  last_char=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
             ((fgetc(file_handle))<<24);

  // Set real character size (will be needed to implement graphics characters)
  if ((width % 8)==0)
  {
    char_size=width*height/8;
  }
  else
  {
    char_size=(width+(8-(width % 8)))*height/8;
  }
  zap_load_area=malloc(char_size*(0x11D-first_char)+0x20);
  fclose(file_handle);

  regs.r[0]=16;
  regs.r[1]=(int) file_name;
  regs.r[2]=(int) zap_load_area;
  regs.r[3]=0;
  _kernel_swi(OS_File, &regs, &regs);

  // fill in graphics chars
  define_zap_chars(zap_load_area+8+(char_size*(0x40-(zap_load_area[4]))),char_size,width,height);

  return zap_load_area;
}

void create_icon_bar_icon(void)
{
  int block[9];

  block[0]=-1; // window handle
  block[1]=0;  // min x
  block[2]=0;  // min y
  block[3]=68; // max x
  block[4]=68; // max y
  block[5]=binary("10111000000000011000100011010");
  block[6]=(int) application_icon_name;
  block[7]=(int) sprite_area;
  block[8]=strlen(application_icon_name);

  regs.r[1]=(int) block;
  _kernel_swi(Wimp_CreateIcon, &regs, &regs);
  iconbar_handle=regs.r[0];
}
