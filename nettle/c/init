/* Initialisation code */
/* by A. Macfarlane Smith */
/* (C) Archifishal Software 2001 */

#include "generic.h"
#include "globals.h"

#include "chardefn.h"
#include "init.h"
#include "misc.h"
#include "nettle.h"
#include "quit.h"
#include "wimp.h"
#include "zapredraw.h"

int *initialise_messages(void)
{
  static int message_list[] =
  {
    2,       /* DataSaveAck */
    0x400C1, /* ModeChange */
    0x808C1, /* TW_Output */
    0x808C2, /* TW_Ego */
    0x808C3, /* TW_Morio */
    0        /* Quit */
  };

  return message_list;
}

void load_messages(void)
{
  char country[16];
  char messages_file_name[1024];
  FILE *file_handle;
  int size_of_messagetrans_buffer;

  /* Get the country - if it has null length, then default to UK */
  if (strlen(get_country(country, 16))==0)
    strcpy(country,"UK");

  /* put together filename */
  sprintf(messages_file_name,"<%s$Dir>.Resources.%s.Messages",application_name,country);

  /* open the file */
  file_handle=fopen(messages_file_name,"r");

  /* if we don't open it, then definitely set country to UK */
  if (file_handle==0)
    strcpy(country,"UK");
  else
    fclose(file_handle);

  sprintf(messages_file_name,"<%s$Dir>.Resources.%s.Messages",application_name,country);

  /* Now re-open it */
  size_of_messagetrans_buffer=_swi(MessageTrans_FileInfo,_IN(1)|_RETURN(2), messages_file_name);

  messagetrans_buffer=malloc(size_of_messagetrans_buffer);

  _swi(MessageTrans_OpenFile, _IN(0)|_IN(1)|_IN(2), messagetrans_area,
                                                    messages_file_name,
                                                    messagetrans_buffer);
}

void load_sprites(void)
{
  int yeig;
  char file_name[1024];
  FILE *file_handle;

  /* find out what sprites we need to load */
  yeig=(int) pow(2, _swi(OS_ReadModeVariable, _IN(0)|_IN(1)|_RETURN(2), -1, 5) );

  sprintf(file_name,"<%s$Dir>.Resources.Sprites",application_name);

  /* if we're in a 2 high pixel mode, append 22 */
  if (yeig==2)
    strcat(file_name,"22");

  file_handle=fopen(file_name,"r");
  if (file_handle==0)
  {
    generror("NoSprites", true);
    closedown_application();
  }
  else
  {
    int size;
    fclose(file_handle);

    /* get the sprite file size */
    size=_swi(OS_File, _IN(0)|_IN(1)|_RETURN(4), 5, file_name)+64;

    /* malloc a block big enough for it */
    sprite_area=malloc(size);

    /* set up the block */
    sprite_area->total_size=size;
    sprite_area->offset_to_1st_sprite=16;

    /* initialise area */
    _swi(OS_SpriteOp, _IN(0)|_IN(1), 256+9, sprite_area);

    /* load sprites into it */
    _swi(OS_SpriteOp, _IN(0)|_IN(1)|_IN(2), 256+10, sprite_area, file_name);
  }
}

void load_templates(void)
{
  char info_data[60];

  /* open the templates file */
  open_template();

  /* read template definitions */
  info=load_template(LOAD_TEMPLATE_NO_FONTS,"info",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(info,0,lookup("AppName", info_data, 60));
  set_icon_data(info,1,lookup("AppAuthor", info_data, 60));
  set_icon_data(info,5,lookup("AppVersion", info_data, 60));
  set_icon_data(info,6,lookup("AppPurpose", info_data, 60));

  choices=load_template(LOAD_TEMPLATE_NO_FONTS,"choices",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  open=load_template(LOAD_TEMPLATE_NO_FONTS,"open",LOAD_TEMPLATE_WIMP_SPRITE_AREA);
  set_icon_data(open,4,lookup("Telnet", info_data, 60));
  set_icon_data(open,9,terminal_name[NETTLE_TERMINAL_VT220]);

  resize=load_template(LOAD_TEMPLATE_NO_FONTS,"resize",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  save=load_template(LOAD_TEMPLATE_NO_FONTS,"save",LOAD_TEMPLATE_WIMP_SPRITE_AREA);

  /* close the templates file */
  close_template();
}

void open_template(void)
{
  int use_3d_templates=false;
  char country[16];
  char template_filename[1024];
  FILE *file_handle;

  /* Check 3D bit of CMOS RAM */
  if (_swi(OS_Byte, _IN(0)|_IN(1)|_RETURN(2), 161, 0x8C) & 1)
    use_3d_templates=true;

  /* Again, set country to UK if we don't know */
  if (strlen(get_country(country, 16))==0)
    strcpy(country,"UK");

  /* Put together filename */
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  /* append filename according to 3D flag */
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  /* If we fail to open, change to UK */
  if (file_handle==0)
  {
    strcpy(country,"UK");
  }
  else
  {
    fclose(file_handle);
  }

  /* Put together filename */
  sprintf(template_filename,"<%s$Dir>.Resources.%s",application_name,country);

  /* append correct filename */
  if (use_3d_templates==false)
  {
    strcat(template_filename,".Templates");
  }
  else
  {
    strcat(template_filename,".Template3D");
  }

  file_handle=fopen(template_filename,"r");

  /* this time, if we fail to open, moan about lack of templates and quit */
  if (file_handle==0)
  {
    generror("NoTemplates", true);
    closedown_application();
  }
  else
  {
    fclose(file_handle);
  }

  _swi(Wimp_OpenTemplate, _IN(1), template_filename);
}

int load_template(int *font_array,char *window_name,int *sprite_area)
{
  char window_name_copy[12];
  struct wimp_createwindow_block *template_data;
  int *indirected_data;
  int size_of_template_data;
  int size_of_indirected_data;
  int window_handle;

  /* template name must be in a writable 12-byte buffer */
  strcpy(window_name_copy, window_name);

  /* get sizes of template data and indirected_data */
  _swi(Wimp_LoadTemplate, _IN(1)|_IN(5)|_IN(6)|_OUT(1)|_OUT(2),
                          0, window_name_copy, 0,
                          &size_of_template_data, &size_of_indirected_data);

  /* malloc this amount, indirected first to be heap friendly */
  indirected_data=malloc(size_of_indirected_data);
  template_data=malloc(size_of_template_data);

  /* load the template */
  _swi(Wimp_LoadTemplate, _IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6), template_data,
                          indirected_data, indirected_data+size_of_indirected_data,
                          font_array, window_name_copy, 0);

  /* set the sprite area pointer */
  template_data->sprite_area=(int) sprite_area;

  window_handle=_swi(Wimp_CreateWindow, _IN(1)|_RETURN(0), template_data);

  /* free the template data (indirected is still needed) */
  free(template_data);

  return window_handle;
}

void close_template(void)
{
  _swi(Wimp_CloseTemplate, 0);
}

void load_zap_fonts(void)
{
  redraw.r_workarea=zapredraw_block;

  /* load in hires and lores zap fonts */
  zap_font_area=load_font(zap_font);
  zap_lowres_font_area=load_font(zap_lowres_font);

  /* do mode_change to set things up */
  mode_change();
}

int *load_font(char *zap_font)
{
  char string[5]="ZFLK";
  char character;
  int *zap_load_area;
  int width;
  int height;
  int last_char;
  int first_char;
  int char_size;
  FILE *file_handle=0;
  char file_end[256];
  char file_start[256];
  char file_name[1024];
  int object_type;

  get_system_variable(file_name,"ZapFontsSource$Path",1024);
  if (strlen(file_name)!=0)
  {
    strcpy(file_start,"ZapFontsSource:");
  }
  else
  {
    strcpy(file_start,"<Nettle$Dir>.Fonts.");
  }

  strcpy(file_end,zap_font);

  /* if string is ZFLK, then this is a redirection font */
  while (strcmp(string,"ZFLK")==0)
  {
    sprintf(file_name,"%s%s",file_start,file_end);

    /* if it's there, what sort of object is it */
    if (_swix(OS_File, _IN(0)|_IN(1)|_OUT(0), 17, file_name, &object_type)==0)
    {
      switch (object_type)
      {
        case 0:
          strcpy(string,"");
          break;
        case 2:
          /* If it's a directory, plonk .0 on the end */
          strcat(file_end,".0");
          strcat(file_name,".0");
          break;
      }

      file_handle=fopen(file_name,"r");

      if (file_handle!=0)
      {
        fgets(string,5,file_handle);

        /* if it's redirection then */
        if (strcmp(string,"ZFLK")==0)
        {
          /* get the new line character */
          character=fgetc(file_handle);

          /* get the redirection font */
          fgets(file_end,256,file_handle);

          fclose(file_handle);
        }
      }
    }
    else
    {
      strcpy(string,"");
    }
  }

  if (file_handle==0)
  {
    /* if we didn't find a font, use Nettle's internal one */
    strcpy(file_name,"<Nettle$Dir>.Fonts.08x16.Default.0");
    file_handle=fopen(file_name,"r");
  }

  fseek(file_handle,8,SEEK_SET);

  /* Get font information */
  width=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
         ((fgetc(file_handle))<<24);
  height=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
          ((fgetc(file_handle))<<24);
  first_char=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
              ((fgetc(file_handle))<<24);
  last_char=((fgetc(file_handle))<<0)+((fgetc(file_handle))<<8)+((fgetc(file_handle))<<16)+
             ((fgetc(file_handle))<<24);

  /* Set real character size (will be needed to implement graphics characters) */
  if ((width % 8)==0)
  {
    char_size=width*height/8;
  }
  else
  {
    char_size=(width+(8-(width % 8)))*height/8;
  }
  zap_load_area=malloc(char_size*(0x11D-first_char)+0x20);
  fclose(file_handle);

  _swi(OS_File, _IN(0)|_IN(1)|_IN(2)|_IN(3), 16, file_name, zap_load_area, 0);

  /* fill in graphics chars */
  define_zap_chars(zap_load_area+8+(char_size*(0x40-(zap_load_area[4]))),char_size,width,height);

  return zap_load_area;
}

void create_icon_bar_icon(void)
{
  struct wimp_createicon_block block;

  block.window_handle=-1; /* window handle */
  block.minx         =0;  /* min x */
  block.miny         =0;  /* min y */
  block.maxx         =68; /* max x */
  block.maxy         =68; /* max y */
  block.icon_flags   =0x1700311a;
  block.buffer       =application_icon_name;
  block.validation   =(char *) sprite_area;
  block.buffer_length=strlen(application_icon_name);

  iconbar_handle=_swi(Wimp_CreateIcon, _IN(1)|_RETURN(0), &block);
}
