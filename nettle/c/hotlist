/**
 * Nettle Hotlist code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "hotlist.h"
#include "misc.h"
#include "wimp.h"
#include "messages.h"
#include "templ.h"
#include "wimputil.h"
#include "nettle.h"
#include <string.h>
#include <time.h>
#include <ctype.h>

typedef enum
{
  ht_invalid,
  ht_telnet,
  ht_ssh,
  ht_task
} hotlisttype;

typedef struct _hotlistnode
{
  struct _hotlistnode *next;
  hotlisttype type;
  char *label;
  char *host;
  char *command;
  unsigned char internal_state;       /* Used for selection etc */
  unsigned char vttype;               /* An index in to the vt type array -- the user gives a string, and we match that to the array at load time */
  unsigned char uselineeditor;
  unsigned short terminal_width;
  unsigned short terminal_height;
  unsigned short scrollback;
} hotlistnode;

static hotlistnode *editlisthead = NULL;
static hotlistnode *editlisttail = NULL;
static hotlistnode *hotlisthead = NULL;
static hotlistnode *hotlisttail = NULL;
static hotlistnode *selectednode = NULL;
static int edititems = 0;
static int items = 0;
static int *menublock = NULL;

static void int_lose_hotlist(hotlistnode **head);
static void addnodetolist(hotlistnode **head, hotlistnode **tail, hotlistnode *node);
static hotlistnode *hotlist_createnew(void);
static int hotlist_populate_selected(void);
static void hotlist_clear_states(void);

static char *get_icon_data(int window, int icon)
{
  static char buf[256];
  
  return read_icon_data(window, icon, buf, 256);
}

static void copy_hotlist(bool edit_to_live) /* true = copy the editlist to the live list */
{
  hotlistnode *node = edit_to_live ? editlisthead : hotlisthead;
  hotlistnode *newnode;
  
  int_lose_hotlist(edit_to_live ? &hotlisthead : &editlisthead);
  
  if (edit_to_live)
    items = 0;
  else
    edititems = 0;
  
  while (node)
  {
    newnode = (hotlistnode *) malloc(sizeof(hotlistnode));
    if (!newnode)
      return;
      
    newnode->label = NULL;
    newnode->host = NULL;
    newnode->command = NULL;
    newnode->internal_state = node->internal_state;
    newnode->type           = node->type;
    newnode->vttype         = node->vttype;
    newnode->uselineeditor  = node->uselineeditor;
    newnode->terminal_width = node->terminal_width;
    newnode->terminal_height= node->terminal_height;
    newnode->scrollback     = node->scrollback;
    if (node->label)
    {
      newnode->label = malloc(strlen(node->label)+1);
      if (!newnode->label)
        goto erro;
      strcpy(newnode->label, node->label);
    }
    if (node->host)
    {
      newnode->host = malloc(strlen(node->host)+1);
      if (!newnode->host)
        goto erro;
      strcpy(newnode->host, node->host);
    }
    if (node->command)
    {
      newnode->command = malloc(strlen(node->command)+1);
      if (!newnode->command)
        goto erro;
      strcpy(newnode->command, node->command);
    }
    
    if (edit_to_live)
      addnodetolist(&hotlisthead, &hotlisttail, newnode);
    else
      addnodetolist(&editlisthead, &editlisttail, newnode);

    if (edit_to_live)
      items++;
    else
      edititems++;
      
    node = node->next;
  }
 
  return;
 
erro:  
  if (newnode->label)
    free(newnode->label);
  if (newnode->host)
    free(newnode->host);
  if (newnode->command)
    free(newnode->command);
  free(newnode);
}

static int hash_type(hotlisttype *type, const char *value)
{
  if (strncmp(value,"telnet",6)==0)
    *type = ht_telnet;
  else if (strncmp(value,"ssh",3)==0)
    *type = ht_ssh;
  else if (strncmp(value,"task",4)==0)
    *type = ht_task;
  else return 1;

  return 0;
}

static int hash_term(unsigned char *type, const char *value)
{
  int i;
  *type = 0;
  for(i=0; i<NO_OF_TERMINAL_TYPES; i++)
  {
    if (strcmp(value,terminal_name[i])==0)
    {
      *type = i;
      return 0;
    }
  }

  return 1;
}

static int read_hot_string(char **dest, char *value, char *check, const char *compare)
{
  if (strncmp(check,compare,strlen(compare))==0)
  {
    if (*dest)
      return 1;
    *dest = malloc(strlen(value)+1);
    if (!*dest)
      return 1;
    strcpy(*dest, value);
  }
  return 0;
}

static int read_hot_number(unsigned short *dest, char *value, char *check, const char *compare)
{
  if (strncmp(check,compare,strlen(compare))==0)
  {
    unsigned long val = strtoul(value, NULL, 10);
    if (val >= (1<<(8*sizeof(short))) ) /* 65535 */
      return 1;
    *dest = (unsigned short) val;
  }
  return 0;
}

static int read_hot_present(char *flag, char *value, char *check, const char *compare)
{
  *flag = '\0';
  if (strncmp(check,compare,strlen(compare))==0)
  {
    *flag = 'y';
  }
  return 0;
}

static void addnodetolist(hotlistnode **head, hotlistnode **tail, hotlistnode *node)
{
  node->next = NULL;
  if (!*head)
    *head = node;
  else
    (*tail)->next = node;
  *tail = node;
}

void lose_hotlist(void)
{
  int_lose_hotlist(&hotlisthead);
  int_lose_hotlist(&editlisthead);
}

static void int_lose_hotlist(hotlistnode **head)
{
  while (*head)
  {
    hotlistnode *next = (*head)->next;

    if ((*head)->label)
      free((*head)->label);
    if ((*head)->command)
      free((*head)->command);
    if ((*head)->host)
      free((*head)->host);
    free(*head);
    *head = next;
  }

  if (menublock)
    free(menublock);
  menublock = NULL;
}

static char *get_line(FILE *in)
{
  static char string[256];
  char *str;
  int len;

  str = fgets(string, sizeof(string), in);
  if (!str)
   return NULL;

  /* strip CRs, spaces etc off the end */
  len = strlen(string);
  for(;len;len--)
  {
    if (string[len-1]>' ')
      break;
    else
      string[len-1]='\0';
  }

  return string;
}

static hotlistnode *create_blank(void)
{
  hotlistnode *node = (hotlistnode *) malloc(sizeof(hotlistnode));
  if (!node)
    return NULL;

  node->internal_state = 0;
  node->type = ht_telnet;
  node->label = NULL;
  node->host = NULL;
  node->command = NULL;
  /* The following should be pulled from the global choices! */
  hash_term(&node->vttype, "vt220");
  node->uselineeditor = line_editor;
  node->terminal_width = defaultsize.x;
  node->terminal_height = defaultsize.y;
  node->scrollback = defaultscroll;

  return node;
}

static void create_entry(char *title, FILE *in)
{
  char *str,*tail,tmp;
  hotlistnode *node = create_blank();
  if (!node)
    goto error;

  node->label = malloc(strlen(title)+1);
  if (!node->label)
    goto error;

  strcpy(node->label, title);

  str = get_line(in);
  if (!(str[0]=='{' && str[1]=='\0'))
    goto errbarf;

  do
  {
    str = get_line(in);
    if (str)
    {
      if (str[0]=='}')
      {
        addnodetolist(&editlisthead, &editlisttail, node);
        edititems++;
        return;
      }

      if (!(*str=='#' || *str=='\0'))
      {
        while (*str==' ')
          str++;

        if (strlen(str)<6 || str[4]!=':')
          goto errbarf;

        tail = str+5;
        while (*tail==' ')
          tail++;

        if(read_hot_string(&node->host           , tail, str, "host")) goto errbarf;
        if(read_hot_string(&node->command        , tail, str, "cmnd")) goto errbarf;
        if(read_hot_number(&node->terminal_width , tail, str, "wide")) goto errbarf;
        if(read_hot_number(&node->terminal_height, tail, str, "high")) goto errbarf;
        if(read_hot_number(&node->scrollback     , tail, str, "scrl")) goto errbarf;
        if(read_hot_present(&tmp                 , tail, str, "type")) goto errbarf;
          else if (tmp) if (hash_type(&node->type, tail)) goto errbarf;
        if(read_hot_present(&tmp                 , tail, str, "term")) goto errbarf;
          else if (tmp) if (hash_term(&node->vttype, tail)) goto errbarf;

      }
    }
  } while (str);

errbarf:
  generror("BadHotlist", true);
error:
  if (node)
  {
    if (node->label)   free(node->label);
    if (node->host)    free(node->host);
    if (node->command) free(node->command);
    free(node);
  }
  fseek(in, 0, SEEK_END);

}

static bool save_hotlist(void)
{
  char hotlist_path[256];
  char string[256];
  hotlistnode *node = hotlisthead;

  get_system_variable(hotlist_path, "Choices$Write", sizeof(hotlist_path));

  if (hotlist_path[0] == '\0' )
  {
    sprintf(string, "<%s$Dir>.Choices", application_name);
  }
  else
  {
    sprintf(string, "<Choices$Write>.%s", application_name);
  }

  _swi(OS_File, _INR(0,1)|_IN(4), 8, string, 0);
  strcat(string, ".Hotlist");

  _kernel_last_oserror();

  {
    bool error=false;
    FILE *file_handle=fopen(string, "w");

    if (file_handle==NULL)
    {
      /* Couldn't open the file for writing */
      error=true;
    }
    else
    {
      time_t current_time;

      time(&current_time);

      fprintf(file_handle, "# Nettle hotlist file\n");
      fprintf(file_handle, "# Created on %s", ctime(&current_time));
      
      while (node)
      {
        if(node->label && node->label[0])
          fprintf(file_handle, "\n%s\n{\n", node->label);
        else
          fprintf(file_handle, "\n(Unnamed){\n");
        
        if(node->host && node->host[0])
          fprintf(file_handle, "  host: %s\n", node->host);
          
        if(node->command && node->command[0])
          fprintf(file_handle, "  cmnd: %s\n", node->command);
        
        fprintf(file_handle, "  type: %s\n", \
          node->type != ht_task ? node->type != ht_ssh ? \
          "telnet" : "ssh" : "task");
        
        fprintf(file_handle, "  term: %s\n", terminal_name[node->vttype]);
        
        fprintf(file_handle, "  wide: %d\n", node->terminal_width);
        
        fprintf(file_handle, "  high: %d\n", node->terminal_height);
        
        fprintf(file_handle, "  scrl: %d\n", node->scrollback);
        
        fprintf(file_handle, "}\n");
        
        node = node->next;
      }


      if (!ferror(file_handle))
      {
        if (fclose(file_handle))
          error=true;

        file_handle=NULL;
      }
    }

    if (error)
    {
      gensaveerror(file_handle, "CantSaveHotlist");
      return false;
    }

    return true;
  }
}

void load_hotlist(void)
{
  FILE *file_handle;
  char hotlist_path[256];
  char string[256];
  char *str;

  get_system_variable(hotlist_path, "Choices$Write", sizeof(hotlist_path));

  if (hotlist_path[0] == '\0' )
  {
    sprintf(string, "<%s$Dir>.Choices.Hotlist", application_name);
  }
  else
  {
    sprintf(string, "Choices:%s.Hotlist", application_name);
  }

  file_handle = fopen(string,"r");
  if (!file_handle)
    return;

  do
  {
    str = get_line(file_handle);
    if (str)
    {
      if (!(*str=='#' || *str=='\0'))
      {
        create_entry(str, file_handle);
      }
    }
  } while (str);

  copy_hotlist(true);

  fclose(file_handle);
}

int *create_hotlist_menu(void)
{
  hotlistnode *node = hotlisthead;
  int position=7;
  int wide=200;

  if (!items)
    return NULL;

  if (!menublock)
  {
    menublock = (int *) malloc(24*items+28);
    if (!menublock)
      return NULL;

    lookup("Hotlist", (char *)menublock, 12);

    menublock[3]=(7<<0)+(2<<8)+(7<<16)+(0<<24); /* black on white items, black on grey title text */
    menublock[4]=wide;
    menublock[5]=44;
    menublock[6]=0;

    while (node)
    {
      menublock[position++]= node->next ? 0 : (1<<7);  /* Set "last" bit if this is the end of the list */
      menublock[position++]=-1;  /* No submenu */
      menublock[position++]=WIMP_ICON_FGCOL(7) | WIMP_ICON_VCENT_BIT | WIMP_ICON_FILLED_BIT | \
  			    WIMP_ICON_TEXT_BIT | WIMP_ICON_INDIRECTED_BIT | WIMP_ICON_SPRITE_BIT;

      menublock[position++]=(int) node->label;
      menublock[position++]=(int)(node->type == ht_ssh ? "snettle_ssh" : \
                                  node->type == ht_telnet ? "snettle_telnt" :
                                  "snettle_task");
      menublock[position++]=strlen(node->label)+1;
    
    if (menublock[position-1]+1 * 16 > wide)
      wide =  menublock[position-1]+1 * 16;

      node = node->next;
    }
    
    menublock[4] = wide;
  }
  return (int *) menublock;
}


static hotlistnode *decode_hotlist_menu(hotlistnode *node, int entry)
{
  if (entry<0 || entry>=((node==hotlisthead)?items:edititems))
    return NULL;

  for(;entry>0;entry--)
    node = node->next;

  return node;
}

void hotlist_draw(struct wimp_getrectangle_block *getrect_block)
{
  struct wimp_ploticon_block pib;
  int y=-4;
  hotlistnode *node = editlisthead;

  pib.min.x = 12;
  pib.max.x = 1024;
  pib.icon_flags = WIMP_ICON_TEXT_BIT | WIMP_ICON_SPRITE_BIT | WIMP_ICON_VCENT_BIT | \
                   WIMP_ICON_INDIRECTED_BIT | WIMP_ICON_FILLED_BIT | WIMP_ICON_FGCOL(7);

  for(;node;node=node->next)
  {
    pib.max.y = y;
    pib.min.y = y-44;
    y-=44;

    pib.contents.it.text = node->label;
    pib.contents.it.validation = (char *)(int) (node->type == ht_ssh ? "snettle_ssh" : \
                                 node->type == ht_telnet ? "snettle_telnt" :
                                 "snettle_task");

    if (node->internal_state & 1)
      pib.icon_flags |= WIMP_ICON_BGCOL(2);
    else
      pib.icon_flags &= ~WIMP_ICON_BGCOL((unsigned int)15);

    pib.contents.it.text_len = strlen(pib.contents.it.text)+1;
    _swi(Wimp_PlotIcon, _IN(1), &pib);
  }
}

int hotlist_num_items(void)
{
  return items;
}

static void hotlist_clear_states(void)
{
  hotlistnode *node = editlisthead;

  for(;node;node=node->next)
  {
    node->internal_state &= ~1;
  }
}

static void hotlist_delete_selected(void)
{
  hotlistnode *node = editlisthead;
  hotlistnode *prev = NULL;

  for(;node;prev=node, node=node->next)
  {
    if(node->internal_state & 1)
    {
      if (prev)
        prev->next = node->next;
      else
        editlisthead = node->next;
        
      if (editlisttail)
      {
        if (editlisttail == node)
          editlisttail = prev;
      }
      
      if (node->label)
        free(node->label);
      if (node->command)
        free(node->command);
      if (node->host)
        free(node->host);
      free(node);
      edititems--;
      return;
    }
  }
}

static bool copy_hotedit_to_selected(void)
{
  char *tmp;
  int num;
  hotlistnode *node = selectednode;
  
  if (!selectednode)
    return true;  /* Shouldn't be possible */
    
  tmp = get_icon_data(win_hotedit, icon_hotedit_label);
  while (*tmp==' ')
    tmp++;
  
  if(*tmp<' ')
  {
    generror("HotBlankLabel",true);
    return false;
  }

  if (node->label)
    free(node->label);
  node->label = strdup(tmp);

  
  tmp = get_icon_data(win_hotedit, icon_hotedit_hostname);
  while (*tmp==' ')
    tmp++;
/*  
  if(*tmp<' ')
  {
    generror("HotBlankHost",true);
    return false;
  }
*/
  if (node->host)
    free(node->host);
  node->host = strdup(tmp);
  
  
  tmp = get_icon_data(win_hotedit, icon_hotedit_command);
  while (*tmp==' ')
    tmp++;
/*  
  if(*tmp<' ')
  {
    generror("HotBlankCommand",true);
    return false;
  }
*/
  if (node->command)
    free(node->command);
  node->command = strdup(tmp);
  
  
  tmp = get_icon_data(win_hotedit, icon_hotedit_termwidth);
  num = atoi(tmp);

  if (num<2 || num>65535)
  {
    generror("HotBadWidth",true);
    return false;
  }

  node->terminal_width = num;

  
  tmp = get_icon_data(win_hotedit, icon_hotedit_termheight);
  num = atoi(tmp);

  if (num<2 || num>65535)
  {
    generror("HotBadHeight",true);
    return false;
  }

  node->terminal_height = num;

  
  tmp = get_icon_data(win_hotedit, icon_hotedit_scrollback);
  num = atoi(tmp);

  if (num<0 || num>65535)
  {
    generror("HotBadScroll",true);
    return false;
  }

  node->scrollback = num;

  return true;
}

static int hotlist_populate_selected(void)
{
  hotlistnode *node = editlisthead;
  char tmp[20];

  for(;node;node=node->next)
  {
    if(node->internal_state & 1)
    {
      selectednode = node;
      
      set_icon_data(win_hotedit, icon_hotedit_label, node->label ? node->label : "<unnamed>");
      set_icon_data(win_hotedit, icon_hotedit_hostname, node->host ? node->host : "");
      set_icon_data(win_hotedit, icon_hotedit_command, node->command ? node->command : "");
      sprintf(tmp,"%d",node->terminal_width);
      set_icon_data(win_hotedit, icon_hotedit_termwidth, tmp);
      sprintf(tmp,"%d",node->terminal_height);
      set_icon_data(win_hotedit, icon_hotedit_termheight, tmp);
      sprintf(tmp,"%d",node->scrollback);
      set_icon_data(win_hotedit, icon_hotedit_scrollback, tmp);

      /* Need to set connection, term type, line editor type */

      return 1;
    }
  }
  return 0;
}

static hotlistnode *hotlist_createnew(void)
{
  hotlistnode *node = create_blank();
  if (!node)
    return NULL;

  if (menublock)
    free(menublock);
  menublock = NULL;

  node->label = malloc(100);
  if (!node->label)
    goto err;
  node->command = malloc(256);
  if (!node->label)
    goto err;
  node->host = malloc(256);
  if (!node->label)
    goto err;

  strcpy(node->label, "New item");
  node->command[0]='\0';
  node->host[0]='\0';

  addnodetolist(&editlisthead, &editlisttail, node);
  edititems++;
  return node;

err:
  if (node->label) free(node->label);
  if (node->command) free(node->command);
  if (node->host) free(node->host);
  free(node);

  return NULL;
}


void win_panehot_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_panehot_new:
      {
        hotlistnode *node = hotlist_createnew();
        hotlist_clear_states();
        node->internal_state |= 1;
      }
      hotlist_populate_selected();
      open_window_centred(win_hotedit);
      _swi(Wimp_SetCaretPosition, _INR(0,5), win_hotedit, icon_hotedit_label, \
        -1, -1, -1, get_icon_data_length(win_hotedit, icon_hotedit_label));
      resize_hotpane();
      force_redraw(win_hotpane,0,-(1<<28),1024,0);
      {
        struct wimp_getwindowinfo_block window;
        window.window_handle=win_hotpane;
        _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */
        window.scroll.y=-(1<<28);
        _swi(Wimp_OpenWindow, _IN(1), &window);
      }
      break;

    case icon_panehot_edit:
      if (hotlist_populate_selected())
      {
        open_window_centred(win_hotedit);
        _swi(Wimp_SetCaretPosition, _INR(0,5), win_hotedit, icon_hotedit_label, \
          -1, -1, -1, get_icon_data_length(win_hotedit, icon_hotedit_label));
      }
      break;

    case icon_panehot_delete:
      close_window(win_hotedit);
      if (hotlist_populate_selected())
      {
        if (generror_question(lookup_static("DeleteHot")))
        {
          hotlist_delete_selected();
          resize_hotpane();
          force_redraw(win_hotpane,0,-(1<<28),1024,0);
          {
            struct wimp_getwindowinfo_block window;
            window.window_handle=win_hotpane;
            _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */
            _swi(Wimp_OpenWindow, _IN(1), &window);
          }
        }
      }
      break;

  }
}


void win_hotpane_click(int x, int y, int buttons, int icon_handle)
{
  int item, x_pos, y_pos;
  hotlistnode *node;

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=win_hotpane;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    x_pos=block.min.x-block.scroll.x;
    y_pos=block.max.y-block.scroll.y;
  }

  item = -((y-y_pos)+8)/44;

  node = decode_hotlist_menu(editlisthead, item);
  if (!node)
    return;

  switch(buttons)
  {
    case ClickSelect:
      hotlist_clear_states();
      node->internal_state |= 1;
      force_redraw(win_hotpane,0,-(1<<28),1024,0);
      break;

    case ClickAdjust:
      hotlist_clear_states();
      force_redraw(win_hotpane,0,-(1<<28),1024,0);
      break;

    case DoubleSelect:
      win_panehot_click(0,0,4,icon_panehot_edit);
      break;

    case DragSelect:
      hotlist_clear_states();
      node->internal_state |= 1;
      force_redraw(win_hotpane,0,-(1<<28),1024,0);

      /* Start dragging the item here */
      break;
  }
}


void win_hotedit_click(int x, int y, int buttons, int icon_handle)
{
  switch(icon_handle)
  {
  case icon_hotedit_cancel:
    close_window(win_hotedit);
    break;
      
  case icon_hotedit_update:
    if(copy_hotedit_to_selected())
      close_window(win_hotedit);
    break;
      
  case icon_hotedit_delete:
    if (generror_question(lookup_static("DeleteHot")))
    {
      close_window(win_hotedit);
      hotlist_delete_selected();
      resize_hotpane();
      force_redraw(win_hotpane,0,-(1<<28),1024,0);
      {
        struct wimp_getwindowinfo_block window;
        window.window_handle=win_hotpane;
        _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */
        _swi(Wimp_OpenWindow, _IN(1), &window);
      }
    }
    break;
  }
}

void resize_hotpane(void)
{
  struct wimp_getwindowinfo_block window;
  struct wimp_setextent_block ext;
  window.window_handle=win_hotpane;

  _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */
  ext.min.x = 0;
  ext.max.y = 0;
  ext.max.x = window.max.x - window.min.x;
  ext.min.y = -(edititems*44 + 16);
  if (ext.min.y> -(window.max.y - window.min.y))
    ext.min.y = -(window.max.y - window.min.y);

  _swi(Wimp_SetExtent,_INR(0,1),win_hotpane, &ext);
}

void fire_hotlist(int item)
{
  hotlistnode *hot = decode_hotlist_menu(hotlisthead, item);
  struct connection_params params;

  if (!hot)
    return;

  params.terminal_type    = (enum nettle_terminal) hot->vttype;
  params.host             = hot->host;
  params.port             = 0;
  params.command          = hot->command;
  params.width            = hot->terminal_width;
  params.height           = hot->terminal_height;
  params.scrollback       = hot->scrollback;
  params.line_editor_type = hot->uselineeditor;
  strcpy(params.label, hot->label);

  switch(hot->type)
  {
    case ht_telnet:
      params.connection_type = NETTLE_TELNET;
      break;

    case ht_ssh:
      params.connection_type = NETTLE_SSH;
      break;

    case ht_task:
      params.connection_type = NETTLE_TASKWINDOW;
      break;

    default:
      return;
  }

  start_connection_friedport(&params);
}

bool finish_hotlist_editing(int dowhat) /* 0=cancel, 1=set, 2=save */
{
  copy_hotlist(dowhat ? true : false);
  
  if (dowhat == 2)
  {
    return save_hotlist();
  }
  
  return true;
}
