/**
 * Nettle Hotlist code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "hotlist.h"
#include "misc.h"
#include "wimp.h"
#include "messages.h"
#include "templ.h"
#include "wimputil.h"
#include "nettle.h"
#include <ctype.h>

static hotlistnode *hotlisthead = NULL;
static hotlistnode *hotlisttail = NULL;
static int items = 0;
static int *menublock = NULL;

static int hash_type(hotlisttype *type, const char *value)
{
  if (strncmp(value,"telnet",6)==0)
    *type = ht_telnet;
  else if (strncmp(value,"ssh",3)==0)
    *type = ht_ssh;
  else if (strncmp(value,"task",4)==0)
    *type = ht_task;
  else return 1;

  return 0;
}

static int hash_term(unsigned char *type, const char *value)
{
  int i;
  *type = 0;
  for(i=0; i<NO_OF_TERMINAL_TYPES; i++)
  {
    if (strcmp(value,terminal_name[i])==0)
    {
      *type = i;
      return 0;
    }
  }

  return 1;
}

static int read_hot_string(char **dest, char *value, char *check, const char *compare)
{
  if (strncmp(check,compare,strlen(compare))==0)
  {
    if (*dest)
      return 1;
    *dest = malloc(strlen(value)+1);
    if (!*dest)
      return 1;
    strcpy(*dest, value);
  }
  return 0;
}

static int read_hot_number(unsigned short *dest, char *value, char *check, const char *compare)
{
  if (strncmp(check,compare,strlen(compare))==0)
  {
    unsigned long val = strtoul(value, NULL, 10);
    if (val >= (1<<(8*sizeof(short))) ) /* 65535 */
      return 1;
    *dest = (unsigned short) val;
  }
  return 0;
}

static int read_hot_present(char *flag, char *value, char *check, const char *compare)
{
  *flag = '\0';
  if (strncmp(check,compare,strlen(compare))==0)
  {
    *flag = 'y';
  }
  return 0;
}

static void addnodetolist(hotlistnode *node)
{
  node->next = NULL;
  if (!hotlisthead)
    hotlisthead = node;
  else
    hotlisttail->next = node;
  hotlisttail = node;
  items++;
}

void lose_hotlist(void)
{
  while (hotlisthead)
  {
    hotlistnode *next = hotlisthead->next;

    if (hotlisthead->label)
      free(hotlisthead->label);
    if (hotlisthead->command)
      free(hotlisthead->command);
    if (hotlisthead->host)
      free(hotlisthead->host);
    free(hotlisthead);
    hotlisthead = next;
  }

  if (menublock)
    free(menublock);
}

static char *get_line(FILE *in)
{
  static char string[256];
  char *str;
  int len;

  str = fgets(string, sizeof(string), in);
  if (!str)
   return NULL;

  /* strip CRs, spaces etc off the end */
  len = strlen(string);
  for(;len;len--)
  {
    if (string[len-1]>' ')
      break;
    else
      string[len-1]='\0';
  }

  return string;
}

static hotlistnode *create_blank(void)
{
  hotlistnode *node = (hotlistnode *) malloc(sizeof(hotlistnode));
  if (!node)
    return NULL;

  node->internal_state = 0;
  node->type = ht_telnet;
  node->label = NULL;
  node->host = NULL;
  node->command = NULL;
  /* The following should be pulled from the global choices! */
  hash_term(&node->vttype, "vt220");
  node->uselineeditor = line_editor;
  node->terminal_width = defaultsize.x;
  node->terminal_height = defaultsize.y;
  node->scrollback = defaultscroll;

  return node;
}

static void create_entry(char *title, FILE *in)
{
  char *str,*tail,tmp;
  hotlistnode *node = create_blank();
  if (!node)
    goto error;

  node->label = malloc(strlen(title)+1);
  if (!node->label)
    goto error;

  strcpy(node->label, title);

  str = get_line(in);
  if (!(str[0]=='{' && str[1]=='\0'))
    goto errbarf;

  do
  {
    str = get_line(in);
    if (str)
    {
      if (str[0]=='}')
      {
        addnodetolist(node);
        return;
      }

      if (!(*str=='#' || *str=='\0'))
      {
        while (*str==' ')
          str++;

        if (strlen(str)<6 || str[4]!=':')
          goto errbarf;

        tail = str+5;
        while (*tail==' ')
          tail++;

        if(read_hot_string(&node->host           , tail, str, "host")) goto errbarf;
        if(read_hot_string(&node->command        , tail, str, "cmnd")) goto errbarf;
        if(read_hot_number(&node->terminal_width , tail, str, "wide")) goto errbarf;
        if(read_hot_number(&node->terminal_height, tail, str, "high")) goto errbarf;
        if(read_hot_number(&node->scrollback     , tail, str, "scrl")) goto errbarf;
        if(read_hot_present(&tmp                 , tail, str, "type")) goto errbarf;
          else if (tmp) if (hash_type(&node->type, tail)) goto errbarf;
        if(read_hot_present(&tmp                 , tail, str, "term")) goto errbarf;
          else if (tmp) if (hash_term(&node->vttype, tail)) goto errbarf;

      }
    }
  } while (str);

errbarf:
  generror("BadHotlist", true);
error:
  if (node)
  {
    if (node->label)   free(node->label);
    if (node->host)    free(node->host);
    if (node->command) free(node->command);
    free(node);
  }
  fseek(in, 0, SEEK_END);

}

void load_hotlist(void)
{
  FILE *file_handle;
  char hotlist_path[256];
  char string[256];
  char *str;

  get_system_variable(hotlist_path, "Choices$Write", sizeof(hotlist_path));

  if (hotlist_path[0] == '\0' )
  {
    sprintf(string, "<%s$Dir>.Choices.Hotlist", application_name);
  }
  else
  {
    sprintf(string, "Choices:%s.Hotlist", application_name);
  }

  file_handle = fopen(string,"r");
  if (!file_handle)
    return;

  do
  {
    str = get_line(file_handle);
    if (str)
    {
      if (!(*str=='#' || *str=='\0'))
      {
        create_entry(str, file_handle);
      }
    }
  } while (str);

  fclose(file_handle);
}

int *create_hotlist_menu(void)
{
  hotlistnode *node = hotlisthead;
  int position=7;
  int wide=200;

  if (!items)
    return NULL;

  if (!menublock)
  {
    menublock = (int *) malloc(24*items+28);
    if (!menublock)
      return NULL;

    lookup("Hotlist", (char *)menublock, 12);

    menublock[3]=(7<<0)+(2<<8)+(7<<16)+(0<<24); /* black on white items, black on grey title text */
    menublock[4]=wide;
    menublock[5]=44;
    menublock[6]=0;

    while (node)
    {
      menublock[position++]= node->next ? 0 : (1<<7);  /* Set "last" bit if this is the end of the list */
      menublock[position++]=-1;  /* No submenu */
      menublock[position++]=WIMP_ICON_FGCOL(7) | WIMP_ICON_VCENT_BIT | WIMP_ICON_FILLED_BIT | \
  			    WIMP_ICON_TEXT_BIT | WIMP_ICON_INDIRECTED_BIT | WIMP_ICON_SPRITE_BIT;

      menublock[position++]=(int) node->label;
      menublock[position++]=(int)(node->type == ht_ssh ? "snettle_ssh" : \
                                  node->type == ht_telnet ? "snettle_telnt" :
                                  "snettle_task");
      menublock[position++]=strlen(node->label)+1;
    
    if (menublock[position-1]+1 * 16 > wide)
      wide =  menublock[position-1]+1 * 16;

      node = node->next;
    }
    
    menublock[4] = wide;
  }
  return (int *) menublock;
}


hotlistnode *decode_hotlist_menu(int entry)
{
  hotlistnode *node = hotlisthead;

  if (entry<0 || entry>=items)
    return NULL;

  for(;entry>0;entry--)
    node = node->next;

  return node;
}

void hotlist_draw(struct wimp_getrectangle_block *getrect_block)
{
  struct wimp_ploticon_block pib;
  int y=-4;
  hotlistnode *node = hotlisthead;

  pib.min.x = 12;
  pib.max.x = 1024;
  pib.icon_flags = WIMP_ICON_TEXT_BIT | WIMP_ICON_SPRITE_BIT | WIMP_ICON_VCENT_BIT | \
                   WIMP_ICON_INDIRECTED_BIT | WIMP_ICON_FILLED_BIT | WIMP_ICON_FGCOL(7);

  for(;node;node=node->next)
  {
    pib.max.y = y;
    pib.min.y = y-44;
    y-=44;

    pib.contents.it.text = node->label;
    pib.contents.it.validation = (char *)(int) (node->type == ht_ssh ? "snettle_ssh" : \
                                 node->type == ht_telnet ? "snettle_telnt" :
                                 "snettle_task");

    if (node->internal_state & 1)
      pib.icon_flags |= WIMP_ICON_BGCOL(2);
    else
      pib.icon_flags &= ~WIMP_ICON_BGCOL((unsigned int)15);

    pib.contents.it.text_len = strlen(pib.contents.it.text)+1;
    _swi(Wimp_PlotIcon, _IN(1), &pib);
  }
}

int hotlist_num_items(void)
{
  return items;
}

void hotlist_clear_states(void)
{
  hotlistnode *node = hotlisthead;

  for(;node;node=node->next)
  {
    node->internal_state &= ~1;
  }
}

int hotlist_populate_selected(void)
{
  hotlistnode *node = hotlisthead;
  char tmp[20];

  for(;node;node=node->next)
  {
    if(node->internal_state & 1)
    {
      set_icon_data(win_hotedit, icon_hotedit_label, node->label ? node->label : "<unnamed>");
      set_icon_data(win_hotedit, icon_hotedit_hostname, node->host ? node->host : "");
      set_icon_data(win_hotedit, icon_hotedit_command, node->command ? node->command : "");
      sprintf(tmp,"%d",node->terminal_width);
      set_icon_data(win_hotedit, icon_hotedit_termwidth, tmp);
      sprintf(tmp,"%d",node->terminal_height);
      set_icon_data(win_hotedit, icon_hotedit_termheight, tmp);
      sprintf(tmp,"%d",node->scrollback);
      set_icon_data(win_hotedit, icon_hotedit_scrollback, tmp);

      /* Need to set connection, term type, line editor type */

      return 1;
    }
  }
  return 0;
}

hotlistnode *hotlist_createnew(void)
{
  hotlistnode *node = create_blank();
  if (!node)
    return NULL;

  if (menublock)
    free(menublock);
  menublock = NULL;

  node->label = malloc(100);
  if (!node->label)
    goto err;
  node->command = malloc(256);
  if (!node->label)
    goto err;
  node->host = malloc(256);
  if (!node->label)
    goto err;

  strcpy(node->label, "New item");
  node->command[0]='\0';
  node->host[0]='\0';

  addnodetolist(node);
  return node;

err:
  if (node->label) free(node->label);
  if (node->command) free(node->command);
  if (node->host) free(node->host);
  free(node);

  return NULL;
}


void win_panehot_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_panehot_new:
      {
        hotlistnode *node = hotlist_createnew();
        hotlist_clear_states();
        node->internal_state |= 1;
      }
      hotlist_populate_selected();
      open_window_centred(win_hotedit);
      resize_hotpane();
      force_redraw(win_hotpane,0,-(1<<28),1024,0);
      {
        struct wimp_getwindowinfo_block window;
        window.window_handle=win_hotpane;
        _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */
        window.scroll.y=-(1<<28);
        _swi(Wimp_OpenWindow, _IN(1), &window);
      }
      break;

    case icon_panehot_edit:
      if (hotlist_populate_selected())
        open_window_centred(win_hotedit);
      break;

    case icon_panehot_delete:
      close_window(win_hotedit);
      if (hotlist_populate_selected())
      {
        if (generror_question(lookup_static("DeleteHot")))
        {
          /* delete it! */

          resize_hotpane();
          force_redraw(win_hotpane,0,-(1<<28),1024,0);
        }
      }
      break;

  }
}


void win_hotpane_click(int x, int y, int buttons, int icon_handle)
{
  int item, x_pos, y_pos;
  hotlistnode *node;

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=win_hotpane;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    x_pos=block.min.x-block.scroll.x;
    y_pos=block.max.y-block.scroll.y;
  }

  item = -((y-y_pos)+8)/44;

  node = decode_hotlist_menu(item);
  if (!node)
    return;

  switch(buttons)
  {
    case ClickSelect:
      hotlist_clear_states();
      node->internal_state |= 1;
      force_redraw(win_hotpane,0,-(1<<28),1024,0);
      break;

    case ClickAdjust:
      hotlist_clear_states();
      force_redraw(win_hotpane,0,-(1<<28),1024,0);
      break;

    case DoubleSelect:
      win_panehot_click(0,0,4,icon_panehot_edit);
      break;

    case DragSelect:
      hotlist_clear_states();
      node->internal_state |= 1;
      force_redraw(win_hotpane,0,-(1<<28),1024,0);

      /* Start dragging the item here */
      break;
  }
}


void win_hotedit_click(int x, int y, int buttons, int icon_handle)
{
  switch(icon_handle)
  {
    case icon_hotedit_cancel:
      close_window(win_hotedit);
      break;
  }
}

void resize_hotpane(void)
{
  struct wimp_getwindowinfo_block window;
  struct wimp_setextent_block ext;
  window.window_handle=win_hotpane;

  _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */
  ext.min.x = 0;
  ext.max.y = 0;
  ext.max.x = window.max.x - window.min.x;
  ext.min.y = -(hotlist_num_items()*44 + 16);
  if (ext.min.y> -(window.max.y - window.min.y))
    ext.min.y = -(window.max.y - window.min.y);

  _swi(Wimp_SetExtent,_INR(0,1),win_hotpane, &ext);
}

void fire_hotlist(int item)
{
  hotlistnode *hot = decode_hotlist_menu(item);
  struct connection_params params;

  if (!hot)
    return;

  params.terminal_type    = (enum nettle_terminal) hot->vttype;
  params.host             = hot->host;
  params.port             = 0;
  params.command          = hot->command;
  params.width            = hot->terminal_width;
  params.height           = hot->terminal_height;
  params.scrollback       = hot->scrollback;
  params.line_editor_type = hot->uselineeditor;
  strcpy(params.label, hot->label);

  switch(hot->type)
  {
    case ht_telnet:
      params.connection_type = NETTLE_TELNET;
      break;

    case ht_ssh:
      params.connection_type = NETTLE_SSH;
      break;

    case ht_task:
      params.connection_type = NETTLE_TASKWINDOW;
      break;

    default:
      return;
  }

  start_connection_friedport(&params);
}
