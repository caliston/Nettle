/**
 * Wimp_Poll / Wimp code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include <ctype.h>

#include "generic.h"
#include "globals.h"

#include <errno.h>
#include "sys/errno.h"

#ifdef USE_TCPIPLIB
#  include "socklib.h"
#else
#  include "sys/socket.h"
#endif

#include "sys/select.h"
#include "sys/time.h"

#include "choices.h"
#include "hotlist.h"
#include "keyboard.h"
#include "lineedit.h"
#include "messages.h"
#include "main.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "socket.h"
#include "sockwatch.h"
#include "termlist.h"
#include "wimp.h"
#include "zapredraw.h"
#include "templ.h"

#define URI_Dispatch   0x4E381
#define URI_RequestURI 0x4E382

static int menu_data[64];
static int menu_data2[64];
static int *bitmaps_area=0;
static int bitmaps_area_number=0;
static int drag_window_handle=0;
static int drag_icon_handle=0;
static colour_t zap_palette[16];
static int menu_window, menu_icon; /* for use with the currently-open menu */
static int colourpicker_handle;

static bool generror_question(const char *string);
static void create_iconbar_menu(void);
static void create_lineeditor_type_menu(void);
static void open_open_window(bool open_window_flag);
static void open_choices_window(void);
static void set_colour_icon(int, colour_t, bool);
static colour_t get_colour_icon(int, bool);
static int get_icon_data_length(int window_handle, int icon_handle);
static void create_terminal_menu(void);
static void create_connection_menu(void);
static void create_terminal_type_menu(int, int, int);
static void drag_start(int, int);
static bool win_choices_read(int save);

static bool win_is_open(int window_handle)
{
  struct wimp_getwindowstate_block window;

  window.window_handle=window_handle;
  _swi(Wimp_GetWindowState, _IN(1), &window);

  if (window.window_flags & (1<<16))
    return true;

  return false;
}

static void close_choices_window(void)
{
  if (win_is_open(win_paneterm))
    close_window(win_paneterm);

  if (win_is_open(win_panecols))
    close_window(win_panecols);

  if (win_is_open(win_panehot))
    close_window(win_panehot);

  close_window(win_choices);
}

void closedown_wimp(void)
{
  _swi(Wimp_CloseDown, _INR(0,1), task_handle, 0x4b534154);
}

void open_window_centred (int window_handle)
{
  struct wimp_openwindow_block block;
  struct coords screen_size;

  /* get the window state */
  block.window_handle = window_handle;
  _swi (Wimp_GetWindowState, _IN(1), &block);

  /* get screen size (pixels) */
  screen_size.x = _swi (OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 11);
  screen_size.y = _swi (OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 12);

  /* calculate position */
  block.max.x -= block.min.x;
  block.min.x = ((screen_size.x + 1) << eig.x) /2 - block.max.x / 2;
  block.max.x += block.min.x;
  block.max.y -= block.min.y;
  block.min.y = ((screen_size.y + 1) << eig.y) / 2 - block.max.y / 2;
  block.max.y += block.min.y;
  block.handle_behind = -1;	/* open on top of stack */

  open_window(&block, window_handle);
}

/* Dunno what this is needed for really... or it should also */
/* encompass the code currently in mode_change */
/*static void redraw_all_sessions(bool font_change)
{
  struct session_struct *session = sessions;*/

  /* Eventually, also resize the terminals if the current font has been
   * changed. Which is why no use of terminal_size is made here. */

/*  while (session)
  {
    struct wimp_getwindowstate_block block;

    block.window_handle = session->window_handle;
    _swi (Wimp_GetWindowState, _IN(1), &block);

    force_redraw (block.window_handle,
                  block.scroll.x, block.scroll.y + block.min.y - block.max.y,
                  block.scroll.x + block.max.x - block.min.x, block.scroll.y);

    session = session->next;
  }
}*/

static void wimp_pollresolve(struct session_struct *session)
{
  switch (socket_resolvehost(session->socket_host,
                             &session->socket_ip))
  {
    case RESOLVER_INPROGRESS:
      /* resolving not finished yet, continue to take null polls */
      main_requirenull = true;
      break;
    case RESOLVER_FAILED:
      set_title_bar(session->window_handle,
                    lookup_static("title_disconnect"));
      write_out_strings(session, lookup_static("noresolv"), "\r\n", 0);
      session->socket_state=NETTLE_SESSION_NONE;
      break;
    case RESOLVER_SUCCESS:
      session->socket_handle =
                      socket_connecttoip(session->socket_ip,
                                         session->socket_port);

      if (session->socket_handle!=-1)
      {
        session->socket_state = NETTLE_SESSION_CONNECT;
        write_out_strings(session, lookup_static("connecting"),
                          socket_ip_string(session->socket_ip),
                          "...\r\n", 0);
        /* take a null so the state machine gets kicked and wimp_pollconect
         * starts taking null polls */
        main_requirenull = true;
      }
      else
      {
        write_out_strings(session, lookup_static("nosocket"),
                           "\r\n", 0);
        session->socket_state=NETTLE_SESSION_NONE;
      }
  }
}



static void wimp_pollconnect(struct session_struct *session)
{
  switch (socket_connected(session->socket_handle))
  {
    case -6:
      set_title_bar(session->window_handle,
                     lookup_static("title_noconn"));
      write_out_strings(session, lookup_static("noconn"), "\r\n", 0);
      socket_close(session->socket_handle);

      session->socket_handle=0;
      session->socket_state=NETTLE_SESSION_NONE;
      break;
    case 4:
      {
        char string[1024];

        sprintf(string,"Nettle/%s (%s,%d)",
                terminal_name[session->terminal_type],
                session->socket_host,
                session->socket_port);

        set_title_bar(session->window_handle,string);

        session->socket_state = NETTLE_SESSION_CONNECTED;
        write_out_strings(session, lookup_static("connected"),
                          socket_ip_string(session->socket_ip),
                          "\r\n", 0);
        main_requirenull = true; /* read any data waiting on the socket */
        break;
      }
    default:
      /* still connecting, take null polls */
      main_requirenull = true;
      break;
  }
}



static void wimp_pollsocket(struct session_struct *session)
{
  int packet_length;
  char receive_block[RECEIVE_BLOCK_LENGTH];

  packet_length = recv(session->socket_handle, receive_block,
                       RECEIVE_BLOCK_LENGTH, 0);

  if (packet_length == -1 && errno == EWOULDBLOCK)
    /* we've read all the available data */
    return;

  if (packet_length == 0 || packet_length == -1)
  {
    /* EOF or error condition */
    set_title_bar(session->window_handle, lookup_static("title_disconnect"));
    reset_terminal(session);
    if (packet_length == 0)
    {
      /* EOF received */
      write_out_strings(session, "\r\n", lookup_static("closed"), 0);
    }
    else
    {
      char errorstr[16];
      sprintf(errorstr, "%d", errno);
      write_out_strings(session, "\r\n", "Nettle: Socket error ", errorstr,
                        " occurred", 0);
    }

    write_out_strings(session, "\r\n", lookup_static("disconn"), "\r\n", 0);
    socket_close(session->socket_handle);
    session->socket_handle=0;
    session->socket_state=NETTLE_SESSION_NONE;

    return;
  }

  write_out_data(session, receive_block, packet_length);

  /* take a null poll as there may be either more data waiting to be read
   * (and sockwatch won't notify us again about data that's already been
   * received), or there may be an EOF condition waiting for us to read
   * it. We don't try reading again straight away, as we might end up taking
   * lots of processor time if data is arriving faster than we can process
   * it.
   */
  main_requirenull = true;
}



static void wimp_pollsessions(void)
{
  struct session_struct  *session;
  int                     fdupperbound; /* (exclusive) */
  fd_set                  readfds;
  struct timeval          timeval;
  int                     numberready;

  FD_ZERO(&readfds);
  fdupperbound = 0;

  /* for each session, either poll it if necessary, or add its socket to
   * the list of ones to check with select() */
  for (session = sessions; session != NULL; session = session->next)
  {
    if (session->connection_type != NETTLE_TELNET)
      continue;

    switch (session->socket_state)
    {
      case NETTLE_SESSION_RESOLVE:
        wimp_pollresolve(session);
        break;

      case NETTLE_SESSION_CONNECT:
        wimp_pollconnect(session);
        break;

      case NETTLE_SESSION_CONNECTED:
        assert(session->socket_handle >= 0 && session->socket_handle < 256);
        FD_SET(session->socket_handle, &readfds);
        if (session->socket_handle >= fdupperbound)
          fdupperbound = session->socket_handle + 1;
        break;

      case NETTLE_SESSION_NONE:
        /* do nothing */
        break;

      default:
        assert(0);
    }
  }

  if (fdupperbound == 0)
    /* no sockets to be polled */
    return;

  timeval.tv_sec  = 0;
  timeval.tv_usec = 0;

  numberready = select(fdupperbound, &readfds, NULL, NULL, &timeval);
  if (numberready == 0)
    /* no sockets need attention */
    return;

  if (numberready == -1 && errno != EBADF)
    /* error other than an invalid descriptor, nothing we can do */
    return;

  for (session = sessions; session != NULL; session = session->next)
  {
    if (session->connection_type != NETTLE_TELNET)
      continue;

    if (session->socket_state != NETTLE_SESSION_CONNECTED)
      continue;

    if (FD_ISSET(session->socket_handle, &readfds))
      wimp_pollsocket(session);
  }
}


void wimp_nullreasoncode(void)
{
  if (socketwatch_pollword != NULL)
    *socketwatch_pollword = 0;

  wimp_pollsessions();

  close_log(false);

  if (selection_in_progress)
    handle_selection_drag();

  if (cursor_session)
  {
    int now = _swi (OS_ReadMonotonicTime, 0);
    if (now - nextcursortime >= 0)
    {
      nextcursortime = now + CURSOR_BLINK_DELAY;
      cursor_state = cursor_state ? false : true;
      force_redraw (cursor_session->window_handle,
                    cursor_session->pos.x * redraw.r_charw << eig.x,
                    (-cursor_session->pos.y - 1) * redraw.r_charh << eig.y,
                    (cursor_session->pos.x + 1) * redraw.r_charw << eig.x,
                     -cursor_session->pos.y * redraw.r_charh << eig.y);
    }
  }
}



/* Redraw window */

void redraw_window(union wimp_poll_block *wimp_block)
{
  struct session_struct *session = sessions;
  int window_handle = wimp_block->redraw_window.window_handle;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    struct wimp_getwindowstate_block block;
    block.window_handle = wimp_block->redraw_window.window_handle;
    _swi (Wimp_GetWindowState, _IN(1), &block);

    zapgen_code(zapredraw_area,
                session->assigned_area,
                session->terminal_size.x,
		-(block.scroll.y >> eig.y) / redraw.r_charh,
		(((block.max.y - block.min.y- block.scroll.y) >> eig.y) + redraw.r_charh - 1)
		  / redraw.r_charh,
                session->other_session_flags);

    redraw.r_data = zapredraw_area;

    _swi(ZapRedraw_RedrawWindow, _INR(0,1), wimp_block, &redraw);
  }
  else if (colourpicker_handle == 0 || window_handle != menu_window)
  {
    /* *DON'T* redraw the ColourPicker window */
    int more;

    more = _swi(Wimp_RedrawWindow, _IN(1)|_RETURN(0), wimp_block);
    while (more)
      more = _swi(Wimp_GetRectangle, _IN(1)|_RETURN(0), wimp_block);
  }
}



/* Open window */

void open_window(struct wimp_openwindow_block *wimp_block, int window_handle)
{
  struct wimp_openwindow_block local_block, *block=&local_block;
  struct session_struct *session = sessions;

  /* find out which session this window is - if any! */

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (wimp_block)
  {
    /* Called from Wimp_Poll, so use that block, which contains an OpenWindow struct */
    block = wimp_block;
  }
  else
  {
    /* Called from our own code, so fetch the OpenWindow block */
    block->window_handle = window_handle;

    _swi(Wimp_GetWindowState, _IN(1), block);

    block->handle_behind = -1;  /* Open on top of stack */
  }

  if (window_handle==win_choices)
  {
    /* Find out which pane we should be opening */
    struct wimp_whichicon_block whichicon_block;
    int window_id_to_open=0;
    int counter=0;

    _swi(Wimp_WhichIcon, _INR(0,3), window_handle, &whichicon_block, WIMP_ICON_SELECTED_BIT,
                                                                     WIMP_ICON_SELECTED_BIT);

    while (whichicon_block.icons[counter]!=-1)
    {
      switch (whichicon_block.icons[counter])
      {
        case icon_choices_size:
          if (window_id_to_open==0)
            window_id_to_open=win_paneterm;
          else
            generror("More than one 'window' icon set in choices.", false);
          break;

        case icon_choices_colour:
          if (window_id_to_open==0)
            window_id_to_open=win_panecols;
          else
            generror("More than one 'window' icon set in choices.", false);
          break;

        case icon_choices_hotlist:
          if (window_id_to_open==0)
            window_id_to_open=win_panehot;
          else
            generror("More than one 'window' icon set in choices.", false);
          break;
      }
      counter++;
    }

    if (window_id_to_open!=0)
    {
      struct wimp_getwindowinfo_block window;
      window.window_handle=window_id_to_open;

      _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */

      window.max.x += block->min.x - (window.min.x-4);
      window.min.x = block->min.x+4;
      window.min.y = block->min.y+4;
      window.max.y = block->max.y-4;
      window.handle_behind=block->handle_behind;

      if (window_id_to_open == win_panehot)
      {
        /* Uhoh. Need to open the hotlist pane's list pane! */

        struct wimp_getwindowinfo_block window2;
        window2.window_handle=win_hotpane;

        _swi(Wimp_GetWindowInfo, _IN(1), 1 + (int) &window2); /* no icons */

        window2.max.x += window.max.x - (40+12);  /* Guessing the scrollbar width... */
        window2.min.x = window.min.x+12;
        window2.min.y = (window.max.y-12) - (window2.max.y - window2.min.y);
        window2.max.y = window.max.y-12;
        window2.handle_behind=block->handle_behind;

        _swi(Wimp_OpenWindow, _IN(1), &window2);

        window.handle_behind=win_hotpane;

      }

      _swi(Wimp_OpenWindow, _IN(1), &window);

      block->handle_behind=window_id_to_open;
    }
    else
    {
      generror("No 'window' selected in choices.", false);
    }
  }
  else if (session)
  {
    /* This is a main "session" window, so handle the pane, if any */
    struct wimp_getwindowinfo_block window;
    window.window_handle = block->window_handle;
    _swi (Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */

    if (inkey (-2))
    {
      /* Ctrl pressed - allow dynamic resizing */
      /* if the v scrollbar was at the bottom and its vpos is unchanged,
       * force it to the bottom */
      if (window.scroll.y == block->scroll.y &&
	  window.scroll.y - window.max.y + window.min.y == window.work_min.y)
      {
	block->scroll.y = window.work_min.y;
      }
    }
    else
    {
      /* limit to the number of rows */
      int height = block->max.y - block->min.y;
      int maxheight = (session->terminal_size.y * redraw.r_charh) << eig.y;

      /* if the window size is unchanged, DON'T apply this limit
       * (allow for moving the window)
       */
      if (height > maxheight &&
	  (window.max.x - window.min.x != block->max.x - block->min.x ||
	   window.max.y - window.min.y != block->max.y - block->min.y))
      {
        block->min.y = block->max.y - maxheight;
	/* if the v scrollbar was at the bottom and its vpos is unchanged
	 * force it to the bottom */
	if (window.scroll.y == block->scroll.y &&
	    window.scroll.y - window.max.y + window.min.y == window.work_min.y)
	{
	  block->scroll.y = window.work_min.y;
	}
      }

    }

    if (session->line_editor_type!=LINEEDIT_NONE)
    {
      /* open the pane window and set the 'behind' word to behind the pane */
      open_pane_window(session, block);
      block->handle_behind = session->pane_handle;
    }
  }

  _swi(Wimp_OpenWindow, _IN(1), block);
}



/* Close window */

void close_window(int window_handle)
{
  struct wimp_closewindow_block block;
  struct session_struct *session = sessions;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    if (session->socket_state == NETTLE_SESSION_CONNECTED)
    {
      char message[200];
      bool status = generror_question(lookup("ConnectionOpen", message, sizeof(message)));

      if (!status)
        return;
    }
    remove_session(session);
  }
  else
  {
    block.window_handle = window_handle;

    _swi(Wimp_CloseWindow, _IN(1), &block);

    if (window_handle == win_panehot)
    {
      block.window_handle = win_hotpane;
      _swi(Wimp_CloseWindow, _IN(1), &block);
    }
  }
}



/* Determine if there are any sessions open.  If so, query the user as to whether */
/* to really quit the program. */

static void close_program(void)
{
  struct session_struct *session = sessions;

  while (session)
  {
    if (session->socket_state == NETTLE_SESSION_CONNECTED)
    {
      char message[200];

      quit_flag = generror_question(lookup("ConnectionMultiOpen", message, sizeof(message)));
      return;
    }
    session = session->next;
  }
  quit_flag = true;
}



static void iconbar_click(int x, int y, int buttons, int icon_handle)
{
  if (icon_handle==iconbar_handle)
  {
     switch (buttons)
     {
       case 4:
  	 open_open_window(true);
  	 break;
       case 2:
  	 create_iconbar_menu();
  	 break;
       case 1:
         create_hotlist_menu();
         break;
     }
  }
}

static void win_open_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_open_cancel:
      close_window(win_open);
      break;

    case icon_open_connect:
      start_connection();
      break;

    case icon_open_contypebut:
      create_connection_menu();
      break;

    case icon_open_termtypebut:
      create_terminal_type_menu(win_open, icon_open_termtype, icon_open_termtypebut);
      break;
  }
}

static void win_save_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_save_cancel:
      _swi(Wimp_CreateMenu, _IN(1), -1);
      break;

    case icon_save_save:
      {
	char save_data[1024];

	read_icon_data(win_save, icon_save_filename, save_data, sizeof(save_data));

	if ((instr(save_data, ":")>=0))
	{
	  struct wimp_geticonstate_block block;

	  block.window_handle= win_save;
	  block.icon_handle  =icon_save_ansi;

	  _swi(Wimp_GetIconState, _IN(1), &block);

	  /* if selected bit is set, then we save with ANSI colour */
	  if (block.icon_flags & (1<<21))
	  {
	    save_selection(save_data, true);
	  }
	  else
	  {
	    save_selection(save_data, false);
	  }

	  if (buttons!=1)
	  {
	    _swi(Wimp_CreateMenu, _IN(1), -1);
	  }
	}
	else
	{
	  generror("ToSaveDrag", true);
	}
      }
      break;

    case icon_save_drag:
      switch (buttons)
      {
	case 64: case 16:
	  /* Drag */
	  drag_start(win_save, 3);
	  break;
      }
      break;
  }
}


static void win_resize_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_resize_cancel:
      _swi(Wimp_CreateMenu, _IN(1), -1);
      break;

    case icon_resize_set:
      {
        struct coords new_size;
        int new_scrollback;

        if (read_termsize_icons (win_resize,\
          icon_resize_width, icon_resize_height, icon_resize_scroll, \
          &new_size, &new_scrollback))
	{
	  resize_terminal(terminal_menu_session, new_size.x, new_size.y, new_scrollback, true);
	  if (buttons != 1)
	  {
	    _swi(Wimp_CreateMenu, _IN(1), -1);
	  }
	}
      }
      break;
  }
}

static void win_choices_click (int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_choices_size:
      if (win_is_open(win_panecols))
        close_window(win_panecols);

      if (win_is_open(win_panehot))
        close_window(win_panehot);

      set_icon_state(win_choices, icon_choices_size, WIMP_ICON_SELECTED_BIT, WIMP_ICON_SELECTED_BIT);
      set_icon_state(win_choices, icon_choices_colour, 0, WIMP_ICON_SELECTED_BIT);
      set_icon_state(win_choices, icon_choices_hotlist, 0, WIMP_ICON_SELECTED_BIT);

      {
        struct wimp_openwindow_block block;

        block.window_handle=win_choices;
        _swi(Wimp_GetWindowState, _IN(1), &block);

        open_window(&block, win_choices);
      }

      break;

    case icon_choices_colour:
      if (win_is_open(win_paneterm))
        close_window(win_paneterm);

      if (win_is_open(win_panehot))
        close_window(win_panehot);

      set_icon_state(win_choices, icon_choices_size, 0, WIMP_ICON_SELECTED_BIT);
      set_icon_state(win_choices, icon_choices_colour, WIMP_ICON_SELECTED_BIT, WIMP_ICON_SELECTED_BIT);
      set_icon_state(win_choices, icon_choices_hotlist, 0, WIMP_ICON_SELECTED_BIT);

      {
        struct wimp_openwindow_block block;

        block.window_handle=win_choices;
        _swi(Wimp_GetWindowState, _IN(1), &block);

        open_window(&block, win_choices);
      }

      break;

    case icon_choices_hotlist:
      if (win_is_open(win_paneterm))
        close_window(win_paneterm);

      if (win_is_open(win_panecols))
        close_window(win_panecols);

      set_icon_state(win_choices, icon_choices_size, 0, WIMP_ICON_SELECTED_BIT);
      set_icon_state(win_choices, icon_choices_colour, 0, WIMP_ICON_SELECTED_BIT);
      set_icon_state(win_choices, icon_choices_hotlist, WIMP_ICON_SELECTED_BIT, WIMP_ICON_SELECTED_BIT);

      {
        struct wimp_openwindow_block block;

        block.window_handle=win_choices;
        _swi(Wimp_GetWindowState, _IN(1), &block);

        open_window(&block, win_choices);
      }

      break;

    case icon_choices_save:
      if (win_choices_read(true) && save_choices() && (buttons & 1) == 0)
        close_choices_window();
      break;

    case icon_choices_cancel:
      if ((buttons & 1) == 0)
        close_choices_window();
      else
        open_choices_window();
      break;

    case icon_choices_set:
      if (win_choices_read(false) && (buttons & 1) == 0)
        close_choices_window();
      break;
  }
}

static void win_paneterm_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_paneterm_termtypebut:
      create_terminal_type_menu(win_paneterm, icon_paneterm_termtype, icon_paneterm_termtypebut);
      break;
    case icon_paneterm_lineeditbut:
      create_lineeditor_type_menu();
      break;
    case icon_paneterm_hifontbut:
    case icon_paneterm_lofontbut:
      if (create_zap_font_menu (win_paneterm, icon_handle))
      {
        menu_window = win_paneterm;

        if (icon_handle==icon_paneterm_hifontbut)
          menu_icon = icon_paneterm_hifont;
        else
          menu_icon = icon_paneterm_lofont;

        menu_open = MENU_ZAPFONTLIST;
      }
      break;
  }
}


static void win_panecols_click(int x, int y, int buttons, int icon_handle)
{
  /* Not terribly optimal */
  if ((icon_handle>=icon_panecols_col0but  && icon_handle<=icon_panecols_col7but) ||
      (icon_handle>=icon_panecols_bold0but && icon_handle<=icon_panecols_bold7but))
  {
    /* open a ColourPicker window (as a menu) */
    static char title[64];
    struct colourpicker_block block;
    struct wimp_geticonstate_block icon;
    struct wimp_getwindowstate_block window;

    strcpy(title, "Select colour");

    window.window_handle = win_panecols;
    icon.window_handle = win_panecols;
    icon.icon_handle = icon_handle;
    _swi (Wimp_GetWindowState, _IN(1), &window);
    _swi (Wimp_GetIconState, _IN(1), &icon);

    block.flags = 0;
    block.title = title;
    block.bl.x = window.min.x + icon.max.x;
    block.bl.y = 0x80000000;
    block.tr.x = 0x7FFFFFFF;
    block.tr.y = window.max.y + icon.max.y;
    block.zero1 = block.zero0 = 0;
    block.colour = get_colour_icon(icon_handle-8, true);
    block.extsize = block.exttype = 0;
    colourpicker_handle = _swi (ColourPicker_OpenDialogue,
                          _INR(0,1) | _OUT(1), 1, &block, &menu_window);

    menu_icon = icon_handle-8; /* icon_handle-8 may change */
    menu_open = MENU_NONE;
  }

  if (icon_handle==icon_panecols_default)
  {
    int loop;
    for (loop=15; loop>=0; loop--)
    {
      set_colour_icon (loop, default_palette[loop], false);
    }
  }
}


static void win_panehot_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case icon_panehot_new:
      open_window_centred(win_hotedit);
      break;

    case icon_panehot_edit:
      if (0)/* if(something is selected) */
        open_window_centred(win_hotedit);
      break;

    case icon_panehot_delete:
      if (0)/* if(something is selected) */
      {
        if (generror_question(lookup_static("DeleteHot")))
        {
          /* delete it! */
        }
      }
      break;

  }
}

static void win_hotpane_click(int x, int y, int buttons, int icon_handle)
{
}

static void win_hotedit_click(int x, int y, int buttons, int icon_handle)
{
}

/** Button enumeration for a click/drag/double click icon */
enum
{
  ClickAdjust  = 0x001 * 256,
  ClickMenu    = 0x002 * 1,
  ClickSelect  = 0x004 * 256,
  DragAdjust   = 0x001 * 16,
  DragMenu     = 0x002 * 16,
  DragSelect   = 0x004 * 16,
  DoubleAdjust = 0x001 * 1,
  DoubleSelect = 0x004 * 1
};



/**
 * Set the caret to be in the given session
 *
 * (Either the window or line editor, if lineeditor is on)
 *
 * @param session   Session to place caret into
 */
static void wimp_claimcaret(struct session_struct *session)
{
  if (line_editor_active(session))
  {
    struct wimp_getcaretposition_block block;

    _swi(Wimp_GetCaretPosition, _IN(1), &block);

    if (session->line_editor_type==LINEEDIT_CHECKBOX)
    {
      if (block.window_handle!=session->pane_handle)
      {
        set_caret_position(session->pane_handle, 1, -1,
          get_icon_data_length(session->pane_handle, 1));
      }
    }
    else
    {
      if (block.window_handle!=session->window_handle)
      {
        set_caret_position(session->window_handle, -1, -1, -1);
      }
    }
  }
  else
  {
    /* no line editor, place in window */
    set_caret_position(session->window_handle,-1,-1,-1);
  }
}



static void wimp_launchurl(struct session_struct *session, int x, int y)
{
  int     x_pos;
  int     y_pos;
  char    url[1024];
  char   *urlptr;
  char   *urlend;
  int     char_offset;
  int     end_offset;

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    x_pos=block.min.x-block.scroll.x;
    y_pos=block.max.y-block.scroll.y;
  }

  char_offset = -( ( (y - y_pos) >> eig.y ) / redraw.r_charh )
                        * session->terminal_size.x
                        + ( ( (x - x_pos) >> eig.x ) / redraw.r_charw );
  end_offset = session->terminal_size.x*
                     (session->terminal_size.y + session->scrollback);

  logf("clicked on '%c'\n",session->assigned_area[char_offset*4+3]);

  if (isspace((int) session->assigned_area[char_offset*4+3]))
    return;

  /* go back to the start of the clicked on 'word' */
  while (char_offset > 0 && !isspace((int) session->assigned_area[char_offset*4+3]))
    char_offset--;
  if (!isalpha((int) session->assigned_area[char_offset*4+3]))
    char_offset++;

  /* go forward to the end of the form [ie. until we find whitespace] */
  urlptr = url;
  urlend = url + sizeof(url) - 8; /* leave space for a '\0', and 'http://' */
  while (char_offset < end_offset && urlptr < urlend &&
         !isspace((int) session->assigned_area[char_offset*4+3]))
  {
    *urlptr++ = session->assigned_area[char_offset*4+3];
    char_offset++;
  }
  *urlptr = '\0';
  logf("url = '%s'\n", url);

  /* we've got a url, check for full formedness */
  urlptr = url;
  while (isalpha((int) (*urlptr)))
    urlptr++;
  if (*urlptr != ':')
  {
    const char *scheme;
    /* there's no scheme section */
    if (strncmp(url, "ftp.", 4) == 0)
      scheme = "ftp://";
    else if (strchr(url, '@') != NULL)
      scheme = "mailto:";
    else
      scheme = "http://";

    /* prefix string we have with the scheme we've guessed */
    memmove(url + strlen(scheme), url, strlen(url) + 1);
    memcpy(url, scheme, strlen(scheme));
  }

  _swix(URI_Dispatch, _INR(0,2), 0, url, 0);
}



static void session_window_click(int x, int y, int buttons, int icon_handle, struct session_struct *session)
{
  int x_pos;
  int y_pos;
  struct wimp_getcaretposition_block caret;

  _swi (Wimp_GetCaretPosition, _IN(1), &caret);

  /* Darren wanted to add some code to not claim caret on CTRL-press - don't know why */

  /* if we're not pressing MENU */
  if (buttons != ClickMenu && buttons != DragMenu)
    wimp_claimcaret(session);

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    x_pos=block.min.x-block.scroll.x;
    y_pos=block.max.y-block.scroll.y;
  }

  switch (buttons)
  {
    case DragSelect:
      /* if SELECT drag, then clear the selection and work out what where the selection */
      /* start is */
      refresh_selection_clear();
      force_redraw_selection();

      selection_session = session;
      selection_start = -( ( (y - y_pos) >> eig.y ) / redraw.r_charh )
                        * session->terminal_size.x
                        + ( ( (x - x_pos) >> eig.x ) / redraw.r_charw );

      if (selection_start > (selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback)))
      {
	selection_start=(selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback));
      }

      if (selection_start<0)
      {
	selection_start=0;
      }

      selection_end=selection_start;
      selection_in_progress=true;
      break;

    case DragAdjust:
      /* if ADJUST drag, then if there is no selection, then start one */
      if (!selection_session)
      {
	refresh_selection_clear();
	force_redraw_selection();

	selection_session = session;
        selection_start = -( ( (y - y_pos) >> eig.y ) / redraw.r_charh )
                          * session->terminal_size.x
                          + ( ( (x - x_pos) >> eig.x ) / redraw.r_charw );

	if (selection_start>(selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback)))
	{
	  selection_start=(selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback));
	}

	if (selection_start<0)
	{
	  selection_start = 0;
	}

	selection_end=selection_start;
	selection_in_progress=true;
	selection_adjust_dragging=SELECTION_ADJUST_END;
      }
      else
      {
	selection_in_progress=true;
      }
      break;

    case DoubleSelect:
      wimp_launchurl(session, x, y);
      break;

    case ClickSelect:
      /* if SELECT click, then clear the selection if the caret is already in the window */
      if (selection_session &&
          (caret.window_handle == session->window_handle ||
           caret.window_handle == session->pane_handle))
      {
	refresh_selection_clear();
	force_redraw_selection();
	selection_session = NULL;
      }
      break;

    case ClickMenu: /* menu click */
      terminal_menu_session = session;
      create_terminal_menu();
      break;

    case ClickAdjust:
      /* if ADJUST click, then extend the selection */
      if (selection_session == session)
        selection_adjust(x,x_pos,y,y_pos);
      break;
  }
}



static void session_pane_click(int x, int y, int buttons, int icon_handle, struct session_struct *session)
{
  switch (icon_handle)
  {
    case 0:
      {
	struct wimp_geticonstate_block block;

	block.window_handle=session->pane_handle;
	block.icon_handle  =icon_handle;

	_swi(Wimp_GetIconState, _IN(1), &block);

	if (block.icon_flags & (1<<21))
	{
	  set_icon_state(session->pane_handle, 1, 0, 1<<23);
	  check_set_caret_position(session->pane_handle, 1);

	  {
	    struct wimp_getcaretposition_block caret_pos;

	    _swi(Wimp_GetCaretPosition, _IN(1), &caret_pos);

	    if (caret_pos.window_handle==session->window_handle)
	    {
	      set_caret_position(session->pane_handle, 1, -1,
		   get_icon_data_length(session->pane_handle, 1));
	    }
	  }
	}
	else
	{
	  set_icon_state(session->pane_handle, 1, 1<<23, 1<<23);

	  {
	    block.window_handle=session->pane_handle;
	    block.icon_handle  =1;

	    _swi(Wimp_GetIconState, _IN(1), &block);

	    force_redraw(session->pane_handle, block.min.x, block.min.y,
					       block.max.x, block.max.y);
	  }

	  {
	    struct wimp_getcaretposition_block caret_pos;

	    _swi(Wimp_GetCaretPosition, _IN(1), &caret_pos);

	    if (caret_pos.window_handle==session->pane_handle)
	    {
	      set_caret_position(session->window_handle,-1,-1,-1);
	    }
	  }
	}
      }
  }
}


static int win_iconbar = -2;
static struct { int *window; void (*handler)(int,int,int,int); } mousehandlers[] =
{
  {&win_iconbar, iconbar_click     },
  {&win_open,    win_open_click    },
  {&win_save,    win_save_click    },
  {&win_resize,  win_resize_click  },
  {&win_choices, win_choices_click },
  {&win_paneterm,win_paneterm_click},
  {&win_panecols,win_panecols_click},
  {&win_panehot, win_panehot_click },
  {&win_hotpane, win_hotpane_click },
  {&win_hotedit, win_hotedit_click },
  {NULL,NULL}
};

/* Mouse click */

void wimp_mouseclick(int x, int y, int buttons, int window_handle, int icon_handle)
{
  int i;
  for(i=0; mousehandlers[i].window; i++)
  {
    if (window_handle==*mousehandlers[i].window)
    {
      mousehandlers[i].handler(x, y, buttons, icon_handle);
      return;
    }
  }

  {
    struct session_struct *session = sessions;

    while (session)
    {
      if (window_handle == session->window_handle)
      {
        session_window_click(x,y,buttons,icon_handle,session);
	return;
      }
      else if (session->line_editor_type==LINEEDIT_CHECKBOX &&
               (window_handle == session->pane_handle))
      {
        session_pane_click(x,y,buttons,icon_handle,session);
	return;
      }

      session = session->next;
    }
  }
}



/* Drag finished */

void drag_finished(void)
{
  struct wimp_getpointerinfo_block gpi_block;
  union wimp_poll_block block;

  if (drag_window_handle==win_save)
  {
    char string[1024];
    int loop;

    read_icon_data(win_save, icon_save_filename, string, sizeof(string));
    loop = strlen(string);

    while (loop>=0 && string[loop]!='.' && string[loop]!=':')
    {
      loop--;
    }

    _swi(Wimp_GetPointerInfo, _IN(1), &gpi_block);

    block.user_message.contents.data_save.window_handle=gpi_block.window_handle;
    block.user_message.contents.data_save.icon_handle  =gpi_block.icon_handle;
    block.user_message.contents.data_save.pos.x        =gpi_block.pos.x;
    block.user_message.contents.data_save.pos.y        =gpi_block.pos.y;
    block.user_message.contents.data_save.size         =selection_end-selection_start;
    block.user_message.contents.data_save.filetype     =0xFFF;

    strcpy(block.user_message.contents.data_save.file_name, string+loop+1);

    block.user_message.length      =(48+strlen(string+loop+1)) & ~3;
    block.user_message.your_ref    =0;
    block.user_message.message_code=1; /* DataSave */

    _swi(Wimp_SendMessage, _INR(0,3), 17, &block,
                           block.user_message.contents.data_save.window_handle,
                           block.user_message.contents.data_save.icon_handle);
  }
}



/* Key pressed */

void key_pressed(int window_handle, int icon_handle, int key, int extra)
{
  int ekey = extra >> 16;
  bool key_status=false;
  char message[MESSAGE_MAX_CONNECTION];

  if (window_handle == win_open)
  {
    char string[MESSAGE_MAX_CONNECTION];
    int connection_type;

    read_icon_data(win_open, icon_open_contype, string, sizeof(string));

    if (strcmp(string, lookup("SSH", message, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_SSH;
    else if (strcmp(string,lookup("Taskwindow", message, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_TASKWINDOW;
    else
      connection_type=NETTLE_TELNET;

    switch (key)
    {
      case 13:
        switch (icon_handle)
        {
          case icon_open_host:
            switch (connection_type)
            {
              case NETTLE_TELNET:
                start_connection();
                break;
              case NETTLE_SSH:
                set_caret_position(win_open,icon_open_command,-1, get_icon_data_length(win_open, icon_open_command));
                break;
            }
            key_status=true;
            break;

          case icon_open_command:
            switch (connection_type)
            {
              case NETTLE_SSH: case NETTLE_TASKWINDOW:
                start_connection();
                break;
            }
            key_status=true;
            break;
        }
        break;

      case 27:
        close_window(win_open);
        break;
    }
  }
  else if (window_handle==win_resize)
  {
    switch (icon_handle)
    {
      case icon_open_contype:
        switch (key)
        {
          case 13:
            {
              struct coords new_size;
              int new_scrollback;

              if (read_termsize_icons(win_resize, icon_resize_width, icon_resize_height, icon_resize_scroll,\
                &new_size, &new_scrollback))
                resize_terminal(terminal_menu_session, new_size.x, new_size.y,
                                new_scrollback, true);

              _swi(Wimp_CreateMenu, _IN(1), -1);
            }
            key_status=true;
        }
        break;
    }
  }
  else if (colourpicker_handle && window_handle == menu_window)
  {
    /* Keypresses in the ColourPicker window have already been handled */
    key_status = true;
  }

  if (key_status==false)
  {
    {
      {
        struct session_struct *session = sessions;

        while (session && window_handle != session->window_handle)
        {
          session = session->next;
        }

        if (session)
        {
          if (session->socket_state==NETTLE_SESSION_CONNECTED)
          {
            if (pass_f12)
            {
              process_wimp_key(session, key, extra);
              key_status=true;
            }
            else
            {
              if (key!=0x1CC && key!=0x1DC && key!=0x1EC && key!=0x1FC)
              {
                process_wimp_key(session, key, extra);
                key_status=true;
              }
            }
          }
        }
      }
    }
  }

  if (key_status==false)
  {
    struct session_struct *session = sessions;
    int line_editor_icon;

    while (session && window_handle != session->pane_handle)
    {
      session = session->next;
    }

    if (session && session->line_editor_type!=LINEEDIT_NONE)
    {
      line_editor_icon=(session->line_editor_type==LINEEDIT_CHECKBOX ? 1 : 0);

      switch (key)
      {
        case 13:
          if (session->socket_state==NETTLE_SESSION_CONNECTED)
          {
            process_line_editor(session);
            key_status=true;
          }
          break;
        case 0x18E: /* Down, sPageDown */
          key_status=true;

          if (ekey == 54)
          {
            scroll_term(session, -1);
            break;
          }

          if (session->line_editor_position==0)
          {
            _swi(OS_WriteI + 7, 0);
          }
          session->line_editor_position--;

          if (session->line_editor_position<0)
          {
            session->line_editor_position=0;
          }

          {
            char icon_data[1024];

            set_icon_data(session->pane_handle, line_editor_icon,
                read_mem((char *)icon_data, session->line_editor_history +
                (session->line_editor_position * 512), sizeof(icon_data)));
          }

          set_caret_position(session->pane_handle, line_editor_icon, -1,
                             get_icon_data_length(session->pane_handle, line_editor_icon));

          break;
        case 0x18F: /* Up, sPageUp */
          key_status=true;

          if (ekey == 33)
          {
            scroll_term(session, 1);
            break;
          }

          if (session->line_editor_position==session->line_editor_total-1)
          {
            _swi(OS_WriteI + 7, 0);
          }
          session->line_editor_position++;

          if (session->line_editor_position>session->line_editor_total-1)
          {
            session->line_editor_position=session->line_editor_total-1;
          }

          {
            char icon_data[1024];

             set_icon_data(session->pane_handle,line_editor_icon,
                read_mem(icon_data, session->line_editor_history+
                 (session->line_editor_position * 512), sizeof(icon_data)));
          }

          set_caret_position(session->pane_handle, line_editor_icon, -1,
                             get_icon_data_length(session->pane_handle, line_editor_icon));

          break;
      }
    }
  }

  if (key_status==false)
  {
    _swi(Wimp_ProcessKey, _IN(0), key);
  }
}



/* Menu selection */

void wimp_menuchoice(int *selection)
{
  switch (menu_open)
  {
    case MENU_ICONBAR:
      switch (selection[0])
      {
        case 1:
          open_choices_window();
          break;

        case 2:
          /* Open connect window */
          open_open_window(true);
          break;

        case 3:
          /* Bring a session window to the front */
          if (selection[1] >= 0)
          {
            struct session_struct *session = get_termlist_entry(selection[1]);
            if (session)
              open_window(NULL, session->window_handle);
          }
          break;

        case 4:
          /* Quit */
          close_program();
      }
      break;

    case MENU_TERMINAL:
      switch (selection[0])
      {
        case 0: /* selection menu */
          switch (selection[1])
          {
            case 0: /* save selection */
              break;

            case 1: /* launch url */
              break;

            case 2: /* send */
              selection_paste();
              break;

            case 3:
              {
                /* Clear selection */
                refresh_selection_clear();
                force_redraw_selection();
                selection_session = NULL;
              }
              break;
          }
          break;
      }
      break;

    case MENU_CONNECTION:
      {
        char connection[MESSAGE_MAX_CONNECTION];

        switch (selection[0])
        {
          case 0:
            set_icon_data(win_open, 4, lookup("Telnet", connection, MESSAGE_MAX_CONNECTION));
            break;
          case 1:
            set_icon_data(win_open, 4, lookup("SSH",  connection, MESSAGE_MAX_CONNECTION));
            break;
          case 2:
            set_icon_data(win_open, 4, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION));
            break;
        }
        open_open_window(false);
      }
      break;

    case MENU_TERMINAL_TYPE:
      if (selection[0] != -1)
      {
        char string[6];
        sprintf(string, "Term%d", selection[0]);

        set_icon_data(menu_window, menu_icon, lookup_static (string));
      }
      break;

    case MENU_HOTLIST:
      {
        hotlistnode *hot = decode_hotlist_menu(selection[0]);

        char tmpbuf[100];
        char connection[MESSAGE_MAX_CONNECTION];

        if (!hot)
          return;

        switch(hot->type)
	{
	  case ht_telnet:
	    set_icon_data(win_open, 4, lookup("Telnet", connection, MESSAGE_MAX_CONNECTION));
	    if (hot->port!=23) sprintf(tmpbuf, "%s:%d", hot->host, hot->port);
	      else strcpy(tmpbuf, hot->host);
	    set_icon_data(win_open, 0, tmpbuf);
	    set_icon_data(win_open, 7, "");
	    break;
	  case ht_ssh:
	    set_icon_data(win_open, 4, lookup("SSH",  connection, MESSAGE_MAX_CONNECTION));
	    if (hot->port!=22) sprintf(tmpbuf, "%s:%d", hot->host, hot->port);
	      else strcpy(tmpbuf, hot->host);
	    set_icon_data(win_open, 0, tmpbuf);
	    set_icon_data(win_open, 7, hot->command);
	    break;
	  case ht_task:
	    set_icon_data(win_open, 4, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION));
	    set_icon_data(win_open, 0, "");
	    set_icon_data(win_open, 7, hot->command);
	    break;
	  case ht_invalid:
	    break;
	}

      }
      break;
    case MENU_LINEED_TYPE:
      if (selection[0] != -1)
      {
        char string[8];
        sprintf(string, "LineEd%d", selection[0]);
	set_icon_data(win_paneterm, icon_paneterm_lineedittype, lookup_static (string));
      }
      break;

    case MENU_ZAPFONTLIST:
      if (selection[0] != -1)
      {
	char string[256];
	if (read_zap_font_selection (selection, string, sizeof (string)))
	  set_icon_data (win_paneterm, menu_icon, string);
      }
  }

  {
    struct wimp_getpointerinfo_block block;

    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    /* If ADJUST, then re-open  menu where it was before */
    if (block.buttons==1)
    {
      switch (menu_open)
      {
        case MENU_ICONBAR:
          create_iconbar_menu();
          break;

        case MENU_TERMINAL:
          create_terminal_menu();
          break;

        case MENU_CONNECTION:
          create_connection_menu();
          break;

        case MENU_TERMINAL_TYPE:
          create_terminal_type_menu(menu_window, menu_icon, menu_icon);
          break;

        case MENU_HOTLIST:
          create_hotlist_menu();
          break;

	case MENU_LINEED_TYPE:
	  create_lineeditor_type_menu();
	  break;

	case MENU_ZAPFONTLIST:
	  reopen_zap_font_menu();
	  break;
      }
    }
  }
}



/* Lose caret */

void lose_caret(int window_handle)
{
  struct session_struct *session = sessions;
  int calc;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    struct wimp_getcaretposition_block block;

    _swi(Wimp_GetCaretPosition, _IN(1), &block);

    /* if lineeditor is off, or the caret isn't in the pane, then make the cursor look like */
    /* we have no input */
    if (!(line_editor_active(session)) || block.window_handle != session->pane_handle)
    {
      calc=get_cursor_position(session);
      write_assigned_flags(session, calc,
      			   read_assigned_flags(session, calc) | NETTLE_FLAG_NO_INPUT);
      cursor_session = NULL;

      force_redraw(session->window_handle,
      		   session->pos.x*redraw.r_charw << eig.x,
		   (-session->pos.y-1)*redraw.r_charh << eig.y,
		   (session->pos.x+1)*redraw.r_charw << eig.x,
		   (-session->pos.y)*redraw.r_charh << eig.y);
    }
    return;
  }

  session = sessions;

  while (session && window_handle != session->pane_handle)
  {
    session = session->next;
  }

  if (session)
  {
    /* if the caret is being lost from the pane, then deselect the cursor too */
    calc=get_cursor_position(session);
    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) | NETTLE_FLAG_NO_INPUT);
    cursor_session = NULL;

    force_redraw(session->window_handle,
    		 session->pos.x*redraw.r_charw << eig.x,
		 (-session->pos.y-1)*redraw.r_charh << eig.y,
		 (session->pos.x+1)*redraw.r_charw << eig.x,
		 (-session->pos.y)*redraw.r_charh << eig.y);
  }
}

static void set_cursor_session (const struct session_struct *session)
{
  if (cursor_blink)
  {
    cursor_session = session;
    nextcursortime = _swi (OS_ReadMonotonicTime, 0) + CURSOR_BLINK_DELAY;
    cursor_state = true;
  }
}


/* Gain caret */

void gain_caret(int window_handle)
{
  struct session_struct *session = sessions;
  int calc;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    /* if the handle is the window handle, get input back for the cursor */
    set_cursor_session (session);
    calc=get_cursor_position(session);

    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) & ~NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->pos.x*redraw.r_charw << eig.x,
		 (-session->pos.y-1)*redraw.r_charh << eig.y,
		 (session->pos.x+1)*redraw.r_charw << eig.x,
	         (-session->pos.y)*redraw.r_charh << eig.y);

    if (line_editor_active(session) && session->line_editor_type==LINEEDIT_CHECKBOX)
    {
      /* if line editor and doesn't already have caret, then set the caret in pane */
      struct wimp_getcaretposition_block block;

      _swi(Wimp_GetCaretPosition, _IN(1), &block);

      if (block.window_handle!=session->pane_handle)
      {
        set_caret_position(session->pane_handle,1,-1,
               		   get_icon_data_length(session->pane_handle,1));
      }
    }

    return;
  }

  session = sessions;

  while (session && window_handle != session->pane_handle)
  {
    session = session->next;
  }

  if (session)
  {
    set_cursor_session (session);
    calc=get_cursor_position(session);

    /* unset no input flag again */
    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) & ~NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->pos.x*redraw.r_charw << eig.x,
		 (-session->pos.y-1)*redraw.r_charh << eig.y,
		 (session->pos.x+1)*redraw.r_charw << eig.x,
	         (-session->pos.y)*redraw.r_charh << eig.y);

    {
      struct wimp_getcaretposition_block block;

      _swi(Wimp_GetCaretPosition, _IN(1), &block);

      /* again, set caret if it's not already in the pane */
      if (block.window_handle!=session->pane_handle &&
          session->line_editor_type==LINEEDIT_CHECKBOX)
      {
        set_caret_position(session->pane_handle,1,-1,
           		   get_icon_data_length(session->pane_handle,1));
      }
    }
  }
}



/* Wimp message */

void wimp_message(union wimp_poll_block *wimp_block)
{
  int message_number = wimp_block->user_message.message_code;
  int sender_ref     = wimp_block->user_message.sender_ref;
  int my_ref         = wimp_block->user_message.my_ref;

  switch (message_number)
  {
    case WIMP_MESSAGE_QUIT:
      quit_flag=true;
      break;

    case WIMP_MESSAGE_DATASAVEACK:
      {
        char string[1024];

        read_mem(string, wimp_block->user_message.contents.data_save_ack.file_name, sizeof(string));

        {
          struct wimp_geticonstate_block block;

          block.window_handle=drag_window_handle;
          block.icon_handle  =icon_save_ansi;

          _swi(Wimp_GetIconState, _IN(1), &block);

          if (block.icon_flags & (1<<21))
          {
            save_selection(string,true);
          }
          else
          {
            save_selection(string,false);
          }
        }

        if (instr(string,"Wimp$Scrap")==-1)
        {
          set_icon_data(drag_window_handle,icon_save_filename,string);
        }

        wimp_block->user_message.your_ref    =my_ref;
        wimp_block->user_message.message_code=3;

        _swi(Wimp_SendMessage, _INR(0,2), 17, wimp_block, sender_ref);

        _swi(Wimp_CreateMenu, _IN(1), -1);
      }
      break;

    case WIMP_MESSAGE_MODECHANGE:
      mode_change();
      break;

    case WIMP_MESSAGE_TASKWINDOW_OUTPUT:
      {
        struct session_struct *session = sessions;

        if (!session) {
          return;
        }

        while (session && session->socket_handle != sender_ref) {
          session = session->next;
        }

        if (session)
        {
          write_out_data(session,
                         wimp_block->user_message.contents.task_window_output.data,
                         wimp_block->user_message.contents.task_window_output.size);
        }
        wimp_block->user_message.my_ref=wimp_block->user_message.your_ref;

        _swi(Wimp_SendMessage, _INR(0,2), 19, wimp_block, sender_ref);
      }
      break;
    case WIMP_MESSAGE_TASKWINDOW_EGO:
      {
        struct session_struct *session = sessions;
        int txt_handle = wimp_block->user_message.contents.task_window_ego.txt_handle;

        while (session && session != (struct session_struct *) txt_handle) {
          session = session->next;
        }

        if (session)
        {
          session->socket_state = NETTLE_SESSION_CONNECTED;
          session->socket_handle = sender_ref;
          set_title_bar (session->window_handle, lookup_static ("title_open"));
        }
      }
      break;

    case WIMP_MESSAGE_TASKWINDOW_MORIO:
      {
        struct session_struct *session = sessions;

        if (!session)
          return;

        while (session && session->socket_handle != sender_ref)
        {
          session = session->next;
        }

        if (session)
        {
          set_title_bar (session->window_handle, lookup_static ("title_closed"));
          session->socket_state=NETTLE_SESSION_NONE;
          session->socket_handle=0;
          reset_terminal (session);
          write_out_strings (session, "\r\n", lookup_static ("twclosed"), "\r\n", 0);
        }
      }
      break;

    case WIMP_MESSAGE_MENUWARNING:
      switch (wimp_block->user_message.contents.menu_warning.submenu)
      {
        case MENU_TERMLIST:
          {
            const int *menublock=create_termlist_menu();
            if (menublock)
              _swi (Wimp_CreateSubMenu, _INR(1,3), menublock,
                    wimp_block->user_message.contents.menu_warning.pos.x,
                    wimp_block->user_message.contents.menu_warning.pos.y);
          }
          break;

        case MENU_ZAPFONTLIST:
          create_zap_font_submenu (wimp_block->user_message.contents.menu_warning.selection,
                                    wimp_block->user_message.contents.menu_warning.pos);
	  break;
      }
      break;

    case WIMP_MESSAGE_MENUSDELETED:
      switch (menu_open)
      {
	case MENU_ZAPFONTLIST:
	  delete_zap_font_menu ();
	  break;
      }
      menu_open = MENU_NONE;
      colourpicker_handle = 0;
      break;

    case COLOURPICKER_COLOUR_CHOICE:
      if (wimp_block->user_message.contents.colourpicker_choice.picker_handle == colourpicker_handle)
        set_colour_icon (menu_icon, wimp_block->user_message.contents.colourpicker_choice.colour, true);
      break;

    case COLOURPICKER_CLOSE_REQUEST:
      if (wimp_block->user_message.contents.colourpicker_close.picker_handle == colourpicker_handle)
      {
        _swi (ColourPicker_CloseDialogue, _INR(0,1), 0, colourpicker_handle);
        colourpicker_handle = 0;
      }
      break;
  }
}



void mode_change(void)
{
  int *zap_font_used;
  int mem_required;
  int a;
  int b;
  int old_charw;
  int old_charh;
  struct session_struct *session = sessions;

  eig.x = _swi (OS_ReadModeVariable, _INR (0,1) | _RETURN (2), -1, 4);
  eig.y = _swi (OS_ReadModeVariable, _INR (0,1) | _RETURN (2), -1, 5);

  old_charw=redraw.r_charw;
  old_charh=redraw.r_charh;

  /* work out which font we should be using */
  zap_font_used = (eig.y == 1) ? zap_font_area : zap_lowres_font_area;

  _swi(ZapRedraw_ReadVduVars, _IN(1), &redraw);

  mem_required=(zap_font_used[2]*zap_font_used[3]*384);

  switch (redraw.r_bpp)
  {
    case 0:mem_required/=8;break;
    case 1:mem_required/=4;break;
    case 2:mem_required/=2;break;
    case 4:mem_required*=2;break;
    case 5:mem_required*=4;break;
  }

  /* Reallocate the bitmaps area */
  if (dynamic_areas_available())
  {
    if (bitmaps_area_number==0)
    {
      char string[]="Nettle bitmaps area";

      _swi(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, mem_required, -1, 0x80,
                           (zap_font_used[2]*zap_font_used[3]*384*4),
                           0, -1, string, &bitmaps_area_number, &bitmaps_area);
    }
    else
    {
      int current_size;

      _swi(OS_DynamicArea, _INR(0,1)|_OUT(2), 2, bitmaps_area_number, &current_size);

      if (mem_required-current_size!=0)
      {
        _swi(OS_ChangeDynamicArea, _INR(0,1), bitmaps_area_number, mem_required-current_size);
      }
    }
  }
  else
  {
      bitmaps_area=realloc(bitmaps_area, mem_required); /* FIXME: Dangerous use of realloc() */
  }

  redraw.r_flags=0;
  redraw.r_charw=zap_font_used[2];
  redraw.r_charh=zap_font_used[3];
  redraw.r_caddr=bitmaps_area;

  _swi(ZapRedraw_CachedCharSize, _INR(0,3)|_OUTR(2,3),
                                 redraw.r_bpp, 0, redraw.r_charw, redraw.r_charh, &a, &b);

  redraw.r_cbpl=a;
  redraw.r_cbpc=b;
  redraw.r_linesp=0;

  _swi(ZapRedraw_ConvertBitmap, _INR(1,4), &redraw, zap_font_used[4], 0x11D,
                                ((char *) zap_font_used)+32);

  redraw.r_palette=zap_palette;

  _swi(ZapRedraw_CreatePalette, _INR(0,4), 2, &redraw, palette, zap_palette, 16);

  redraw.r_for=7;
  redraw.r_bac=0;

  /* Resize all of the terminals to fit the new font size */
  while (session)
  {
    reopen_and_size_window(session, session->terminal_size.x, session->terminal_size.y,
                           old_charw, old_charh);

    session = session->next;
  }
}


void lose_bitmaps(void)
{
  if (dynamic_areas_available())
  {
    if (bitmaps_area_number!=0)
    {
      _swi(OS_DynamicArea, _INR(0,1), 1, bitmaps_area_number);
    }
  }
  else
  {
    free(bitmaps_area);
  }
}

void lose_zapredraw_area(void)
{
  if (dynamic_areas_available())
  {
    if (zapredraw_area_number!=0)
    {
      _swi(OS_DynamicArea, _INR(0,1), 1, zapredraw_area_number);
    }
  }
  else
  {
    free(zapredraw_area);
  }
}

/* Other Wimp related code */

void generror(const char *string, bool is_message)
{
  char message[252];
  struct wimp_reporterror_block block;

  if (is_message)
    string = lookup(string, message, sizeof(message));

  block.errnum=255;

  strcpy(block.errmess, string);

  _swi(Wimp_ReportError, _INR(0,2), &block, 0, application_name);
}



static bool generror_question(const char *string)
{
  struct wimp_reporterror_block block;

  block.errnum=255;

  strcpy(block.errmess, string);

  return (bool) (_swi(Wimp_ReportError, _INR(0,2)|_RETURN(1), &block,
                                        (1<<1)+(1<<0), application_name) == 1);
}



void set_caret_position(int window_handle, int icon_handle, int flags, int string_index)
{
  struct session_struct *session = sessions;

  if (cursor_blink)
  {
    while (session)
    {
      if (window_handle == session->window_handle ||
          window_handle == session->pane_handle)
      {
        cursor_session = session;
        break;
      }
      session = session->next;
    }
  }

  _swi(Wimp_SetCaretPosition, _INR(0,5), window_handle, icon_handle, -1, -1, flags, string_index);
}

void check_set_caret_position (int window_handle, int icon_handle)
{
  /* Update the caret position if it's in the given icon. */
  struct wimp_getcaretposition_block caret_pos;

  _swi(Wimp_GetCaretPosition, _IN(1), &caret_pos);

  if (caret_pos.window_handle == window_handle &&
      caret_pos.icon_handle == icon_handle)
  {
    set_caret_position (window_handle, icon_handle, -1,
			get_icon_data_length (window_handle, icon_handle));
  }
}


void set_icon_state (int window_handle, int icon_handle, int eor, int clear)
{
  struct wimp_seticonstate_block icon_set;

  icon_set.window_handle = window_handle;
  icon_set.icon_handle	 = icon_handle;
  icon_set.eor		 = eor;
  icon_set.clear	 = clear;

  _swi (Wimp_SetIconState, _IN(1), &icon_set);
}


void set_icon_data(int window_handle, int icon_handle, const char *contents)
{
  struct wimp_geticonstate_block block;

  block.window_handle=window_handle;
  block.icon_handle  =icon_handle;

  _swi(Wimp_GetIconState, _IN(1), &block);

  if (block.icon_flags & WIMP_ICON_INDIRECTED_BIT)
  {
    if (strcmp(block.contents.it.text, contents) != 0)
    {
      strcpy(block.contents.it.text, contents);

      set_icon_state(window_handle, icon_handle, 0, 0);
      check_set_caret_position(window_handle, icon_handle);
    }
  }
  else
  {
    char string[6];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
}



char *read_icon_data(int window_handle, int icon_handle, char *buffer, int buf_len)
{
  struct wimp_geticonstate_block block;

  block.window_handle = window_handle;
  block.icon_handle   = icon_handle;

  _swi(Wimp_GetIconState, _IN(1), &block);

  if (block.icon_flags & WIMP_ICON_INDIRECTED_BIT)
  {
    read_mem(buffer, block.contents.it.text, buf_len);
  }
  else
  {
    int len = (buf_len > 12) ? 12 : (buf_len - 1);
    assert (len >= 0);
    memcpy (buffer, block.contents.t.text, len);
    buffer[len] = '\0';
    while (--len >= 0)
      if (buffer[len] < 32)
        buffer[len] = '\0';
  }
  return buffer;
}



static int get_icon_data_length(int window_handle, int icon_handle)
{
  struct wimp_geticonstate_block block;
  int length = 0;

  block.window_handle = window_handle;
  block.icon_handle   = icon_handle;

  _swi(Wimp_GetIconState, _IN(1), &block);

  if (block.icon_flags & WIMP_ICON_INDIRECTED_BIT)
  {
    char *data = block.contents.it.text;

    while (*data != '\0' && *data != '\x0d' && *data != '\x0a') {
      length++;
      data++;
    }
  }
  else
  {
    char string[64];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
  return length;
}


static char *get_icon_validation (int window_handle, int icon_handle)
{
  struct wimp_geticonstate_block block;

  block.window_handle = window_handle;
  block.icon_handle = icon_handle;
  _swi (Wimp_GetIconState, _IN(1), &block);

  if ((block.icon_flags & WIMP_ICON_INDIRECTED_BIT) == 0)
  {
    char string[64];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
    return 0;
  }

  if ((block.icon_flags & WIMP_ICON_TEXT_BIT) == 0 ||
      block.contents.it.validation == 0 ||
      block.contents.it.validation == (char *)-1)
  {
    char string[64];
    sprintf(string,"Icon %d in window %X has no validation string.",icon_handle,window_handle);
    generror(string, false);
    return 0;
  }

  return block.contents.it.validation;
}



/* Create menu code */

static int *create_menu(int *menu_defn, char *indirected, char *title, char *entries, ... )
{
  va_list args;
  int window_handle;
  char *item;
  bool last_item=false;
  int position=7;
  char *pos;
  int menu_flags = 0;

  if (strlen(title)<12)
  {
    strcpy((char *)menu_defn, title);
  }
  else
  {
    int length = strlen (title);

    assert (indirected);

    strcpy (indirected, title);
    menu_defn[0] = (int) indirected;
    menu_defn[1] = (int) indirected + length;
    menu_defn[2] = length + 1;
    indirected += length + 1;

    menu_flags = 1 << 8;	/* indirected menu title */
  }

  menu_defn[3]=(7<<0)+(2<<8)+(7<<16)+(0<<24); /* black on white items, black on grey title text */
  menu_defn[4]=0;
  menu_defn[5]=44;
  menu_defn[6]=0;

  va_start(args, entries);

  item=entries;

  while (!last_item)
  {
    int icon_flags = WIMP_ICON_FGCOL(7) | WIMP_ICON_VCENT_BIT |
		     WIMP_ICON_FILLED_BIT | WIMP_ICON_TEXT_BIT;
    /* menu_flags is reset at the *end* of the loop -
     * first time round, there may be an 'indirected title' flag */

    window_handle=-1;
    {
      menu_defn[position]=0;
      item--;
      for (;;)
      {
        switch (*++item)
        {
          case '#':
            icon_flags |= WIMP_ICON_SHADED_BIT;
            continue; /* the for loop */
          case '.':
            menu_flags |= 1 << 1; /* dotted line follows */
            continue;
          case '/':
            menu_flags |= 1 << 0; /* ticked */
            continue;
          case '[':
            menu_flags |= 1 << 3; /* submenu => menu warning message */
            continue;
        }
        break; /* didn't match anything - exit the loop */
      }
    }

    pos=item+strlen(item);
    for (;;)
    {
      switch (*--pos)
      {
        case '>':
          window_handle=va_arg(args,int);
          continue;
        case '\\':
          last_item=true;
          menu_flags |= 1 << 7;
          continue;
      }
      break;
    }

    menu_defn[position++] = menu_flags;
    menu_defn[position++] = window_handle;

    if (strlen(item)<13)
    {
      menu_defn[position++] = icon_flags;

      strncpy(((char *) menu_defn)+(position*4),item,pos-item+1);

      {
        char *menu_data_char=(char *) menu_defn;
        menu_data_char[(position*4)+pos-item+1]='\0';
      }

      position+=3;
    }
    else
    {
      int length = pos - item + 1;

      menu_defn[position++] = icon_flags | WIMP_ICON_INDIRECTED_BIT;

      assert(indirected);

      strncpy(indirected, item, length);
      indirected[length]='\0';
      menu_defn[position++]=(int) indirected;
      menu_defn[position++]=(int) indirected+length;
      menu_defn[position++]=length+1;
      indirected+=length+1;
    }

    item=va_arg(args,char *);

    menu_flags=0;
  }

  va_end(args);

  return menu_defn;
}



static char *get_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 1);

  assert(item != NULL);

  return strcpy(item, value);
}



static char *get_last_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 2);

  assert(item != NULL);

  strcpy(item, value);
  return strcat(item, "\\");
}



static char *get_grey_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 2);

  assert(item != NULL);

  item[0] = '#';
  item[1] = '\0';
  return strcat(item, value);
}



static char *get_grey_last_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, 20);
  char *item = malloc(strlen(value) + 3);

  assert(item != NULL);

  item[0] = '#';
  strcpy(item + 1, value);
  strcat(item,"\\");
  return item;
}



static void create_iconbar_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title   = get_menu_item("AppName");
  char *menu_info    = get_menu_item("Info");
  char *menu_choices = get_menu_item("Choices");
  char *menu_connect = get_menu_item("Connect");
  char *menu_session;
  char *menu_quit    = get_last_menu_item("Quit");

  if (sessions)
    menu_session = get_menu_item("Session]");
  else
    menu_session = get_grey_menu_item("Session]");

  if (create_menu(menu_data, 0, menu_title,
                  menu_info, win_info,
                  menu_choices,
                  menu_connect,
                  menu_session, MENU_TERMLIST,
                  menu_quit))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    _swi(Wimp_CreateMenu, _INR(1,3), menu_data,
                                     block.pos.x-64, 96+24 + (5*44) );
  }

  free(menu_title);
  free(menu_info);
  free(menu_choices);
  free(menu_connect);
  free(menu_session);
  free(menu_quit);

  menu_open=MENU_ICONBAR;
}



static void create_terminal_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title          =get_menu_item("Terminal");
  char *menu_selection;
  char *menu_resize         =get_menu_item("Resize");
  char *menu_options        =get_grey_last_menu_item("Options");
  char *menu_selection_title=get_menu_item("Selection");
  char *menu_save	    =get_menu_item("Save");
  char *menu_launch_url     =get_grey_menu_item("LaunchURL");
  char *menu_send           =get_menu_item("Send");
  char *menu_clear          =get_last_menu_item("Clear");

  set_termsize_icons(win_resize, icon_resize_width, icon_resize_height, icon_resize_scroll,\
          terminal_menu_session->terminal_size, terminal_menu_session->scrollback);

  if (!selection_session || (selection_start==selection_end))
  {
    menu_selection=get_grey_menu_item("Selection>");
  }
  else
  {
    menu_selection=get_menu_item("Selection>");
  }

  if (create_menu(menu_data, 0, menu_title, menu_selection, menu_data2, menu_resize, win_resize,
    		  menu_options))
  {
    if (create_menu(menu_data2, 0, menu_selection_title, menu_save, win_save, menu_launch_url,
                    menu_send, menu_clear))
    {
      _swi(Wimp_GetPointerInfo, _IN(1), &block);

      _swi(Wimp_CreateMenu, _INR(1,3), menu_data, block.pos.x-64, block.pos.y);
    }
  }

  free(menu_title);
  free(menu_selection);
  free(menu_resize);
  free(menu_options);
  free(menu_selection_title);
  free(menu_save);
  free(menu_launch_url);
  free(menu_send);
  free(menu_clear);

  menu_open=MENU_TERMINAL;
}



static void create_connection_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title     =get_menu_item("Connection");
  char *menu_telnet    =get_menu_item("Telnet");
  char *menu_ssh       =get_grey_menu_item("SSH");
  char *menu_taskwindow=get_last_menu_item("Taskwindow");

  if (create_menu(menu_data,0,menu_title,menu_telnet,menu_ssh,menu_taskwindow))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    create_menu_by_icon (menu_data, win_open, icon_open_contypebut);
  }

  free(menu_title);
  free(menu_telnet);
  free(menu_ssh);
  free(menu_taskwindow);

  menu_open=MENU_CONNECTION;
}



static void create_terminal_type_menu(int window_handle, int text_icon, int by_icon)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title     =get_menu_item("Terminal");
  char *menu_term0     =get_menu_item("Term0");
  char *menu_term1     =get_menu_item("Term1");
  char *menu_term2     =get_menu_item("Term2");
  char *menu_term3     =get_grey_menu_item("Term3");
  char *menu_term4     =get_grey_menu_item("Term4");
  char *menu_term5     =get_grey_menu_item("Term5");
  char *menu_term6     =get_grey_menu_item("Term6");
  char *menu_term7     =get_menu_item("Term7");
  char *menu_term8     =get_last_menu_item("Term8");

  if (create_menu(menu_data,0,menu_title,menu_term0,menu_term1,menu_term2,menu_term3,
    		  menu_term4,menu_term5,menu_term6,menu_term7,menu_term8))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    create_menu_by_icon (menu_data, window_handle, by_icon);
  }

  free(menu_title);
  free(menu_term0);
  free(menu_term1);
  free(menu_term2);
  free(menu_term3);
  free(menu_term4);
  free(menu_term5);
  free(menu_term6);
  free(menu_term7);
  free(menu_term8);

  menu_open=MENU_TERMINAL_TYPE;
  menu_window = window_handle;
  menu_icon = text_icon;
}



static void create_lineeditor_type_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title = get_menu_item("LineEd");
  char *menu_line0 = get_menu_item("LineEd0");
  char *menu_line1 = get_menu_item("LineEd1");
  char *menu_line2 = get_last_menu_item("LineEd2");

  if (create_menu (menu_data, 0, menu_title, menu_line0, menu_line1, menu_line2))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    create_menu_by_icon (menu_data, win_paneterm, 17);
  }

  free (menu_title);
  free (menu_line0);
  free (menu_line1);
  free (menu_line2);

  menu_open=MENU_LINEED_TYPE;
}



/* Set title bar code */
void set_title_bar(int window_handle, const char *title)
{
  struct wimp_getwindowinfo_block block;

  block.window_handle=window_handle;

  _swi(Wimp_GetWindowInfo, _IN(1), ((int) &block)+1);

  if (block.icon_flags & (1<<8))
  {
    if (strcmp(block.title.it.text, title) != 0)
    {
      strcpy(block.title.it.text, title);

      _swi(Wimp_ForceRedraw, _INR(0,2), window_handle, 0x4B534154, 3);
    }
  }
  else
  {
    generror("Title bar in window is not indirected.", false);
  }
}



/* Force redraw code */
void force_redraw(int window_handle, int minx, int miny, int maxx, int maxy)
{
  _swi(Wimp_ForceRedraw, _INR(0,4), window_handle, minx, miny, maxx, maxy);
}



static void drag_start(int window_handle, int icon_handle)
{
  int xstart, ystart, xsize, ysize;
  char string[256];

  drag_window_handle=window_handle;
  drag_icon_handle=icon_handle;

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=window_handle;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    xstart=block.min.x-block.scroll.x;
    ystart=block.max.y-block.scroll.y;
  }

  xsize=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 11);
  ysize=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 12);

  xsize <<= eig.x;
  ysize <<= eig.y;

  {
    struct wimp_geticonstate_block gis_block;
    struct wimp_dragbox_block block;

    gis_block.window_handle=window_handle;
    gis_block.icon_handle  =icon_handle;

    _swi(Wimp_GetIconState, _IN(1), &gis_block);

    block.window_handle=window_handle;
    block.drag_type    =5;
    block.min.x         =gis_block.min.x+xstart;
    block.min.y         =gis_block.min.y+ystart;
    block.max.x         =gis_block.max.x+xstart;
    block.max.y         =gis_block.max.y+ystart;
    block.parent_min.x =0;
    block.parent_min.y =0;
    block.parent_max.x =xsize;
    block.parent_max.y =ysize;

    read_icon_data(window_handle, icon_handle, string, sizeof(string));

    if (_swi(OS_Byte, _INR(0,1)|_RETURN(2), 161, 28) & (1<<1))
    {
      _swi(DragASprite_Start, _INR(0,4), 0xc5, 1, string, &block.min.x, 0);
    }
    else
    {
      _swi(Wimp_DragBox, _IN(1), &block);
    }
  }
}



static void open_open_window(bool open_window_flag)
{
  char string[MESSAGE_MAX_CONNECTION];
  int connection_type;

  set_icon_data(win_open, icon_open_termtype, terminal_name[default_terminal]);

  read_icon_data(win_open, icon_open_contype, string, MESSAGE_MAX_CONNECTION);

  {
    char type[MESSAGE_MAX_CONNECTION];

    if (strcmp(string, lookup("SSH", type, MESSAGE_MAX_CONNECTION)) == 0)
      connection_type = NETTLE_SSH;
    else if (strcmp(string, lookup("Taskwindow", type, MESSAGE_MAX_CONNECTION)) == 0)
      connection_type = NETTLE_TASKWINDOW;
    else
      connection_type = NETTLE_TELNET;
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
       /* unshade the host icons, shade the command icons */
       set_icon_state (win_open, icon_open_host, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, icon_open_hostbut, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, icon_open_command, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, icon_open_commandbut, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
       break;

    case NETTLE_SSH:
       /* unshade the host and command icons */
       set_icon_state (win_open, icon_open_host, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, icon_open_hostbut, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, icon_open_command, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, icon_open_commandbut, 0, WIMP_ICON_SHADED_BIT);
       break;

    case NETTLE_TASKWINDOW:
      /* shade the host icons, unshade the command icons */
      set_icon_state (win_open, icon_open_host, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
      set_icon_state (win_open, icon_open_hostbut, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
      set_icon_state (win_open, icon_open_command, 0, WIMP_ICON_SHADED_BIT);
      set_icon_state (win_open, icon_open_commandbut, 0, WIMP_ICON_SHADED_BIT);
      break;
  }

  if (open_window_flag)
  {
    struct wimp_getwindowstate_block window;

    window.window_handle = win_open;
    _swi(Wimp_GetWindowState, _IN(1), &window);

    window.handle_behind = -1;  /* Open on top of stack */

    if ((window.window_flags & (1 << 16)) == 0)
    {
      /* window is not open, open it centred on the pointer taking care to
       * not obscure the icon bar */
      struct wimp_getpointerinfo_block pointer;
      int width = window.max.x - window.min.x;
      int height = window.max.y - window.min.y;

      _swi(Wimp_GetPointerInfo, _IN(1), &pointer);

      window.min.x = pointer.pos.x - width / 2;
      window.min.y = pointer.pos.y - height / 2;

      /* '134 + 2' is a cheap approximation of the height of the icon bar */
      if (window.min.y < 134 + 2)
        window.min.y = 134 + 2;

      window.max.x = window.min.x + width;
      window.max.y = window.min.y + height;
    }
    _swi(Wimp_OpenWindow, _IN(1), &window);
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
    case NETTLE_SSH:
      set_caret_position(win_open, icon_open_host, -1, get_icon_data_length(win_open, 0));
      break;

    case NETTLE_TASKWINDOW:
      set_caret_position(win_open, icon_open_command, -1, get_icon_data_length(win_open, 7));
      break;
  }
}



static void open_choices_window(void)
{
  char string[32];

  /* Select paneterm */
  set_icon_state(win_choices, icon_choices_size, WIMP_ICON_SELECTED_BIT, WIMP_ICON_SELECTED_BIT);
  set_icon_state(win_choices, icon_choices_colour, 0, WIMP_ICON_SELECTED_BIT);
  set_icon_state(win_choices, icon_choices_hotlist, 0, WIMP_ICON_SELECTED_BIT);

  /* Set paneterm type options */

  set_icon_data(win_paneterm, icon_paneterm_termtype, terminal_name[default_terminal]);
  set_termsize_icons(win_paneterm, icon_paneterm_termwidth, icon_paneterm_termheight, icon_paneterm_scrollback, defaultsize, defaultscroll);
  sprintf(string, "%d", line_editor_size);
  set_icon_data(win_paneterm, icon_paneterm_lineeditor, string);

  {
    char string_lineedit[32];

    sprintf(string_lineedit,"LineEd%d",line_editor);
    set_icon_data(win_paneterm, icon_paneterm_lineedittype, lookup(string_lineedit, string, sizeof(string)));
  }

  /* Set panecol type options */
  {
    int loop;

    for (loop = 15; loop >= 0; --loop)
      set_colour_icon (loop, palette[loop], false);
  }

  /* Set panehot type options */

  set_icon_data(win_paneterm, icon_paneterm_hifont, zap_font);
  set_icon_data(win_paneterm, icon_paneterm_lofont, zap_lowres_font);

  if (win_is_open(win_choices))
    open_window(NULL, win_choices);
  else
  {
    open_window_centred(win_choices);
    set_caret_position(win_paneterm, icon_paneterm_termwidth, -1, get_icon_data_length(win_paneterm, icon_paneterm_termwidth));
  }
}

static bool win_choices_read(int save)
{
  struct coords new_termsize;
  int new_scrollback;
  int new_line_editor_size;
  enum nettle_terminal new_default_terminal;
  char new_zap_font[256];
  char new_zap_lowres_font[256];
  char string[32];

  /* Read paneterm type options */
  {
    char terminal_type_string[32];
    int counter=0;

    strcpy(terminal_type_string, read_icon_data(win_paneterm, icon_paneterm_termtype, string, sizeof(string)));

    while (counter<NO_OF_TERMINAL_TYPES &&
           strcmp(terminal_type_string, terminal_name[counter]))
    {
      counter++;
    }

    if (counter!=NO_OF_TERMINAL_TYPES)
    {
      new_default_terminal=(enum nettle_terminal) counter;
    }
    else
    {
      generror("BadTermType", true);
      return false;
    }
  }

  if (!read_termsize_icons (win_paneterm, icon_paneterm_termwidth, icon_paneterm_termheight, icon_paneterm_scrollback,
			    &new_termsize, &new_scrollback))
    return false;

  new_line_editor_size = atoi (read_icon_data (win_paneterm, icon_paneterm_lineeditor, string, sizeof (string)));


  if (new_line_editor_size < 1 || new_line_editor_size > MAX_LINE_EDITOR_SIZE)
  {
    generror ("BadLineEdSize", true);
    return false;
  }

  strcpy(new_zap_font, read_icon_data(win_paneterm, icon_paneterm_hifont, string, sizeof(string)));
  strcpy(new_zap_lowres_font, read_icon_data(win_paneterm, icon_paneterm_lofont, string, sizeof(string)));


  /* Read panecols type options */
  {
    int loop;
    for (loop=15; loop>=0; loop--)
    {
      palette[loop] = get_colour_icon(loop, false);
    }

  }

  /* Read panehot type options */


  /* make the choices in the new_* variables permanent */
  default_terminal = new_default_terminal;
  defaultsize = new_termsize;
  defaultscroll = new_scrollback;

  /* Set new palette */
  _swi(ZapRedraw_CreatePalette, _INR(0,4), 2, &redraw, palette, zap_palette, 16);

  /* Load in new zap fonts */
  if (strcmp(zap_font, new_zap_font)!=0)
  {
    free(zap_font_area);
    strcpy(zap_font, new_zap_font);
    zap_font_area=load_font(zap_font);
  }

  if (strcmp(zap_lowres_font, new_zap_lowres_font)!=0)
  {
    free(zap_lowres_font_area);
    strcpy(zap_lowres_font, new_zap_lowres_font);
    zap_lowres_font_area=load_font(zap_lowres_font);
  }

  mode_change();

  /* if we're saving, save now */
  return save ? save_choices () : true;
}

static void set_colour_icon(int colour_handle, colour_t colour, bool is_an_icon)
{
  int icon_handle=-1;
  char *validation;

  if (is_an_icon)
  {
    icon_handle=colour_handle;
  }
  else
  {
    if (colour_handle>=0 && colour_handle<=7)
      icon_handle=colour_handle;

    if (colour_handle>=8 && colour_handle<=15)
      icon_handle=colour_handle-8+icon_panecols_bold0;
  }

  if (icon_handle==-1)
  {
    char string[64];

    sprintf(string,"Failed to set icon handle for set_colour_icon (colour_handle %d)",colour_handle);
    generror(string,false);
    return;
  }

  validation = get_icon_validation(win_panecols, icon_handle);

  sprintf(validation, "R2;C/%06X", ((unsigned int) colour) >> 8);

  set_icon_state (win_panecols, icon_handle, 0, 0);
}

static colour_t get_colour_icon(int colour_handle, bool is_an_icon)
{
  int icon_handle=-1;
  const char *validation;
  colour_t colour;

  if (is_an_icon)
  {
    icon_handle=colour_handle;
  }
  else
  {
    if (colour_handle>=0 && colour_handle<=7)
      icon_handle=colour_handle;

    if (colour_handle>=8 && colour_handle<=15)
      icon_handle=colour_handle-8+icon_panecols_bold0;
  }

  if (icon_handle==-1)
  {
    generror("Failed to set icon handle for get_colour_icon",false);
    return (colour_t) 0;
  }

  validation = get_icon_validation (win_panecols, icon_handle);

  colour = strtoul(validation + 5, NULL, 16);
  return (colour << 8);
}

void create_menu_by_icon (int *menu, int window, int icon)
{
  /* open the menu in the proper place next to a menu icon */
  struct wimp_geticonstate_block gisblock;
  struct wimp_getwindowstate_block gwsblock;

  gisblock.window_handle = window;
  gisblock.icon_handle = icon;
  _swi (Wimp_GetIconState, _IN(1), (int) &gisblock);

  gwsblock.window_handle = window;
  _swi (Wimp_GetWindowState, _IN(1), (int) &gwsblock);

  _swi(Wimp_CreateMenu, _INR(1,3), menu,
       gwsblock.min.x + gwsblock.scroll.x + gisblock.max.x,
       gwsblock.max.y + gwsblock.scroll.y + gisblock.max.y);
}

void set_termsize_icons (int window_handle, int xicon, int yicon, int sicon,
			 struct coords size, int scrollback)
{
  char string[8];
  struct wimp_getcaretposition_block block;

  sprintf (string, "%d", size.x);
  set_icon_data (window_handle, xicon, string);

  sprintf (string, "%d", size.y);
  set_icon_data (window_handle, yicon, string);

  sprintf (string, "%d", scrollback);
  set_icon_data (window_handle, sicon, string);

  _swi(Wimp_GetCaretPosition, _IN(1), &block);

  if (block.window_handle == window_handle &&
      (block.icon_handle == xicon ||
       block.icon_handle == yicon ||
       block.icon_handle == sicon))
  {
    set_caret_position (window_handle, block.icon_handle, -1,
			get_icon_data_length (window_handle, block.icon_handle));
  }
}


bool read_termsize_icons (int window_handle, int xicon, int yicon, int sicon,
			  struct coords *size, int *scrollback)
{
  char string[8];
  struct coords tmpsize;
  int tmpscroll;

  tmpsize.x = atoi (read_icon_data (window_handle, xicon, string, sizeof (string)));
  tmpsize.y = atoi (read_icon_data (window_handle, yicon, string, sizeof (string)));
  tmpscroll = atoi (read_icon_data (window_handle, sicon, string, sizeof (string)));

  if (tmpsize.x < MIN_TERMINAL_WIDTH || tmpsize.x > MAX_TERMINAL_WIDTH ||
      tmpsize.y < MIN_TERMINAL_HEIGHT || tmpsize.y > MAX_TERMINAL_HEIGHT ||
      tmpscroll < 0 || tmpscroll > MAX_SCROLLBACK_SIZE)
  {
    generror ("BadTermSize", true);
    return false;
  }

  *size = tmpsize;
  *scrollback = tmpscroll;
  return true;
}

int read_lineeditor_type (int window_handle, int icon_handle)
{
  char string[32]; /* overkill */
  char token[] = "LineEd0";
  int loop;

  read_icon_data (window_handle, icon_handle, string, sizeof (string));
  for (loop = 0; loop < LINEEDIT_NUM_TYPES; loop++)
  {
    token[6] = '0' + loop;
    if (! strcmp (string, lookup_static (token)))
      return loop;
  }
  return LINEEDIT_NONE;
}

enum nettle_terminal read_terminal_type (int window_handle, int icon_handle)
{
  char string[32];
  int loop = 0;

  read_icon_data (window_handle, icon_handle, string, sizeof(string));

  while (loop < NO_OF_TERMINAL_TYPES)
  {
    if (! strcmp(string, terminal_name[loop]))
      return (enum nettle_terminal) loop;

    loop++;
  }

  return default_terminal;
}
