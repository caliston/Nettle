/**
 * Wimp_Poll / Wimp code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "lineedit.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "socket.h"
#include "wimp.h"
#include "zapredraw.h"

/* Null code */

void null_reason_code(void)
{
  if (!sessions) { return; }

  if (!current_session) {
    current_session = sessions;
  }

  if (current_session->connection_type == NETTLE_TELNET)
  {
    switch (current_session->socket_state)
    {
      case NETTLE_SESSION_RESOLVE:
        switch(socket_resolvehost(current_session->socket_host,
                                  &current_session->socket_ip))
        {
          case RESOLVER_INPROGRESS:
            /* not finished yet */
            break;
          case RESOLVER_FAILED:
            set_title_bar(current_session->window_handle,"nettle (Disconnected)");
            write_out_string(current_session, "nettle: Failed to resolve remote host\r\n");
            current_session->socket_state=NETTLE_SESSION_NONE;
            break;
          case RESOLVER_SUCCESS:
            current_session->socket_handle=
                            socket_connecttoip(current_session->socket_ip,
                                               current_session->socket_port);

            if (current_session->socket_handle!=-1)
            {
              current_session->socket_state = NETTLE_SESSION_CONNECT;
              write_out_string(current_session, "nettle: Connecting to ");
              write_out_string(current_session, socket_ip_string(current_session->socket_ip));
              write_out_string(current_session, "...\r\n");
            }
            else
            {
              write_out_string(current_session,"nettle: Failed to create socket\r\n");
              current_session->socket_state=NETTLE_SESSION_NONE;
            }
        }
        break;
      case NETTLE_SESSION_CONNECT:
        switch (socket_connected(current_session->socket_handle))
        {
          case -6:
            set_title_bar(current_session->window_handle,"nettle (Connection refused)");
            write_out_string(current_session,"nettle: Connection refused\r\n");
            socket_close(current_session->socket_handle);

            current_session->socket_handle=0;
            current_session->socket_state=NETTLE_SESSION_NONE;
            break;
          case 4:
            {
              char string[1024];

              sprintf(string,"nettle/%s (%s,%d)",
                      terminal_name[current_session->terminal_type],
                      current_session->socket_host,
                      current_session->socket_port);

              set_title_bar(current_session->window_handle,string);

              current_session->socket_state = NETTLE_SESSION_CONNECTED;
              write_out_string(current_session, "nettle: Connected to ");
              write_out_string(current_session, socket_ip_string(current_session->socket_ip));
              write_out_string(current_session, "\r\n");
              break;
           }
        }
        break;
      case NETTLE_SESSION_CONNECTED:
        {
          int packet_length;
          char receive_block[RECEIVE_BLOCK_LENGTH];

          packet_length=socket_readdata(current_session->socket_handle,receive_block,
                                        RECEIVE_BLOCK_LENGTH);

          if (packet_length>0)
          {
            /* deal with data from socket */
            write_out_data(current_session,receive_block,packet_length);
          }
          else
          {
            if (packet_length==-1)
            {
              set_title_bar(current_session->window_handle,"nettle (Disconnected)");
              write_out_string(current_session,"\r\nnettle: Remote has closed connection\r\n");
              write_out_string(current_session,"nettle: Disconnected\r\n");
              socket_close(current_session->socket_handle);
              current_session->socket_handle=0;
              current_session->socket_state=NETTLE_SESSION_NONE;
            }
          }
        }
        break;
    }
  }

  current_session = current_session->next;
  if (!current_session) {
    current_session = sessions;
  }

  close_log();

  if (selection_in_progress)
    handle_selection_drag();
}

/* Redraw window */

void redraw_window(int window_handle)
{
  struct session_struct *session = sessions;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    zapgen_code(zapredraw_area,
                session->assigned_area,
                session->terminal_size_x,
                session->terminal_size_y + session->scrollback,
                session->other_session_flags);

    redraw.r_data = zapredraw_area;

    _swi(ZapRedraw_RedrawWindow, _INR(0,1), &wimp_block, &redraw);
  }
  else
  {
    int more;

    more = _swi(Wimp_RedrawWindow, _IN(1)|_RETURN(0), &wimp_block);
    while (more)
      more = _swi(Wimp_GetRectangle, _IN(1)|_RETURN(0), &wimp_block);
  }
}

/* Open window */

void open_window(int window_handle, bool poll_flag)
{
  struct wimp_openwindow_block block;
  struct session_struct *session = sessions;

  /* find out which session this window is */

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  switch (poll_flag)
  {
    case true:
      if (session)
      {
        if (line_editor)
        {
          /* open the pane window and set the 'behind' word to behind the pane */
          open_pane_window(session, (struct wimp_openwindow_block *) &wimp_block);
          wimp_block.open_window.handle_behind = session->pane_handle;
        }
      }
      break;
    default:
      block.window_handle = window_handle;

      _swi(Wimp_GetWindowState, _IN(1), &block);

      block.handle_behind = -1;
      if (session)
      {
        if (line_editor)
        {
          /* open the pane window and set the 'behind' word to behind the pane */
          open_pane_window(session, &block);
          block.handle_behind = session->pane_handle;
        }
      }
      break;
  }

  /* open the main window */
  if (poll_flag)
      _swi(Wimp_OpenWindow, _IN(1), &wimp_block);
  else
      _swi(Wimp_OpenWindow, _IN(1), &block);
}

/* Close window */

void close_window(int window_handle)
{
  struct wimp_closewindow_block block;
  struct session_struct *session = sessions;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    if (session->socket_state == NETTLE_SESSION_CONNECTED)
    {
      char message[200];
      bool status = generror_question(lookup("ConnectionOpen", message, 200));

      if (!status)
        return;
    }
    remove_session(session);
  }
  else
  {
    block.window_handle = window_handle;

    _swi(Wimp_CloseWindow, _IN(1), &block);
  }
}

/* Determine if there are any sessions open.  If so, query the user as to whether */
/*  to really quit the program. */

static void close_program(void)
{
  struct session_struct *session = sessions;

  while (session)
  {
    if (session->socket_state == NETTLE_SESSION_CONNECTED)
    {
      char message[200];

      quit_flag = generror_question(lookup("ConnectionMultiOpen", message, 200));
      return;
    }
    session = session->next;
  }
  quit_flag = true;
}


/* Mouse click */

void mouse_click(int x, int y, int buttons, int window_handle, int icon_handle)
{
  if (window_handle==-2)
  {
    if (icon_handle==iconbar_handle)
    {
       switch (buttons)
       {
         case 4: case 1:
           open_open_window(true);
           break;
         case 2:
           create_iconbar_menu();
           break;
       }
    }
    return;
  }

  if (window_handle==open)
  {
    switch (icon_handle)
    {
      case 2:
        close_window(open);
        break;
      case 3:
        start_connection();
        break;
      case 5:
        create_connection_menu();
        break;
      case 10:
        create_terminal_type_menu();
        break;
    }
    return;
  }

  if (window_handle==save)
  {
    switch (icon_handle)
    {
      case 0:
        _swi(Wimp_CreateMenu, _IN(1), -1);
        break;
      case 1:
        {
          char save_data[1024];

          read_icon_data(save, 2, save_data, 1024);

          if ((instr(save_data, ":")>=0))
          {
            struct wimp_geticonstate_block block;

            block.window_handle=save;
            block.icon_handle  =4;

            _swi(Wimp_GetIconState, _IN(1), &block);

            /* if selected bit is set, then we save with ANSI colour */
            if (block.icon_flags & (1<<21))
            {
              save_selection(save_data, true);
            }
            else
            {
              save_selection(save_data, false);
            }

            _swi(Wimp_CreateMenu, _IN(1), -1);
          }
          else
          {
            generror("To save, drag the icon to a directory display", false);
          }
        }
        break;
      case 3:
        switch (buttons)
        {
          case 64: case 16:
            /* Drag */
            drag_start(save, 3);
            break;
        }
        break;
    }
    return;
  }

  {
    struct session_struct *session = sessions;
    int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

    /* find the session */

    while (session && window_handle != session->window_handle)
    {
      session = session->next;
    }

    if (session)
    {
      int x_pos;
      int y_pos;

      /* if we're not pressing MENU */
      if (buttons!=2 && buttons!=32)
      {
        /* set the caret to be in the window or line editor (depending if lineeditor is on) */
        if (line_editor_active(session))
        {
          struct wimp_getcaretposition_block block;

          _swi(Wimp_GetCaretPosition, _IN(1), &block);

          if (block.window_handle!=session->pane_handle)
          {
            set_caret_position(session->pane_handle, 1, -1,
              get_icon_data_length(session->pane_handle, 1));
          }
        }
        else
        {
          set_caret_position(session->window_handle,-1,-1,-1);
        }
      }

      {
        struct wimp_getwindowstate_block block;

        block.window_handle=window_handle;

        _swi(Wimp_GetWindowState, _IN(1), &block);

        x_pos=block.minx-block.scroll_x;
        y_pos=block.maxy-block.scroll_y;
      }

      switch (buttons)
      {
        case 64:
          /* if SELECT drag, then clear the selection and work out what where the selection start */
          /* is */
          refresh_selection_clear();

          selection_session = session;
          selection_start=((-((y-y_pos)/redraw.r_charh/2/zap_yeig))*
          		   session->terminal_size_x)+((x-x_pos)/redraw.r_charw/2);

          if (selection_start > (selection_session->terminal_size_x*
          			(selection_session->terminal_size_y+
          				selection_session->scrollback)))
          {
            selection_start=(selection_session->terminal_size_x*
          			(selection_session->terminal_size_y+
          				selection_session->scrollback));
          }

          if (selection_start<0)
          {
            selection_start=0;
          }

          selection_end=selection_start;
          selection_in_progress=true;
          break;
        case 16:
          /* if ADJUST drag, then if there is no selection, then start one */
          if (!selection_session || selection_session->window_handle != window_handle)
          {
            refresh_selection_clear();

            selection_session = session;
            selection_start=((-((y-y_pos)/redraw.r_charh/2/zap_yeig))*
            		   session->terminal_size_x)+((x-x_pos)/redraw.r_charw/2);

            if (selection_start>(selection_session->terminal_size_x*
            			(selection_session->terminal_size_y+
          				selection_session->scrollback)))
            {
              selection_start=(selection_session->terminal_size_x*
          			(selection_session->terminal_size_y+
          				selection_session->scrollback));
            }

            if (selection_start<0)
            {
              selection_start = 0;
            }

            selection_end=selection_start;
            selection_in_progress=true;
            selection_adjust_dragging=SELECTION_ADJUST_END;
          }
          else
          {
            selection_in_progress=true;
          }
          break;
        case 4:
          /* if SELECT click, then clear the selection */
          if (selection_session)
          {
            refresh_selection_clear();
            force_redraw(selection_session->window_handle,0,
              (-selection_session->terminal_size_y-
           	selection_session->scrollback)*
           	redraw.r_charh*2*zap_yeig,
                   selection_session->terminal_size_x*redraw.r_charw*2,0);
            selection_session = NULL;
          }
          break;
        case 2:
          terminal_menu_session = session;
          create_terminal_menu();
          break;
        case 1:
          /* if ADJUST click, then extend the selection */
          selection_adjust(x,x_pos,y,y_pos);
          break;
      }

      return;
    }
  }

  {
    struct session_struct *session = sessions;

    while (session && window_handle != session->pane_handle)
    {
      session = session->next;
    }

    if (session)
    {
      switch (icon_handle)
      {
        case 0:
          {
            struct wimp_geticonstate_block block;

            block.window_handle=window_handle;
            block.icon_handle  =icon_handle;

            _swi(Wimp_GetIconState, _IN(1), &block);

            if (block.icon_flags & (1<<21))
            {
              {
                struct wimp_seticonstate_block block;

                block.window_handle=session->pane_handle;
                block.icon_handle  =1;
                block.eor          =0;
                block.clear        =1<<23;

                _swi(Wimp_SetIconState, _IN(1), &block);
              }

              {
                struct wimp_getcaretposition_block block;

                _swi(Wimp_GetCaretPosition, _IN(1), &block);

                if (block.window_handle==session->window_handle)
                {
                  set_caret_position(session->pane_handle, 1, -1,
  				     get_icon_data_length(session->pane_handle, 1));
                }
              }
            }
            else
            {
              {
                struct wimp_seticonstate_block block;

                block.window_handle=session->pane_handle;
                block.icon_handle  =1;
                block.eor          =1<<23;
                block.clear        =1<<23;

                _swi(Wimp_SetIconState, _IN(1), &block);
              }

              {
                struct wimp_geticonstate_block block;

                block.window_handle=session->pane_handle;
                block.icon_handle  =1;

                _swi(Wimp_GetIconState, _IN(1), &block);

                force_redraw(session->pane_handle, block.minx, block.miny,
                                                   block.maxx, block.maxy);
              }

              {
                struct wimp_getcaretposition_block block;

                _swi(Wimp_GetCaretPosition, _IN(1), &block);

                if (block.window_handle==session->pane_handle)
                {
                  set_caret_position(session->window_handle,-1,-1,-1);
                }
              }
            }
          }
      }
      return;
    }
  }
}

/* Drag finished */

void drag_finished(void)
{
  struct wimp_getpointerinfo_block gpi_block;
  union wimp_poll_block block;

  if (drag_window_handle==save)
  {
    char string[1024];
    int loop;

    read_icon_data(save, 2, string, 1024);
    loop = strlen(string);

    while (loop>=0 && string[loop]!='.' && string[loop]!=':')
    {
      loop--;
    }

    _swi(Wimp_GetPointerInfo, _IN(1), &gpi_block);

    block.user_message.contents.data_save.window_handle=gpi_block.window_handle;
    block.user_message.contents.data_save.icon_handle  =gpi_block.icon_handle;
    block.user_message.contents.data_save.x            =gpi_block.x;
    block.user_message.contents.data_save.y            =gpi_block.y;
    block.user_message.contents.data_save.size         =selection_end-selection_start;
    block.user_message.contents.data_save.filetype     =0xFFF;

    strcpy(block.user_message.contents.data_save.file_name, string+loop+1);

    block.user_message.length      =(48+strlen(string+loop+1)) & ~3;
    block.user_message.my_ref      =0;
    block.user_message.message_code=1; /* DataSave */

    _swi(Wimp_SendMessage, _INR(0,3), 17, &block,
                           block.user_message.contents.data_save.window_handle,
                           block.user_message.contents.data_save.icon_handle);
  }
}

/* Key pressed */

void key_pressed(int window_handle, int icon_handle, int key)
{
  bool key_status=false;
  char message[MESSAGE_MAX_CONNECTION];

  if (window_handle == open)
  {
    char string[11];
    int connection_type;

    read_icon_data(open, 4, string, 11);

    if (strcmp(string, lookup("SSH", message, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_SSH;
    else if (strcmp(string,lookup("Taskwindow", message, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_TASKWINDOW;
    else
      connection_type=NETTLE_TELNET;

    switch (icon_handle)
    {
      case 0:
        switch (key)
        {
          case 13:
            switch (connection_type)
            {
              case NETTLE_TELNET:
                start_connection();
                break;
              case NETTLE_SSH:
                set_caret_position(open,7,-1, get_icon_data_length(open, 7));
                break;
            }
            key_status=true;
            break;
        }
        break;
      case 7:
        switch (key)
        {
          case 13:
            switch (connection_type)
            {
              case NETTLE_SSH: case NETTLE_TASKWINDOW:
                start_connection();
                break;
            }
            key_status=true;
            break;
        }
        break;
    }
  }
  else
  {
    {
      {
        struct session_struct *session = sessions;

        while (session && window_handle != session->window_handle)
        {
          session = session->next;
        }

        if (session)
        {
          if (session->socket_state==NETTLE_SESSION_CONNECTED)
          {
            if (pass_f12)
            {
              process_wimp_key(session, key);
              key_status=true;
            }
            else
            {
              if (key!=0x1CC && key!=0x1DC && key!=0x1EC && key!=0x1FC)
              {
                process_wimp_key(session, key);
                key_status=true;
              }
            }
          }
        }
      }
    }
  }

  if (key_status==false && line_editor)
  {
    struct session_struct *session = sessions;

    while (session && window_handle != session->window_handle)
    {
      session = session->next;
    }

    if (session)
    {
      switch (icon_handle)
      {
        case 1:
          switch (key)
          {
            case 13:
              if (session->socket_state==NETTLE_SESSION_CONNECTED)
              {
                process_line_editor(session);
                key_status=true;
              }
              break;
            case 0x18E: /* Down arrow */
              key_status=true;
              if (session->line_editor_position==0)
              {
                _swi(OS_WriteI + 7, 0);
              }
              session->line_editor_position--;

              if (session->line_editor_position<0)
              {
                session->line_editor_position=0;
              }

              {
                char icon_data[1024];

                set_icon_data(session->pane_handle, 1,
                    read_mem((char *)icon_data, session->line_editor_history +
                    (session->line_editor_position * 512), 1024));
              }

              set_caret_position(session->pane_handle, 1, -1,
                                 get_icon_data_length(session->pane_handle,1));

              break;
            case 0x18F: /* Up arrow */
              key_status=true;
              if (session->line_editor_position==
                				session->line_editor_total-1)
              {
                _swi(OS_WriteI + 7, 0);
              }
              session->line_editor_position++;

              if (session->line_editor_position>
                				session->line_editor_total-1)
              {
                session->line_editor_position=
                				session->line_editor_total-1;
              }

              {
                char icon_data[1024];

                 set_icon_data(session->pane_handle,1,
                    read_mem(icon_data, session->line_editor_history+
                     (session->line_editor_position * 512), 1024));
              }

              set_caret_position(session->pane_handle, 1, -1,
                                 get_icon_data_length(session->pane_handle,1));

              break;
          }
          break;
      }
    }
  }

  if (key_status==false)
  {
    _swi(Wimp_ProcessKey, _IN(0), key);
  }
}

/* Menu selection */

void menu_selection()
{
  switch (menu_open)
  {
    case MENU_ICONBAR:
      switch (wimp_block.menu_selection.menu[0])
      {
        case 2:
          /* Quit */
          close_program();
      }
      break;
    case MENU_TERMINAL:
      switch (wimp_block.menu_selection.menu[0])
      {
        case 0:
          switch (wimp_block.menu_selection.menu[1])
          {
            case 3:
              {
                /* Clear selection */
                int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

                refresh_selection_clear();
                force_redraw(selection_session->window_handle,0,
               			(-selection_session->terminal_size_y-
               			selection_session->scrollback)*
               			redraw.r_charh*2*zap_yeig,
                      		selection_session->terminal_size_x*redraw.r_charw*2,0);

                selection_session = NULL;
              }
              break;
          }
          break;
      }
      break;
    case MENU_CONNECTION:
      {
        char connection[MESSAGE_MAX_CONNECTION];

        switch (wimp_block.menu_selection.menu[0])
        {
          case 0:
            set_icon_data(open, 4, lookup("Telnet", connection, MESSAGE_MAX_CONNECTION));
            break;
          case 1:
            set_icon_data(open, 4, lookup("SSH",  connection, MESSAGE_MAX_CONNECTION));
            break;
          case 2:
            set_icon_data(open, 4, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION));
            break;
        }
        open_open_window(false);
      }
      break;
    case MENU_TERMINAL_TYPE:
      {
        char terminal[MESSAGE_MAX_TERMINAL];
        char string[6];
        sprintf(string, "Term%d", wimp_block.menu_selection.menu[0]);

        set_icon_data(open, 9, lookup(string, terminal, MESSAGE_MAX_TERMINAL));
      }
      break;
  }

  {
    struct wimp_getpointerinfo_block block;

    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    /* If ADJUST, then re-open  menu where it was before */
    if (block.buttons==1)
    {
      switch (menu_open)
      {
        case MENU_ICONBAR:
          create_iconbar_menu();
          break;
        case MENU_TERMINAL:
          create_terminal_menu();
          break;
        case MENU_CONNECTION:
          create_connection_menu();
          break;
        case MENU_TERMINAL_TYPE:
          create_terminal_type_menu();
          break;
      }
    }
  }
}

/* Lose caret */

void lose_caret()
{
  struct session_struct *session = sessions;
  int calc;
  int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  while (session && wimp_block.caret.window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    struct wimp_getcaretposition_block block;

    _swi(Wimp_GetCaretPosition, _IN(1), &block);

    /* if lineeditor is off, or the caret isn't in the pane, then make the cursor look like */
    /* we have no input */
    if (!(line_editor_active(session)) ||
        block.window_handle != session->pane_handle)
    {
      calc=get_cursor_position(session);
      write_assigned_flags(session, calc,
      			   read_assigned_flags(session, calc) | NETTLE_FLAG_NO_INPUT);

      force_redraw(session->window_handle,
      		   session->xpos*redraw.r_charw*2,
		   (-session->ypos-1)*redraw.r_charh*2*zap_yeig,
		   (session->xpos+1)*redraw.r_charw*2,
		   (-session->ypos)*redraw.r_charh*2*zap_yeig);
    }
    return;
  }

  session = sessions;

  while (session && wimp_block.caret.window_handle != session->pane_handle)
  {
    session = session->next;
  }

  if (session)
  {
    /* if the caret is being lost from the pane, then deselect the cursor too */
    calc=get_cursor_position(session);
    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) | NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->xpos*redraw.r_charw*2,
		 (-session->ypos-1)*redraw.r_charh*2*zap_yeig,
		 (session->xpos+1)*redraw.r_charw*2,
		 (-session->ypos)*redraw.r_charh*2*zap_yeig);
  }
}

/* Gain caret */

void gain_caret()
{
  struct session_struct *session = sessions;
  int calc;
  int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  while (session && wimp_block.caret.window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    /* if the handle is the window handle, get input back for the cursor */
    calc=get_cursor_position(session);

    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) & ~NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->xpos*redraw.r_charw*2,
		 (-session->ypos-1)*redraw.r_charh*2*zap_yeig,
		 (session->xpos+1)*redraw.r_charw*2,
	         (-session->ypos)*redraw.r_charh*2*zap_yeig);

    if (line_editor_active(session))
    {
      /* if line editor and doesn't already have caret, then set the caret in pane */
      struct wimp_getcaretposition_block block;

      _swi(Wimp_GetCaretPosition, _IN(1), &block);

      if (block.window_handle!=session->pane_handle)
      {
        set_caret_position(session->pane_handle,1,-1,
               		   get_icon_data_length(session->pane_handle,1));
      }
    }

    return;
  }

  session = sessions;

  while (session && wimp_block.caret.window_handle != session->pane_handle)
  {
    session = session->next;
  }

  if (session)
  {
    calc=get_cursor_position(session);

    /* unset no input flag again */
    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) & ~NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->xpos*redraw.r_charw*2,
		 (-session->ypos-1)*redraw.r_charh*2*zap_yeig,
		 (session->xpos+1)*redraw.r_charw*2,
		 (-session->ypos)*redraw.r_charh*2*zap_yeig);

    {
      struct wimp_getcaretposition_block block;

      _swi(Wimp_GetCaretPosition, _IN(1), &block);

      /* again, set caret if it's not already in the pane */
      if (block.window_handle!=session->pane_handle)
      {
        set_caret_position(session->pane_handle,1,-1,
           		   get_icon_data_length(session->pane_handle,1));
      }
    }
  }
}

/* Wimp message */

void wimp_message(int message_number, int sender_ref, int my_ref)
{
  switch (message_number)
  {
    case 0: /* Quit */
      quit_flag=true;
      break;
    case 2: /* DataSaveAck */
      {
        char string[1024];

        read_mem(string, wimp_block.user_message.contents.data_save_ack.file_name, 1024);

        {
          struct wimp_geticonstate_block block;

          block.window_handle=drag_window_handle;
          block.icon_handle  =4;

          _swi(Wimp_GetIconState, _IN(1), &block);

          if (block.icon_flags & (1<<21))
          {
            save_selection(string,true);
          }
          else
          {
            save_selection(string,false);
          }
        }

        if (instr(string,"Wimp$Scrap")==-1)
        {
          set_icon_data(drag_window_handle,2,string);
        }

        wimp_block.user_message.sender_ref  =my_ref;
        wimp_block.user_message.message_code=3;

        _swi(Wimp_SendMessage, _INR(0,2), 17, &wimp_block, sender_ref);

        _swi(Wimp_CreateMenu, _IN(1), -1);
      }
      break;
    case 0x400C1: /* Mode change */
      mode_change();
      break;
    case 0x808C1: /* Task window data */
      {
        struct session_struct *session = sessions;

        if (session) {
          return;
        }

        while (session && session->socket_handle != sender_ref) {
          session = session->next;
        }

        if (session)
        {
          write_out_data(session,
                         wimp_block.user_message.contents.task_window_output.data,
                         wimp_block.user_message.contents.task_window_output.size);
        }
        wimp_block.user_message.my_ref=wimp_block.user_message.your_ref;

        _swi(Wimp_SendMessage, _INR(0,2), 19, &wimp_block, sender_ref);
      }
      break;
    case 0x808C2: /* Task window started */
      {
        struct session_struct *session = sessions;
        int s_count = 0;
        int txt_handle = wimp_block.user_message.contents.task_window_ego.txt_handle;

        while (session && s_count < txt_handle) {
          s_count++;
          session = session->next;
        }

        if (session)
        {
          session->socket_state = NETTLE_SESSION_CONNECTED;
          session->socket_handle = sender_ref;
          set_title_bar(session->window_handle,"nettle (Open)");
        }
      }
      break;
    case 0x808C3: /* Task window terminated */
      {
        struct session_struct *session = sessions;

        if (session) {
          return;
        }

        while (session && session->socket_handle != sender_ref) {
          session = session->next;
        }

        if (session)
        {
          set_title_bar(session->window_handle,"nettle (Closed)");
          session->socket_state=NETTLE_SESSION_NONE;
          session->socket_handle=0;
        }

        write_out_string(session, "\r\nnettle: Taskwindow has closed\r\n");
      }
      break;
  }
}

void mode_change(void)
{
  int *zap_font_used;
  int mem_required;
  int a;
  int b;
  struct session_struct *session = sessions;
  int zap_yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

  /* work out which font we should be using */
  if (zap_yeig==1)
  {
    zap_font_used=zap_font_area;
  }
  else
  {
    zap_font_used=zap_lowres_font_area;
  }

  _swi(ZapRedraw_ReadVduVars, _IN(1), &redraw);

  mem_required=(zap_font_used[2]*zap_font_used[3]*384);

  switch (redraw.r_bpp)
  {
    case 0:mem_required/=8;break;
    case 1:mem_required/=4;break;
    case 2:mem_required/=2;break;
    case 4:mem_required*=2;break;
    case 5:mem_required*=4;break;
  }

  /* Reallocate the bitmaps area */
  bitmaps_area=realloc(bitmaps_area,mem_required);

  redraw.r_flags=0;
  redraw.r_charw=zap_font_used[2];
  redraw.r_charh=zap_font_used[3];
  redraw.r_caddr=bitmaps_area;

  _swi(ZapRedraw_CachedCharSize, _INR(0,3)|_OUTR(2,3),
                                 redraw.r_bpp, 0, redraw.r_charw, redraw.r_charh, &a, &b);

  redraw.r_cbpl=a;
  redraw.r_cbpc=b;
  redraw.r_linesp=0;

  _swi(ZapRedraw_ConvertBitmap, _INR(1,4), &redraw, zap_font_used[4], 0x11D,
                                ((char *) zap_font_used)+32);

  redraw.r_palette=zap_palette;

  _swi(ZapRedraw_CreatePalette, _INR(0,4), 2, &redraw, palette,
                                zap_palette, 16);

  redraw.r_for=7;
  redraw.r_bac=0;

  /* Resize all of the terminals to fit the new font size */
  while (session)
  {
    int block[4];
    block[0]=0;
    block[1]=-((session->terminal_size_y+session->scrollback)*
                redraw.r_charh*2*zap_yeig);
    block[2]=session->terminal_size_x*redraw.r_charw*2;
    block[3]=12;

    _swi(Wimp_SetExtent, _INR(0,1), session->window_handle, block);

    session = session->next;
  }
}

/* */
/* Other Wimp related code */
/* */

void generror(const char *string, bool is_message)
{
  char message[256];
  int block[64];

  if (is_message) {
    string = lookup(string, message, 256);
  }

  block[0]=0x52380; /* fill in the error number - error numbers aren't allocated the same as */
                    /* SWIs, so this number is wrong... */
  strcpy((char *)block+4,string);

  _swi(Wimp_ReportError, _INR(0,2), block, 0, application_name);
}

bool generror_question(char *string)
{
  int block[64];

  block[0]=0x52380; /* fill in the error number - error numbers aren't allocated the same as */
                    /* SWIs, so this number is wrong... */
  strcpy((char *)block+4,string);

  return (bool) (_swi(Wimp_ReportError, _INR(0,2)|_RETURN(1), block,
                                        (1<<1)+(1<<0),application_name) == 1);
}

void set_caret_position(int window_handle, int icon_handle, int flags, int index)
{
  _swi(Wimp_SetCaretPosition, _INR(0,5),
                              window_handle, icon_handle, -1, -1, flags, index);
}

void set_icon_data(int window_handle, int icon_handle, char *contents)
{
  int block[10];

  block[0]=window_handle;
  block[1]=icon_handle;

  _swi(Wimp_GetIconState, _IN(1), block);

  if (block[6] & (1<<8))
  {
    if (strcmp((char *)block[7],contents))
    {
      strcpy((char *)block[7],contents);
      block[2]=0;
      block[3]=0;

      _swi(Wimp_SetIconState, _IN(1), block);
    }
  }
  else
  {
    char string[1024];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
}

void set_icon_validation(int window_handle, int icon_handle, char *contents)
{
  int block[10];

  block[0]=window_handle;
  block[1]=icon_handle;

  _swi(Wimp_GetIconState, _IN(1), block);

  if (block[6] & (1<<8))
  {
    if (strcmp((char *)block[8],contents))
    {
      strcpy((char *)block[8],contents);
      block[2]=0;
      block[3]=0;

      _swi(Wimp_SetIconState, _IN(1), block);
    }
  }
  else
  {
    char string[1024];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
}

char *read_icon_data(int window_handle, int icon_handle, char *buffer, int buf_len)
{
  int block[10];

  block[0] = window_handle;
  block[1] = icon_handle;

  _swi(Wimp_GetIconState, _IN(1), block);

  if (block[6] & (1 << 8))
  {
    return read_mem(buffer, (char *)block[7], buf_len);
  }
  else
  {
    char string[1024];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
  return "";
}


int get_icon_data_length(int window_handle, int icon_handle)
{
  int block[11];
  int length = 0;

  block[0] = window_handle;
  block[1] = icon_handle;

  _swi(Wimp_GetIconState, _IN(1), block);

  if (block[6] & (1 << 8))
  {
    char *data = (char *)block[7];

    while (*data != '\0' && *data != '\x0d' && *data != '\x0a') {
      length++;
      data++;
    }
  }
  else
  {
    char string[1024];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
  return length;
}


/* Create menu code */

static int *create_menu(int *menu_data, char *indirected, char *title, char *entries, ... )
{
  va_list args;
  int window_handle;
  char *item;
  bool exit_loop=false;
  int position=28;
  char *pos;
  bool shaded,dotted,ticked,send_message,last_item;

  if (strlen(title)<12)
  {
    strcpy((char *)menu_data, title);
  }
  else
  {
    generror("Title string too long (can be fixed, but not important right now)", false);
    return 0;
  }

  menu_data[3]=(7<<0)+(2<<8)+(7<<16)+(0<<24);
  menu_data[4]=0;
  menu_data[5]=44;
  menu_data[6]=0;

  va_start(args, entries);

  item=entries;

  while (!exit_loop)
  {
    ticked=false; dotted=false; shaded=false; send_message=false; last_item=false;
    window_handle=-1;
    {
      menu_data[position/4]=0;
      while ((*item=='#') || (*item=='.') || (*item=='/') || (*item=='['))
      {
        switch (*item)
        {
          case '#':
            shaded=true;
            break;
          case '.':
            dotted=true;
            break;
          case '/':
            ticked=true;
            break;
          case '[':
            send_message=true;
            break;
        }
        item++;
      }
    }

    pos=item+strlen(item)-1;
    while ((*pos=='>') || (*pos=='\\'))
    {
      switch (*pos)
      {
        case '>':
          window_handle=va_arg(args,int);
          break;
        case '\\':
          last_item=true;
          exit_loop=true;
          break;
      }
      pos--;
    }

    if (ticked)
    {
      menu_data[position/4]=menu_data[position/4] | (1<<0);
    }
    if (dotted)
    {
      menu_data[position/4]=menu_data[position/4] | (1<<1);
    }
    if (send_message)
    {
      menu_data[position/4]=menu_data[position/4] | (1<<3);
    }
    if (last_item)
    {
      menu_data[position/4]=menu_data[position/4] | (1<<7);
    }

    position+=4;
    menu_data[position/4]=window_handle;
    position+=4;

    if (strlen(item)<13)
    {
      menu_data[position/4]=0x7000031;
    }
    else
    {
      menu_data[position/4]=0x7000131;
    }

    if (shaded)
    {
      menu_data[position/4]=menu_data[position/4] | (1<<22);
    }

    position+=4;

    if (strlen(item)<13)
    {
      strncpy((char *) menu_data+position,item,pos-item+1);

      {
        char *menu_data_char=(char *) menu_data;
        menu_data_char[position+pos-item+1]='\0';
      }

      position+=4;
    }
    else
    {
      strncpy(indirected, item, pos-item+1);
      indirected[pos-item+1]='\0';
      menu_data[position/4]=(int) indirected;
      position+=4;
      menu_data[position/4]=strlen(indirected);
      indirected+=strlen(indirected);
    }
    position+=8;

    item=va_arg(args,char *);
  }

  va_end(args);

  return menu_data;
}

static char *get_menu_item(char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 1);

  return strcpy(item, value);
}

static char *get_last_menu_item(char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 2);

  strcpy(item, value);
  return strcat(item, "\\");
}

static char *get_grey_menu_item(char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 2);

  item[0] = '#';
  item[1] = '\0';
  return strcat(item, value);
}

static char *get_grey_last_menu_item(char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, 20);
  char *item = malloc(strlen(value) + 3);

  item[0] = '#';
  strcpy(item + 1, value);
  strcat(item,"\\");
  return item;
}

void create_iconbar_menu(void)
{
  int block[5];

  char *menu_title   = get_menu_item("AppName");
  char *menu_info    = get_menu_item("Info");
  char *menu_choices = get_grey_menu_item("Choices");
  char *menu_quit    = get_last_menu_item("Quit");

  if (create_menu(menu_data,0,menu_title,menu_info,info,menu_choices,menu_quit))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), block);

    _swi(Wimp_CreateMenu, _INR(1,3), menu_data, block[0]-64, 252);
  }

  free(menu_title);
  free(menu_info);
  free(menu_choices);
  free(menu_quit);

  menu_open=MENU_ICONBAR;
}

void create_terminal_menu(void)
{
  int block[5];

  char *menu_title          =get_menu_item("Terminal");
  char *menu_selection;
  char *menu_resize         =get_grey_menu_item("Resize");
  char *menu_options        =get_grey_last_menu_item("Options");
  char *menu_selection_title=get_menu_item("Selection");
  char *menu_save	    =get_menu_item("Save");
  char *menu_launch_url     =get_grey_menu_item("LaunchURL");
  char *menu_send           =get_grey_menu_item("Send");
  char *menu_clear          =get_grey_last_menu_item("Clear");

  if (!selection_session || (selection_start==selection_end))
  {
    menu_selection=get_grey_menu_item("Selection>");
  }
  else
  {
    menu_selection=get_menu_item("Selection>");
  }

  if (create_menu(menu_data,0,menu_title,menu_selection,menu_data2,menu_resize,resize,
    		  menu_options))
  {
    if (create_menu(menu_data2,0,menu_selection_title,menu_save,save,menu_launch_url,menu_send,
                    menu_clear))
    {
      _swi(Wimp_GetPointerInfo, _IN(1), block);

      _swi(Wimp_CreateMenu, _INR(1,3), menu_data, block[0]-64, block[1]);
    }
  }

  free(menu_title);
  free(menu_selection);
  free(menu_resize);
  free(menu_options);
  free(menu_selection_title);
  free(menu_save);
  free(menu_launch_url);
  free(menu_send);
  free(menu_clear);

  menu_open=MENU_TERMINAL;
}

void create_connection_menu(void)
{
  int block[5];

  char *menu_title     =get_menu_item("Connection");
  char *menu_telnet    =get_menu_item("Telnet");
  char *menu_ssh       =get_grey_menu_item("SSH");
  char *menu_taskwindow=get_last_menu_item("Taskwindow");

  if (create_menu(menu_data,0,menu_title,menu_telnet,menu_ssh,menu_taskwindow))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), block);

    _swi(Wimp_CreateMenu, _INR(1,3), menu_data, block[0]-64, block[1]);
  }

  menu_open=MENU_CONNECTION;
}

void create_terminal_type_menu(void)
{
  int block[5];

  char *menu_title     =get_menu_item("Terminal");
  char *menu_term0     =get_grey_menu_item("Term0");
  char *menu_term1     =get_grey_menu_item("Term1");
  char *menu_term2     =get_menu_item("Term2");
  char *menu_term3     =get_grey_menu_item("Term3");
  char *menu_term4     =get_grey_menu_item("Term4");
  char *menu_term5     =get_grey_menu_item("Term5");
  char *menu_term6     =get_grey_menu_item("Term6");
  char *menu_term7     =get_grey_last_menu_item("Term7");

  if (create_menu(menu_data,0,menu_title,menu_term0,menu_term1,menu_term2,menu_term3,
    		  menu_term4,menu_term5,menu_term6,menu_term7))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), block);

    _swi(Wimp_CreateMenu, _INR(1,3), menu_data, block[0]-64, block[1]);
  }

  free(menu_title);
  free(menu_term0);
  free(menu_term1);
  free(menu_term2);
  free(menu_term3);
  free(menu_term4);
  free(menu_term5);
  free(menu_term6);
  free(menu_term7);

  menu_open=MENU_TERMINAL_TYPE;
}

/* Set title bar code */
void set_title_bar(int window_handle, char *title)
{
  int block[23];

  block[0]=window_handle;

  _swi(Wimp_GetWindowInfo, _IN(1), ((char *) block)+1);

  if (block[15] & (1<<8))
  {
    if (strcmp((char *)block[19],title))
    {
      strcpy((char *)block[19],title);

      _swi(Wimp_ForceRedraw, _INR(0,2), window_handle, 0x4B534154, 3);
    }
  }
  else
  {
    generror("Title bar in window is not indirected.", false);
  }
}

/* Force redraw code */
void force_redraw(int window_handle, int minx, int miny, int maxx, int maxy)
{
  _swi(Wimp_ForceRedraw, _INR(0,4), window_handle, minx, miny,
                                                                            maxx, maxy);
}


void drag_start(int window_handle, int icon_handle)
{
  int xstart,ystart,xeig,yeig,xsize,ysize;
  int block[10];
  char string[256];

  drag_window_handle=window_handle;
  drag_icon_handle=icon_handle;

  block[0]=window_handle;

  _swi(Wimp_GetWindowState, _IN(1), block);

  xstart=block[1]-block[5];
  ystart=block[4]-block[6];

  xeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
  yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);
  xsize=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 11);
  ysize=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 12);

  xsize*=xeig*2;
  ysize*=yeig*2;

  block[0]=window_handle;
  block[1]=icon_handle;

  _swi(Wimp_GetIconState, _IN(1), block);

  block[0]=window_handle;
  block[1]=5;
  block[2]+=xstart;
  block[3]+=ystart;
  block[4]+=xstart;
  block[5]+=ystart;
  block[6]=0;
  block[7]=0;
  block[8]=xsize;
  block[9]=ysize;

  read_icon_data(window_handle, icon_handle, string, 256);

  if (_swi(OS_Byte, _INR(0,1)|_RETURN(2), 161, 28) & 1)
  {
    _swi(DragASprite_Start, _INR(0,4), 0xc5, 1, string, block+8, 0);
  }
  else
  {
    _swi(Wimp_DragBox, _IN(1), block);
  }
}

void open_open_window(bool open_window_flag)
{
  char string[11];
  int connection_type;
  int block[4];

  read_icon_data(open, 4, string, 11);

  {
    char type[20];

    if (strcmp(string, lookup("SSH", type, 20)) == 0)
      connection_type = NETTLE_SSH;
    else if (strcmp(string,lookup("Taskwindow", type, 20)) == 0)
      connection_type = NETTLE_TASKWINDOW;
    else
      connection_type = NETTLE_TELNET;
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
      block[0]=open;
      block[1]=7; /* Comnand icon */
      block[2]=1<<22;
      block[3]=1<<22;
      _swi(Wimp_SetIconState, _IN(1), block);

      block[0]=open;
      block[1]=0; /* Host icon */
      block[2]=0;
      block[3]=1<<22;
      _swi(Wimp_SetIconState, _IN(1), block);

      break;

    case NETTLE_SSH:
      block[0]=open;
      block[1]=7; /* Command icon */
      block[2]=0;
      block[3]=1<<22;
      _swi(Wimp_SetIconState, _IN(1), block);

      block[0]=open;
      block[1]=0; /* Host icon */
      block[2]=0;
      block[3]=1<<22;
      _swi(Wimp_SetIconState, _IN(1), block);

      break;

    case NETTLE_TASKWINDOW:
      block[0]=open;
      block[1]=7; /* Command icon */
      block[2]=0;
      block[3]=1<<22;
      _swi(Wimp_SetIconState, _IN(1), block);


      block[0]=open;
      block[1]=0;     /* Host icon */
      block[2]=1<<22;
      block[3]=1<<22;
      _swi(Wimp_SetIconState, _IN(1), block);

      break;
  }

  if (open_window_flag)
  {
    open_window(open,false);
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
    case NETTLE_SSH:
      set_caret_position(open, 0, -1, get_icon_data_length(open, 0));
      break;

    case NETTLE_TASKWINDOW:
      set_caret_position(open, 7, -1, get_icon_data_length(open, 7));
      break;
  }
}
