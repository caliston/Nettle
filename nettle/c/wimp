/**
 * Wimp_Poll / Wimp code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include <errno.h>
#include "sys/errno.h"

#ifdef USE_TCPIPLIB
#  include "socklib.h"
#else
#  include "sys/socket.h"
#endif

#include "sys/select.h"
#include "sys/time.h"

#include "choices.h"
#include "hotlist.h"
#include "lineedit.h"
#include "messages.h"
#include "main.h"
#include "misc.h"
#include "nettle.h"
#include "process.h"
#include "seln.h"
#include "socket.h"
#include "sockwatch.h"
#include "termlist.h"
#include "wimp.h"
#include "zapredraw.h"

static int menu_data[64];
static int menu_data2[64];
static int *bitmaps_area=0;
static int bitmaps_area_number=0;
static int drag_window_handle=0;
static int drag_icon_handle=0;
static struct session_struct *terminal_menu_session = NULL;
static int zap_palette[16];
static int palette[16]={0x00000000, 0x0000D000, 0x00D00000, 0x00D0D000,
  		        0xD0000000, 0xD000D000, 0xD0D00000, 0xD0D0D000,
  		        0x40404000, 0x0000FF00, 0x00FF0000, 0x00FFFF00,
  		        0xFF000000, 0xFF00FF00, 0xFFFF0000, 0xFFFFFF00};

static bool generror_question(char *string);
static void create_iconbar_menu(void);
static void open_open_window(bool open_window_flag);
static void open_choices_window(void);
static int get_icon_data_length(int window_handle, int icon_handle);
static void create_terminal_menu(void);
static void create_connection_menu(void);
static void create_terminal_type_menu(void);
static void drag_start(int, int);
static bool win_choices_read(int save);


void closedown_wimp(void)
{
  _swi(Wimp_CloseDown, _INR(0,1), task_handle, 0x4b534154);
}

void open_window_centred (int window_handle)
{
  struct wimp_openwindow_block block;
  struct coords screen_size;

  /* get the window state */
  block.window_handle = window_handle;
  _swi (Wimp_GetWindowState, _IN(1), &block);

  /* get screen size (pixels) */
  screen_size.x = _swi (OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 11);
  screen_size.y = _swi (OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 12);

  /* calculate position */
  block.max.x -= block.min.x;
  block.min.x = ((screen_size.x + 1) << eig.x) /2 - block.max.x / 2;
  block.max.x += block.min.x;
  block.max.y -= block.min.y;
  block.min.y = ((screen_size.y + 1) << eig.y) / 2 - block.max.y / 2;
  block.max.y += block.min.y;
  block.handle_behind = -1;	/* open on top of stack */

  open_window(&block, NULL);
}

static void wimp_pollresolve(struct session_struct *session)
{
  switch (socket_resolvehost(session->socket_host,
                             &session->socket_ip))
  {
    case RESOLVER_INPROGRESS:
      /* resolving not finished yet, continue to take null polls */
      main_requirenull = true;
      break;
    case RESOLVER_FAILED:
      set_title_bar(session->window_handle,
                    lookup_static("title_disconnect"));
      write_out_strings(session, lookup_static("noresolv"), "\r\n", 0);
      session->socket_state=NETTLE_SESSION_NONE;
      break;
    case RESOLVER_SUCCESS:
      session->socket_handle =
                      socket_connecttoip(session->socket_ip,
                                         session->socket_port);

      if (session->socket_handle!=-1)
      {
        session->socket_state = NETTLE_SESSION_CONNECT;
        write_out_strings(session, lookup_static("connecting"),
                          socket_ip_string(session->socket_ip),
                          "...\r\n", 0);
        /* take a null so the state machine gets kicked and wimp_pollconect
         * starts taking null polls */
        main_requirenull = true;
      }
      else
      {
        write_out_strings(session, lookup_static("nosocket"),
                           "\r\n", 0);
        session->socket_state=NETTLE_SESSION_NONE;
      }
  }
}



static void wimp_pollconnect(struct session_struct *session)
{
  switch (socket_connected(session->socket_handle))
  {
    case -6:
      set_title_bar(session->window_handle,
                     lookup_static("title_noconn"));
      write_out_strings(session, lookup_static("noconn"), "\r\n", 0);
      socket_close(session->socket_handle);

      session->socket_handle=0;
      session->socket_state=NETTLE_SESSION_NONE;
      break;
    case 4:
      {
        char string[1024];

        sprintf(string,"nettle/%s (%s,%d)",
                terminal_name[session->terminal_type],
                session->socket_host,
                session->socket_port);

        set_title_bar(session->window_handle,string);

        session->socket_state = NETTLE_SESSION_CONNECTED;
        write_out_strings(session, lookup_static("connected"),
                          socket_ip_string(session->socket_ip),
                          "\r\n", 0);
        main_requirenull = true; /* read any data waiting on the socket */
        break;
      }
    default:
      /* still connecting, take null polls */
      main_requirenull = true;
      break;
  }
}



static void wimp_pollsocket(struct session_struct *session)
{
  int packet_length;
  char receive_block[RECEIVE_BLOCK_LENGTH];

  packet_length = recv(session->socket_handle, receive_block,
                       RECEIVE_BLOCK_LENGTH, 0);
  
  if (packet_length == -1 && errno == EWOULDBLOCK)
    /* we've read all the available data */
    return;
  
  if (packet_length == 0 || packet_length == -1)
  {
    /* EOF or error condition */
    set_title_bar(session->window_handle, lookup_static("title_disconnect"));
    reset_terminal(session);
    if (packet_length == 0)
    {
      /* EOF received */
      write_out_strings(session, "\r\n", lookup_static("closed"), 0);
    }
    else
    {
      char errorstr[16];
      sprintf(errorstr, "%d", errno);
      write_out_strings(session, "\r\n", "Nettle: Socket error ", errorstr,
                        " occurred", 0);
    }
  
    write_out_strings(session, "\r\n", lookup_static("disconn"), "\r\n", 0);
    socket_close(session->socket_handle);
    session->socket_handle=0;
    session->socket_state=NETTLE_SESSION_NONE;
    
    return;
  }

  write_out_data(session, receive_block, packet_length);

  /* take a null poll as there may be either more data waiting to be read
   * (and sockwatch won't notify us again about data that's already been
   * received), or there may be an EOF condition waiting for us to read
   * it. We don't try reading again straight away, as we might end up taking
   * lots of processor time if data is arriving faster than we can process
   * it.
   */
  main_requirenull = true;
}



static void wimp_pollsessions(void)
{
  struct session_struct  *session;
  int                     fdupperbound; /* (exclusive) */
  fd_set                  readfds;
  struct timeval          timeval;
  int                     numberready;

  FD_ZERO(&readfds);
  fdupperbound = 0;

  /* for each session, either poll it if necessary, or add its socket to
   * the list of ones to check with select() */
  for (session = sessions; session != NULL; session = session->next)
  {
    if (session->connection_type != NETTLE_TELNET)
      continue;

    switch (session->socket_state)
    {
      case NETTLE_SESSION_RESOLVE:
        wimp_pollresolve(session);
        break;

      case NETTLE_SESSION_CONNECT:
        wimp_pollconnect(session);
        break;

      case NETTLE_SESSION_CONNECTED:
        assert(session->socket_handle >= 0 && session->socket_handle < 256);
        FD_SET(session->socket_handle, &readfds);
        if (session->socket_handle >= fdupperbound)
          fdupperbound = session->socket_handle + 1;
        break;

      case NETTLE_SESSION_NONE:
        /* do nothing */
        break;

      default:
        assert(0);
    }
  }

  if (fdupperbound == 0)
    /* no sockets to be polled */
    return;

  timeval.tv_sec  = 0;
  timeval.tv_usec = 0;

  numberready = select(fdupperbound, &readfds, NULL, NULL, &timeval);
  if (numberready == 0)
    /* no sockets need attention */
    return;

  if (numberready == -1 && errno != EBADF)
    /* error other than an invalid descriptor, nothing we can do */
    return;

  for (session = sessions; session != NULL; session = session->next)
  {
    if (session->connection_type != NETTLE_TELNET)
      continue;

    if (session->socket_state != NETTLE_SESSION_CONNECTED)
      continue;

    if (FD_ISSET(session->socket_handle, &readfds))
      wimp_pollsocket(session);
  }
}


void wimp_nullreasoncode(void)
{
  if (socketwatch_pollword != NULL)
    *socketwatch_pollword = 0;

  wimp_pollsessions();

  close_log(false);

  if (selection_in_progress)
    handle_selection_drag();
}



/* Redraw window */

void redraw_window(union wimp_poll_block *wimp_block)
{
  struct session_struct *session = sessions;
  int window_handle = wimp_block->redraw_window.window_handle;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    zapgen_code(zapredraw_area,
                session->assigned_area,
                session->terminal_size.x,
                session->terminal_size.y + session->scrollback,
                session->other_session_flags);

    redraw.r_data = zapredraw_area;

    _swi(ZapRedraw_RedrawWindow, _INR(0,1), wimp_block, &redraw);
  }
  else
  {
    int more;

    more = _swi(Wimp_RedrawWindow, _IN(1)|_RETURN(0), wimp_block);
    while (more)
      more = _swi(Wimp_GetRectangle, _IN(1)|_RETURN(0), wimp_block);
  }
}



/* Open window */

void open_window(struct wimp_openwindow_block *wimp_block, int window_handle)
{
  struct wimp_openwindow_block local_block, *block=&local_block;
  struct session_struct *session = sessions;

  /* find out which session this window is - if any! */

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (wimp_block)
  {
    /* Called from Wimp_Poll, so use that block, which contains an OpenWindow struct */
    block = wimp_block;
  }
  else
  {
    /* Called from our own code, so fetch the OpenWindow block */
    block->window_handle = window_handle;

    _swi(Wimp_GetWindowState, _IN(1), block);

    block->handle_behind = -1;  /* Open on top of stack */
  }

  if (session)
  {
    /* This is a main "session" window, so handle the pane, if any */
    struct wimp_getwindowinfo_block window;
    window.window_handle = block->window_handle;
    _swi (Wimp_GetWindowInfo, _IN(1), 1 + (int) &window); /* no icons */

    if (_swi (OS_Byte, _INR(0,2) | _RETURN(1), 129, 254, 255))
    {
      /* Ctrl pressed - allow dynamic resizing */
      /* if the v scrollbar was at the bottom and its vpos is unchanged,
       * force it to the bottom */
      if (window.scroll.y == block->scroll.y &&
	  window.scroll.y - window.max.y + window.min.y == window.work_min.y)
      {
	block->scroll.y = window.work_min.y;
      }
    }
    else
    {
      /* limit to the number of rows */
      int height = block->max.y - block->min.y;
      int maxheight = (session->terminal_size.y * redraw.r_charh) << eig.y;

      /* if the window size is unchanged, DON'T apply this limit
       * (allow for moving the window)
       */
      if (height > maxheight &&
	  (window.max.x - window.min.x != block->max.x - block->min.x ||
	   window.max.y - window.min.y != block->max.y - block->min.y))
      {
        block->min.y = block->max.y - maxheight;
	/* if the v scrollbar was at the bottom and its vpos is unchanged
	 * force it to the bottom */
	if (window.scroll.y == block->scroll.y &&
	    window.scroll.y - window.max.y + window.min.y == window.work_min.y)
	{
	  block->scroll.y = window.work_min.y;
	}
      }

    }

    if (session->line_editor_type!=LINEEDIT_NONE)
    {
      /* open the pane window and set the 'behind' word to behind the pane */
      open_pane_window(session, block);
      block->handle_behind = session->pane_handle;
    }
  }

  _swi(Wimp_OpenWindow, _IN(1), block);
}



/* Close window */

void close_window(int window_handle)
{
  struct wimp_closewindow_block block;
  struct session_struct *session = sessions;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    if (session->socket_state == NETTLE_SESSION_CONNECTED)
    {
      char message[200];
      bool status = generror_question(lookup("ConnectionOpen", message, sizeof(message)));

      if (!status)
        return;
    }
    remove_session(session);
  }
  else
  {
    block.window_handle = window_handle;

    _swi(Wimp_CloseWindow, _IN(1), &block);
  }
}



/* Determine if there are any sessions open.  If so, query the user as to whether */
/* to really quit the program. */

static void close_program(void)
{
  struct session_struct *session = sessions;

  while (session)
  {
    if (session->socket_state == NETTLE_SESSION_CONNECTED)
    {
      char message[200];

      quit_flag = generror_question(lookup("ConnectionMultiOpen", message, sizeof(message)));
      return;
    }
    session = session->next;
  }
  quit_flag = true;
}



/* Mouse click */

static void iconbar_click(int x, int y, int buttons, int icon_handle)
{
  if (icon_handle==iconbar_handle)
  {
     switch (buttons)
     {
       case 4:
  	 open_open_window(true);
  	 break;
       case 2:
  	 create_iconbar_menu();
  	 break;
       case 1:
         create_hotlist_menu();
         break;
     }
  }
}

static void win_open_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case 2:
      close_window(win_open);
      break;
    case 3:
      start_connection();
      break;
    case 5:
      create_connection_menu();
      break;
    case 10:
      create_terminal_type_menu();
      break;
  }
}

static void win_save_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case 0:
      _swi(Wimp_CreateMenu, _IN(1), -1);
      break;

    case 1:
      {
	char save_data[1024];

	read_icon_data(win_save, 2, save_data, sizeof(save_data));

	if ((instr(save_data, ":")>=0))
	{
	  struct wimp_geticonstate_block block;

	  block.window_handle= win_save;
	  block.icon_handle  =4;

	  _swi(Wimp_GetIconState, _IN(1), &block);

	  /* if selected bit is set, then we save with ANSI colour */
	  if (block.icon_flags & (1<<21))
	  {
	    save_selection(save_data, true);
	  }
	  else
	  {
	    save_selection(save_data, false);
	  }

	  if (buttons!=1)
	  {
	    _swi(Wimp_CreateMenu, _IN(1), -1);
	  }
	}
	else
	{
	  generror("ToSaveDrag", true);
	}
      }
      break;

    case 3:
      switch (buttons)
      {
	case 64: case 16:
	  /* Drag */
	  drag_start(win_save, 3);
	  break;
      }
      break;
  }
}


static void win_resize_click(int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case 6:
      _swi(Wimp_CreateMenu, _IN(1), -1);
      break;
    case 7:
      {
        struct coords new_size;
        int new_scrollback;

        if (read_termsize_icons (win_resize, 0, 2, 4, &new_size, &new_scrollback))
	{
	  resize_terminal(terminal_menu_session, new_size.x, new_size.y, new_scrollback, true);
	  if (buttons != 1)
	  {
	    _swi(Wimp_CreateMenu, _IN(1), -1);
	  }
	}
      }
      break;
  }
}

static void win_choices_click (int x, int y, int buttons, int icon_handle)
{
  switch (icon_handle)
  {
    case 0: /* save */
      if (win_choices_read(true) && save_choices() && (buttons & 1) == 0)
        close_window(win_choices);
      break;
    case 1: /* cancel */
      if ((buttons & 1) == 0)
        close_window(win_choices);
      else
        open_choices_window();
      break;
    case 2: /* ok */
      if (win_choices_read(false) && (buttons & 1) == 0)
        close_window(win_choices);
      break;
    case 9: /* colours editor window */
      break;
    case 20: /* hotlist editor window */
      break;
  }
}


static void session_window_click(int x, int y, int buttons, int icon_handle, struct session_struct *session)
{
  int x_pos;
  int y_pos;

  /* if we're not pressing MENU */
  if (buttons!=2 && buttons!=32)
  {
    /* set the caret to be in the window or line editor (depending if lineeditor is on) */
    if (line_editor_active(session))
    {
      struct wimp_getcaretposition_block block;

      _swi(Wimp_GetCaretPosition, _IN(1), &block);

      if (session->line_editor_type==LINEEDIT_CHECKBOX)
      {
        if (block.window_handle!=session->pane_handle)
        {
  	  set_caret_position(session->pane_handle, 1, -1,
	    get_icon_data_length(session->pane_handle, 1));
        }
      }
      else
      {
        if (block.window_handle!=session->window_handle)
        {
  	  set_caret_position(session->window_handle, -1, -1, -1);
        }
      }
    }
    else
    {
      set_caret_position(session->window_handle,-1,-1,-1);
    }
  }

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=session->window_handle;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    x_pos=block.min.x-block.scroll.x;
    y_pos=block.max.y-block.scroll.y;
  }

  switch (buttons)
  {
    case 64:
      /* if SELECT drag, then clear the selection and work out what where the selection */
      /* start is */
      refresh_selection_clear();

      selection_session = session;
      selection_start = -( ( (y - y_pos) >> eig.y ) / redraw.r_charh )
                        * session->terminal_size.x
                        + ( ( (x - x_pos) >> eig.x ) / redraw.r_charw );

      if (selection_start > (selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback)))
      {
	selection_start=(selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback));
      }

      if (selection_start<0)
      {
	selection_start=0;
      }

      selection_end=selection_start;
      selection_in_progress=true;
      break;
    case 16:
      /* if ADJUST drag, then if there is no selection, then start one */
      if (!selection_session)
      {
	refresh_selection_clear();

	selection_session = session;
        selection_start = -( ( (y - y_pos) >> eig.y ) / redraw.r_charh )
                          * session->terminal_size.x
                          + ( ( (x - x_pos) >> eig.x ) / redraw.r_charw );

	if (selection_start>(selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback)))
	{
	  selection_start=(selection_session->terminal_size.x*
			    (selection_session->terminal_size.y+
				    selection_session->scrollback));
	}

	if (selection_start<0)
	{
	  selection_start = 0;
	}

	selection_end=selection_start;
	selection_in_progress=true;
	selection_adjust_dragging=SELECTION_ADJUST_END;
      }
      else
      {
	selection_in_progress=true;
      }
      break;
    case 4:
      /* if SELECT click, then clear the selection */
      if (selection_session)
      {
	refresh_selection_clear();
	force_redraw(selection_session->window_handle,0,
	  (-selection_session->terminal_size.y-
	    selection_session->scrollback)*
	    redraw.r_charh << eig.y,
	       selection_session->terminal_size.x*redraw.r_charw << eig.x,0);
	selection_session = NULL;
      }
      break;
    case 2:
      terminal_menu_session = session;
      create_terminal_menu();
      break;
    case 1:
      /* if ADJUST click, then extend the selection */
      selection_adjust(x,x_pos,y,y_pos);
      break;
  }
}

static void session_pane_click(int x, int y, int buttons, int icon_handle, struct session_struct *session)
{
  switch (icon_handle)
  {
    case 0:
      {
	struct wimp_geticonstate_block block;

	block.window_handle=session->pane_handle;
	block.icon_handle  =icon_handle;

	_swi(Wimp_GetIconState, _IN(1), &block);

	if (block.icon_flags & (1<<21))
	{
	  set_icon_state(session->pane_handle, 1, 0, 1<<23);
	  check_set_caret_position(session->pane_handle, 1);

	  {
	    struct wimp_getcaretposition_block caret_pos;

	    _swi(Wimp_GetCaretPosition, _IN(1), &caret_pos);

	    if (caret_pos.window_handle==session->window_handle)
	    {
	      set_caret_position(session->pane_handle, 1, -1,
		   get_icon_data_length(session->pane_handle, 1));
	    }
	  }
	}
	else
	{
	  set_icon_state(session->pane_handle, 1, 1<<23, 1<<23);

	  {
	    block.window_handle=session->pane_handle;
	    block.icon_handle  =1;

	    _swi(Wimp_GetIconState, _IN(1), &block);

	    force_redraw(session->pane_handle, block.min.x, block.min.y,
					       block.max.x, block.max.y);
	  }

	  {
	    struct wimp_getcaretposition_block caret_pos;

	    _swi(Wimp_GetCaretPosition, _IN(1), &caret_pos);

	    if (caret_pos.window_handle==session->pane_handle)
	    {
	      set_caret_position(session->window_handle,-1,-1,-1);
	    }
	  }
	}
      }
  }
}


/* Mouse click */

void mouse_click(int x, int y, int buttons, int window_handle, int icon_handle)
{
  if (window_handle==-2)
  {
    iconbar_click(x,y,buttons,icon_handle);
  }
  else if (window_handle == win_open)
  {
    win_open_click(x,y,buttons,icon_handle);
  }
  else if (window_handle == win_save)
  {
    win_save_click(x,y,buttons,icon_handle);
  }
  else if (window_handle == win_resize)
  {
    win_resize_click(x,y,buttons,icon_handle);
  }
  else if (window_handle == win_choices)
  {
    win_choices_click(x, y, buttons, icon_handle);
  }
  else
  {
    struct session_struct *session = sessions;

    while (session)
    {
      if (window_handle == session->window_handle)
      {
        session_window_click(x,y,buttons,icon_handle,session);
	return;
      }
      else if (session->line_editor_type==LINEEDIT_CHECKBOX &&
               (window_handle == session->pane_handle))
      {
        session_pane_click(x,y,buttons,icon_handle,session);
	return;
      }

      session = session->next;
    }
  }
}



/* Drag finished */

void drag_finished(void)
{
  struct wimp_getpointerinfo_block gpi_block;
  union wimp_poll_block block;

  if (drag_window_handle==win_save)
  {
    char string[1024];
    int loop;

    read_icon_data(win_save, 2, string, sizeof(string));
    loop = strlen(string);

    while (loop>=0 && string[loop]!='.' && string[loop]!=':')
    {
      loop--;
    }

    _swi(Wimp_GetPointerInfo, _IN(1), &gpi_block);

    block.user_message.contents.data_save.window_handle=gpi_block.window_handle;
    block.user_message.contents.data_save.icon_handle  =gpi_block.icon_handle;
    block.user_message.contents.data_save.pos.x        =gpi_block.pos.x;
    block.user_message.contents.data_save.pos.y        =gpi_block.pos.y;
    block.user_message.contents.data_save.size         =selection_end-selection_start;
    block.user_message.contents.data_save.filetype     =0xFFF;

    strcpy(block.user_message.contents.data_save.file_name, string+loop+1);

    block.user_message.length      =(48+strlen(string+loop+1)) & ~3;
    block.user_message.your_ref    =0;
    block.user_message.message_code=1; /* DataSave */

    _swi(Wimp_SendMessage, _INR(0,3), 17, &block,
                           block.user_message.contents.data_save.window_handle,
                           block.user_message.contents.data_save.icon_handle);
  }
}



/* Key pressed */

void key_pressed(int window_handle, int icon_handle, int key, int extra)
{
  int ekey = extra >> 16;
  bool key_status=false;
  char message[MESSAGE_MAX_CONNECTION];

  if (window_handle == win_open)
  {
    char string[MESSAGE_MAX_CONNECTION];
    int connection_type;

    read_icon_data(win_open, 4, string, sizeof(string));

    if (strcmp(string, lookup("SSH", message, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_SSH;
    else if (strcmp(string,lookup("Taskwindow", message, MESSAGE_MAX_CONNECTION))==0)
      connection_type=NETTLE_TASKWINDOW;
    else
      connection_type=NETTLE_TELNET;

    switch (key)
    {
      case 13:
        switch (icon_handle)
        {
          case 0:
            switch (connection_type)
            {
              case NETTLE_TELNET:
                start_connection();
                break;
              case NETTLE_SSH:
                set_caret_position(win_open,7,-1, get_icon_data_length(win_open, 7));
                break;
            }
            key_status=true;
            break;
          case 7:
            switch (connection_type)
            {
              case NETTLE_SSH: case NETTLE_TASKWINDOW:
                start_connection();
                break;
            }
            key_status=true;
            break;
        }
        break;
      case 27:
        close_window(win_open);
        break;
    }
  }

  if (window_handle==win_resize)
  {
    switch (icon_handle)
    {
      case 4:
        switch (key)
        {
          case 13:
            {
              struct coords new_size;
              int new_scrollback;

              if (read_termsize_icons(win_resize, 0, 2, 4, &new_size, &new_scrollback))
                resize_terminal(terminal_menu_session, new_size.x, new_size.y,
                                new_scrollback, true);

              _swi(Wimp_CreateMenu, _IN(1), -1);
            }
            key_status=true;
        }
        break;
    }
  }

  if (key_status==false)
  {
    {
      {
        struct session_struct *session = sessions;

        while (session && window_handle != session->window_handle)
        {
          session = session->next;
        }

        if (session)
        {
          if (session->socket_state==NETTLE_SESSION_CONNECTED)
          {
            if (pass_f12)
            {
              process_wimp_key(session, key, extra);
              key_status=true;
            }
            else
            {
              if (key!=0x1CC && key!=0x1DC && key!=0x1EC && key!=0x1FC)
              {
                process_wimp_key(session, key, extra);
                key_status=true;
              }
            }
          }
        }
      }
    }
  }

  if (key_status==false)
  {
    struct session_struct *session = sessions;
    int line_editor_icon;

    while (session && window_handle != session->pane_handle)
    {
      session = session->next;
    }

    if (session && session->line_editor_type!=LINEEDIT_NONE)
    {
      line_editor_icon=(session->line_editor_type==LINEEDIT_CHECKBOX ? 1 : 0);

      switch (key)
      {
        case 13:
          if (session->socket_state==NETTLE_SESSION_CONNECTED)
          {
            process_line_editor(session);
            key_status=true;
          }
          break;
        case 0x18E: /* Down, sPageDown */
          key_status=true;

          if (ekey == 54)
          {
            scroll_term(session, -1);
            break;
          }

          if (session->line_editor_position==0)
          {
            _swi(OS_WriteI + 7, 0);
          }
          session->line_editor_position--;

          if (session->line_editor_position<0)
          {
            session->line_editor_position=0;
          }

          {
            char icon_data[1024];

            set_icon_data(session->pane_handle, line_editor_icon,
                read_mem((char *)icon_data, session->line_editor_history +
                (session->line_editor_position * 512), sizeof(icon_data)));
          }

          set_caret_position(session->pane_handle, line_editor_icon, -1,
                             get_icon_data_length(session->pane_handle, line_editor_icon));

          break;
        case 0x18F: /* Up, sPageUp */
          key_status=true;

          if (ekey == 33)
          {
            scroll_term(session, 1);
            break;
          }

          if (session->line_editor_position==session->line_editor_total-1)
          {
            _swi(OS_WriteI + 7, 0);
          }
          session->line_editor_position++;

          if (session->line_editor_position>session->line_editor_total-1)
          {
            session->line_editor_position=session->line_editor_total-1;
          }

          {
            char icon_data[1024];

             set_icon_data(session->pane_handle,line_editor_icon,
                read_mem(icon_data, session->line_editor_history+
                 (session->line_editor_position * 512), sizeof(icon_data)));
          }

          set_caret_position(session->pane_handle, line_editor_icon, -1,
                             get_icon_data_length(session->pane_handle, line_editor_icon));

          break;
      }
    }
  }

  if (key_status==false)
  {
    _swi(Wimp_ProcessKey, _IN(0), key);
  }
}



/* Menu selection */

void wimp_menuchoice(int *selection)
{
  switch (menu_open)
  {
    case MENU_ICONBAR:
      switch (selection[0])
      {
        case 1:
          open_choices_window();
          break;
        case 2:
          /* Open connect window */
          open_open_window(true);
          break;
        case 3:
          /* Bring a session window to the front */
          {
            struct session_struct *session = get_termlist_entry(selection[1]);
            if (session)
              open_window(NULL, session->window_handle);
          }
          break;
        case 4:
          /* Quit */
          close_program();
      }
      break;

    case MENU_TERMINAL:
      switch (selection[0])
      {
        case 0: /* selection menu */
          switch (selection[1])
          {
            case 0: /* save selection */
              break;
            
            case 1: /* launch url */
              break;
              
            case 2: /* send */
              selection_paste();
              break;
              
            case 3:
              {
                /* Clear selection */
                refresh_selection_clear();
                force_redraw(selection_session->window_handle,0,
               			(-selection_session->terminal_size.y-
               			selection_session->scrollback)*
               			redraw.r_charh << eig.y,
                      		selection_session->terminal_size.x*redraw.r_charw << eig.x,0);

                selection_session = NULL;
              }
              break;
          }
          break;
      }
      break;

    case MENU_CONNECTION:
      {
        char connection[MESSAGE_MAX_CONNECTION];

        switch (selection[0])
        {
          case 0:
            set_icon_data(win_open, 4, lookup("Telnet", connection, MESSAGE_MAX_CONNECTION));
            break;
          case 1:
            set_icon_data(win_open, 4, lookup("SSH",  connection, MESSAGE_MAX_CONNECTION));
            break;
          case 2:
            set_icon_data(win_open, 4, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION));
            break;
        }
        open_open_window(false);
      }
      break;

    case MENU_TERMINAL_TYPE:
      {
        char terminal[MESSAGE_MAX_TERMINAL];
        char string[6];
        sprintf(string, "Term%d", selection[0]);

        set_icon_data(win_open, 9, lookup(string, terminal, MESSAGE_MAX_TERMINAL));
      }
      break;

    case MENU_HOTLIST:
      {
	/* use hotlist entry selection[0]  */
  /*
      char tmpbuf[100];
        char connection[MESSAGE_MAX_CONNECTION];
        unsigned short port;
	char *command;
	char *host;

        switch(type)
	{
	  case ht_telnet:
	    set_icon_data(win_open, 4, lookup("Telnet", connection, MESSAGE_MAX_CONNECTION));
	    if (port!=23) sprintf(tmpbuf, "%s:%d", host, port);
	      else strcpy(tmpbuf, host);
	    set_icon_data(win_open, 0, tmpbuf);
	    set_icon_data(win_open, 7, "");
	    break;
	  case ht_ssh:
	    set_icon_data(win_open, 4, lookup("SSH",  connection, MESSAGE_MAX_CONNECTION));
	    if (port!=22) sprintf(tmpbuf, "%s:%d", host, port);
	      else strcpy(tmpbuf, host);
	    set_icon_data(win_open, 0, tmpbuf);
	    set_icon_data(win_open, 7, command);
	    break;
	  case ht_task:
	    set_icon_data(win_open, 4, lookup("Taskwindow", connection, MESSAGE_MAX_CONNECTION));
	    set_icon_data(win_open, 0, "");
	    set_icon_data(win_open, 7, command);
	    break;
	  case ht_invalid:
	    break;
	}
*/
      }
      break;
  }

  {
    struct wimp_getpointerinfo_block block;

    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    /* If ADJUST, then re-open  menu where it was before */
    if (block.buttons==1)
    {
      switch (menu_open)
      {
        case MENU_ICONBAR:
          create_iconbar_menu();
          break;

        case MENU_TERMINAL:
          create_terminal_menu();
          break;

        case MENU_CONNECTION:
          create_connection_menu();
          break;

        case MENU_TERMINAL_TYPE:
          create_terminal_type_menu();
          break;

        case MENU_HOTLIST:
          create_hotlist_menu();
          break;
      }
    }
  }
}



/* Lose caret */

void lose_caret(int window_handle)
{
  struct session_struct *session = sessions;
  int calc;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    struct wimp_getcaretposition_block block;

    _swi(Wimp_GetCaretPosition, _IN(1), &block);

    /* if lineeditor is off, or the caret isn't in the pane, then make the cursor look like */
    /* we have no input */
    if (!(line_editor_active(session)) || block.window_handle != session->pane_handle)
    {
      calc=get_cursor_position(session);
      write_assigned_flags(session, calc,
      			   read_assigned_flags(session, calc) | NETTLE_FLAG_NO_INPUT);

      force_redraw(session->window_handle,
      		   session->pos.x*redraw.r_charw << eig.x,
		   (-session->pos.y-1)*redraw.r_charh << eig.y,
		   (session->pos.x+1)*redraw.r_charw << eig.x,
		   (-session->pos.y)*redraw.r_charh << eig.y);
    }
    return;
  }

  session = sessions;

  while (session && window_handle != session->pane_handle)
  {
    session = session->next;
  }

  if (session)
  {
    /* if the caret is being lost from the pane, then deselect the cursor too */
    calc=get_cursor_position(session);
    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) | NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->pos.x*redraw.r_charw << eig.x,
		 (-session->pos.y-1)*redraw.r_charh << eig.y,
		 (session->pos.x+1)*redraw.r_charw << eig.x,
		 (-session->pos.y)*redraw.r_charh << eig.y);
  }
}



/* Gain caret */

void gain_caret(int window_handle)
{
  struct session_struct *session = sessions;
  int calc;

  while (session && window_handle != session->window_handle)
  {
    session = session->next;
  }

  if (session)
  {
    /* if the handle is the window handle, get input back for the cursor */
    calc=get_cursor_position(session);

    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) & ~NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->pos.x*redraw.r_charw << eig.x,
		 (-session->pos.y-1)*redraw.r_charh << eig.y,
		 (session->pos.x+1)*redraw.r_charw << eig.x,
	         (-session->pos.y)*redraw.r_charh << eig.y);

    if (line_editor_active(session) && session->line_editor_type==LINEEDIT_CHECKBOX)
    {
      /* if line editor and doesn't already have caret, then set the caret in pane */
      struct wimp_getcaretposition_block block;

      _swi(Wimp_GetCaretPosition, _IN(1), &block);

      if (block.window_handle!=session->pane_handle)
      {
        set_caret_position(session->pane_handle,1,-1,
               		   get_icon_data_length(session->pane_handle,1));
      }
    }

    return;
  }

  session = sessions;

  while (session && window_handle != session->pane_handle)
  {
    session = session->next;
  }

  if (session)
  {
    calc=get_cursor_position(session);

    /* unset no input flag again */
    write_assigned_flags(session, calc,
    			 read_assigned_flags(session, calc) & ~NETTLE_FLAG_NO_INPUT);

    force_redraw(session->window_handle,
    		 session->pos.x*redraw.r_charw << eig.x,
		 (-session->pos.y-1)*redraw.r_charh << eig.y,
		 (session->pos.x+1)*redraw.r_charw << eig.x,
	         (-session->pos.y)*redraw.r_charh << eig.y);

    {
      struct wimp_getcaretposition_block block;

      _swi(Wimp_GetCaretPosition, _IN(1), &block);

      /* again, set caret if it's not already in the pane */
      if (block.window_handle!=session->pane_handle &&
          session->line_editor_type==LINEEDIT_CHECKBOX)
      {
        set_caret_position(session->pane_handle,1,-1,
           		   get_icon_data_length(session->pane_handle,1));
      }
    }
  }
}



/* Wimp message */

void wimp_message(union wimp_poll_block *wimp_block)
{
  int message_number = wimp_block->user_message.message_code;
  int sender_ref     = wimp_block->user_message.sender_ref;
  int my_ref         = wimp_block->user_message.my_ref;

  switch (message_number)
  {
    case WIMP_MESSAGE_QUIT:
      quit_flag=true;
      break;

    case WIMP_MESSAGE_DATASAVEACK:
      {
        char string[1024];

        read_mem(string, wimp_block->user_message.contents.data_save_ack.file_name, sizeof(string));

        {
          struct wimp_geticonstate_block block;

          block.window_handle=drag_window_handle;
          block.icon_handle  =4;

          _swi(Wimp_GetIconState, _IN(1), &block);

          if (block.icon_flags & (1<<21))
          {
            save_selection(string,true);
          }
          else
          {
            save_selection(string,false);
          }
        }

        if (instr(string,"Wimp$Scrap")==-1)
        {
          set_icon_data(drag_window_handle,2,string);
        }

        wimp_block->user_message.your_ref    =my_ref;
        wimp_block->user_message.message_code=3;

        _swi(Wimp_SendMessage, _INR(0,2), 17, wimp_block, sender_ref);

        _swi(Wimp_CreateMenu, _IN(1), -1);
      }
      break;

    case WIMP_MESSAGE_MODECHANGE:
      mode_change();
      break;

    case WIMP_MESSAGE_TASKWINDOW_OUTPUT:
      {
        struct session_struct *session = sessions;

        if (!session) {
          return;
        }

        while (session && session->socket_handle != sender_ref) {
          session = session->next;
        }

        if (session)
        {
          write_out_data(session,
                         wimp_block->user_message.contents.task_window_output.data,
                         wimp_block->user_message.contents.task_window_output.size);
        }
        wimp_block->user_message.my_ref=wimp_block->user_message.your_ref;

        _swi(Wimp_SendMessage, _INR(0,2), 19, wimp_block, sender_ref);
      }
      break;
    case WIMP_MESSAGE_TASKWINDOW_EGO:
      {
        struct session_struct *session = sessions;
        int txt_handle = wimp_block->user_message.contents.task_window_ego.txt_handle;

        while (session && session != (struct session_struct *) txt_handle) {
          session = session->next;
        }

        if (session)
        {
          session->socket_state = NETTLE_SESSION_CONNECTED;
          session->socket_handle = sender_ref;
          set_title_bar (session->window_handle, lookup_static ("title_open"));
        }
      }
      break;

    case WIMP_MESSAGE_TASKWINDOW_MORIO:
      {
        struct session_struct *session = sessions;

        if (!session)
          return;

        while (session && session->socket_handle != sender_ref)
        {
          session = session->next;
        }

        if (session)
        {
          set_title_bar (session->window_handle, lookup_static ("title_closed"));
          session->socket_state=NETTLE_SESSION_NONE;
          session->socket_handle=0;
        }

        reset_terminal (session);
        write_out_strings (session, "\r\n", lookup_static ("twclosed"), "\r\n", 0);
      }
      break;

    case WIMP_MESSAGE_MENUWARNING:
      switch (wimp_block->user_message.contents.menu_warning.submenu)
      {
        case MENU_TERMLIST:
          {
            const int *menublock=create_termlist_menu();
            if (menublock)
              _swi (Wimp_CreateSubMenu, _INR(1,3), menublock,
                    wimp_block->user_message.contents.menu_warning.pos.x,
                    wimp_block->user_message.contents.menu_warning.pos.y);
          }
      }
      break;
  }
}



void mode_change(void)
{
  int *zap_font_used;
  int mem_required;
  int a;
  int b;
  int old_charw;
  int old_charh;
  struct session_struct *session = sessions;

  eig.x = _swi (OS_ReadModeVariable, _INR (0,1) | _RETURN (2), -1, 4);
  eig.y = _swi (OS_ReadModeVariable, _INR (0,1) | _RETURN (2), -1, 5);

  old_charw=redraw.r_charw;
  old_charh=redraw.r_charh;

  /* work out which font we should be using */
  zap_font_used = (eig.y == 1) ? zap_font_area : zap_lowres_font_area;

  _swi(ZapRedraw_ReadVduVars, _IN(1), &redraw);

  mem_required=(zap_font_used[2]*zap_font_used[3]*384);

  switch (redraw.r_bpp)
  {
    case 0:mem_required/=8;break;
    case 1:mem_required/=4;break;
    case 2:mem_required/=2;break;
    case 4:mem_required*=2;break;
    case 5:mem_required*=4;break;
  }

  /* Reallocate the bitmaps area */
  if (dynamic_areas_available())
  {
    if (bitmaps_area_number==0)
    {
      char string[]="Nettle bitmaps area";

      _swi(OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, mem_required, -1, 0x80,
                           (zap_font_used[2]*zap_font_used[3]*384*4),
                           0, -1, string, &bitmaps_area_number, &bitmaps_area);
    }
    else
    {
      int current_size;

      _swi(OS_DynamicArea, _INR(0,1)|_OUT(2), 2, bitmaps_area_number, &current_size);

      if (mem_required-current_size!=0)
      {
        _swi(OS_ChangeDynamicArea, _INR(0,1), bitmaps_area_number, mem_required-current_size);
      }
    }
  }
  else
  {
      bitmaps_area=realloc(bitmaps_area, mem_required); /* FIXME: Dangerous use of realloc() */
  }

  redraw.r_flags=0;
  redraw.r_charw=zap_font_used[2];
  redraw.r_charh=zap_font_used[3];
  redraw.r_caddr=bitmaps_area;

  _swi(ZapRedraw_CachedCharSize, _INR(0,3)|_OUTR(2,3),
                                 redraw.r_bpp, 0, redraw.r_charw, redraw.r_charh, &a, &b);

  redraw.r_cbpl=a;
  redraw.r_cbpc=b;
  redraw.r_linesp=0;

  _swi(ZapRedraw_ConvertBitmap, _INR(1,4), &redraw, zap_font_used[4], 0x11D,
                                ((char *) zap_font_used)+32);

  redraw.r_palette=zap_palette;

  _swi(ZapRedraw_CreatePalette, _INR(0,4), 2, &redraw, palette, zap_palette, 16);

  redraw.r_for=7;
  redraw.r_bac=0;

  /* Resize all of the terminals to fit the new font size */
  while (session)
  {
    reopen_and_size_window(session, session->terminal_size.x, session->terminal_size.y,
                           old_charw, old_charh);

    session = session->next;
  }
}


void lose_bitmaps(void)
{
  if (dynamic_areas_available())
  {
    if (bitmaps_area_number!=0)
    {
      _swi(OS_DynamicArea, _INR(0,1), 1, bitmaps_area_number);
    }
  }
  else
  {
    free(bitmaps_area);
  }
}

void lose_zapredraw_area(void)
{
  if (dynamic_areas_available())
  {
    if (zapredraw_area_number!=0)
    {
      _swi(OS_DynamicArea, _INR(0,1), 1, zapredraw_area_number);
    }
  }
  else
  {
    free(zapredraw_area);
  }
}

/* Other Wimp related code */

void generror(const char *string, bool is_message)
{
  char message[252];
  struct wimp_reporterror_block block;

  if (is_message)
    string = lookup(string, message, sizeof(message));

  block.errnum=255;

  strcpy(block.errmess, string);

  _swi(Wimp_ReportError, _INR(0,2), &block, 0, application_name);
}



static bool generror_question(char *string)
{
  struct wimp_reporterror_block block;

  block.errnum=255;

  strcpy(block.errmess, string);

  return (bool) (_swi(Wimp_ReportError, _INR(0,2)|_RETURN(1), &block,
                                        (1<<1)+(1<<0), application_name) == 1);
}



void set_caret_position(int window_handle, int icon_handle, int flags, int string_index)
{
  _swi(Wimp_SetCaretPosition, _INR(0,5), window_handle, icon_handle, -1, -1, flags, string_index);
}

void check_set_caret_position (int window_handle, int icon_handle)
{
  /* Update the caret position if it's in the given icon. */
  struct wimp_getcaretposition_block caret_pos;

  _swi(Wimp_GetCaretPosition, _IN(1), &caret_pos);

  if (caret_pos.window_handle == window_handle &&
      caret_pos.icon_handle == icon_handle)
  {
    set_caret_position (window_handle, icon_handle, -1,
			get_icon_data_length (window_handle, icon_handle));
  }
}


void set_icon_state (int window_handle, int icon_handle, int eor, int clear)
{
  struct wimp_seticonstate_block icon_set;

  icon_set.window_handle = window_handle;
  icon_set.icon_handle	 = icon_handle;
  icon_set.eor		 = eor;
  icon_set.clear	 = clear;

  _swi (Wimp_SetIconState, _IN(1), &icon_set);
}


void set_icon_data(int window_handle, int icon_handle, const char *contents)
{
  struct wimp_geticonstate_block block;

  block.window_handle=window_handle;
  block.icon_handle  =icon_handle;

  _swi(Wimp_GetIconState, _IN(1), &block);

  if (block.icon_flags & (1<<8))
  {
    if (strcmp(block.contents.it.text, contents) != 0)
    {
      strcpy(block.contents.it.text, contents);

      set_icon_state(window_handle, icon_handle, 0, 0);
      check_set_caret_position(window_handle, icon_handle);
    }
  }
  else
  {
    char string[1024];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
}



char *read_icon_data(int window_handle, int icon_handle, char *buffer, int buf_len)
{
  struct wimp_geticonstate_block block;

  block.window_handle = window_handle;
  block.icon_handle   = icon_handle;

  _swi(Wimp_GetIconState, _IN(1), &block);

  if (block.icon_flags & WIMP_ICON_INDIRECTED_BIT)
  {
    read_mem(buffer, block.contents.it.text, buf_len);
  }
  else
  {
    char string[1024];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
    buffer[0] = '\0';
  }
  return buffer;
}



static int get_icon_data_length(int window_handle, int icon_handle)
{
  struct wimp_geticonstate_block block;
  int length = 0;

  block.window_handle = window_handle;
  block.icon_handle   = icon_handle;

  _swi(Wimp_GetIconState, _IN(1), &block);

  if (block.icon_flags & WIMP_ICON_INDIRECTED_BIT)
  {
    char *data = block.contents.it.text;

    while (*data != '\0' && *data != '\x0d' && *data != '\x0a') {
      length++;
      data++;
    }
  }
  else
  {
    char string[1024];
    sprintf(string,"Icon %d in window %X is not indirected.",icon_handle,window_handle);
    generror(string, false);
  }
  return length;
}



/* Create menu code */

static int *create_menu(int *menu_defn, char *indirected, char *title, char *entries, ... )
{
  va_list args;
  int window_handle;
  char *item;
  bool exit_loop=false;
  int position=7;
  char *pos;
  bool shaded,dotted,ticked,send_message,last_item;

  if (strlen(title)<12)
  {
    strcpy((char *)menu_defn, title);
  }
  else
  {
    generror("Title string too long (can be fixed, but not important right now)", false);
    return 0;
  }

  menu_defn[3]=(7<<0)+(2<<8)+(7<<16)+(0<<24); /* black on white items, black on grey title text */
  menu_defn[4]=0;
  menu_defn[5]=44;
  menu_defn[6]=0;

  va_start(args, entries);

  item=entries;

  while (!exit_loop)
  {
    ticked=false; dotted=false; shaded=false; send_message=false; last_item=false;
    window_handle=-1;
    {
      menu_defn[position]=0;
      while ((*item=='#') || (*item=='.') || (*item=='/') || (*item=='['))
      {
        switch (*item)
        {
          case '#':
            shaded=true;
            break;
          case '.':
            dotted=true;
            break;
          case '/':
            ticked=true;
            break;
          case '[':
            send_message=true;
            break;
        }
        item++;
      }
    }

    pos=item+strlen(item)-1;
    while ((*pos==']') || (*pos=='>') || (*pos=='\\'))
    {
      switch (*pos)
      {
        case ']':
          menu_defn[position] |= 1 << 3;
        case '>':
          window_handle=va_arg(args,int);
          break;
        case '\\':
          last_item=true;
          exit_loop=true;
          break;
      }
      pos--;
    }

    if (ticked)
    {
      menu_defn[position] |= (1<<0);
    }
    if (dotted)
    {
      menu_defn[position] |= (1<<1);
    }
    if (send_message)
    {
      menu_defn[position] |= (1<<3);
    }
    if (last_item)
    {
      menu_defn[position] |= (1<<7);
    }

    position++;
    menu_defn[position]=window_handle;
    position++;

    menu_defn[position]=WIMP_ICON_FGCOL(7) | WIMP_ICON_VCENT_BIT | WIMP_ICON_FILLED_BIT | WIMP_ICON_TEXT_BIT;
    if (strlen(item)>13)
    {
      menu_defn[position] |= WIMP_ICON_INDIRECTED_BIT;
    }

    if (shaded)
    {
      menu_defn[position] |= WIMP_ICON_SHADED_BIT;
    }

    position++;

    if (strlen(item)<13)
    {
      strncpy(((char *) menu_defn)+(position*4),item,pos-item+1);

      {
        char *menu_data_char=(char *) menu_defn;
        menu_data_char[(position*4)+pos-item+1]='\0';
      }

      position+=3;
    }
    else
    {
      assert(indirected);

      strncpy(indirected, item, pos-item+1);
      indirected[pos-item+1]='\0';
      menu_defn[position++]=(int) indirected;
      menu_defn[position++]=(int) indirected+strlen(indirected);
      menu_defn[position++]=strlen(indirected)+1;
      indirected+=strlen(indirected)+1;
    }

    item=va_arg(args,char *);
  }

  va_end(args);

  return menu_defn;
}



static char *get_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 1);

  assert(item != NULL);

  return strcpy(item, value);
}



static char *get_last_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 2);

  assert(item != NULL);

  strcpy(item, value);
  return strcat(item, "\\");
}



static char *get_grey_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, MESSAGE_MAX_MENU);
  char *item = malloc(strlen(value) + 2);

  assert(item != NULL);

  item[0] = '#';
  item[1] = '\0';
  return strcat(item, value);
}



static char *get_grey_last_menu_item(const char *name)
{
  char contents[MESSAGE_MAX_MENU];
  char *value = lookup(name, contents, 20);
  char *item = malloc(strlen(value) + 3);

  assert(item != NULL);

  item[0] = '#';
  strcpy(item + 1, value);
  strcat(item,"\\");
  return item;
}



static void create_iconbar_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title   = get_menu_item("AppName");
  char *menu_info    = get_menu_item("Info");
  char *menu_choices = get_menu_item("Choices");
  char *menu_connect = get_menu_item("Connect");
  char *menu_session = get_menu_item("Session]");
  char *menu_quit    = get_last_menu_item("Quit");

  if (create_menu(menu_data, 0, menu_title,
                  menu_info, win_info,
                  menu_choices,
                  menu_connect,
                  menu_session, MENU_TERMLIST,
                  menu_quit))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    _swi(Wimp_CreateMenu, _INR(1,3), menu_data,
                                     block.pos.x-64, 96+24 + (5*44) );
  }

  free(menu_title);
  free(menu_info);
  free(menu_choices);
  free(menu_connect);
  free(menu_session);
  free(menu_quit);

  menu_open=MENU_ICONBAR;
}



static void create_terminal_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title          =get_menu_item("Terminal");
  char *menu_selection;
  char *menu_resize         =get_menu_item("Resize");
  char *menu_options        =get_grey_last_menu_item("Options");
  char *menu_selection_title=get_menu_item("Selection");
  char *menu_save	    =get_menu_item("Save");
  char *menu_launch_url     =get_grey_menu_item("LaunchURL");
  char *menu_send           =get_menu_item("Send");
  char *menu_clear          =get_grey_last_menu_item("Clear");

  set_termsize_icons(win_resize, 0, 2, 4, terminal_menu_session->terminal_size,
                                          terminal_menu_session->scrollback);

  if (!selection_session || (selection_start==selection_end))
  {
    menu_selection=get_grey_menu_item("Selection>");
  }
  else
  {
    menu_selection=get_menu_item("Selection>");
  }

  if (create_menu(menu_data, 0, menu_title, menu_selection, menu_data2, menu_resize, win_resize,
    		  menu_options))
  {
    if (create_menu(menu_data2, 0, menu_selection_title, menu_save, win_save, menu_launch_url,
                    menu_send, menu_clear))
    {
      _swi(Wimp_GetPointerInfo, _IN(1), &block);

      _swi(Wimp_CreateMenu, _INR(1,3), menu_data, block.pos.x-64, block.pos.y);
    }
  }

  free(menu_title);
  free(menu_selection);
  free(menu_resize);
  free(menu_options);
  free(menu_selection_title);
  free(menu_save);
  free(menu_launch_url);
  free(menu_send);
  free(menu_clear);

  menu_open=MENU_TERMINAL;
}



static void create_connection_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title     =get_menu_item("Connection");
  char *menu_telnet    =get_menu_item("Telnet");
  char *menu_ssh       =get_grey_menu_item("SSH");
  char *menu_taskwindow=get_last_menu_item("Taskwindow");

  if (create_menu(menu_data,0,menu_title,menu_telnet,menu_ssh,menu_taskwindow))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    create_menu_by_icon (menu_data, win_open, 5);
  }

  free(menu_title);
  free(menu_telnet);
  free(menu_ssh);
  free(menu_taskwindow);

  menu_open=MENU_CONNECTION;
}



static void create_terminal_type_menu(void)
{
  struct wimp_getpointerinfo_block block;

  char *menu_title     =get_menu_item("Terminal");
  char *menu_term0     =get_grey_menu_item("Term0");
  char *menu_term1     =get_grey_menu_item("Term1");
  char *menu_term2     =get_menu_item("Term2");
  char *menu_term3     =get_grey_menu_item("Term3");
  char *menu_term4     =get_grey_menu_item("Term4");
  char *menu_term5     =get_grey_menu_item("Term5");
  char *menu_term6     =get_grey_menu_item("Term6");
  char *menu_term7     =get_grey_last_menu_item("Term7");

  if (create_menu(menu_data,0,menu_title,menu_term0,menu_term1,menu_term2,menu_term3,
    		  menu_term4,menu_term5,menu_term6,menu_term7))
  {
    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    create_menu_by_icon (menu_data, win_open, 10);
  }

  free(menu_title);
  free(menu_term0);
  free(menu_term1);
  free(menu_term2);
  free(menu_term3);
  free(menu_term4);
  free(menu_term5);
  free(menu_term6);
  free(menu_term7);

  menu_open=MENU_TERMINAL_TYPE;
}



/* Set title bar code */
void set_title_bar(int window_handle, const char *title)
{
  struct wimp_getwindowinfo_block block;

  block.window_handle=window_handle;

  _swi(Wimp_GetWindowInfo, _IN(1), ((int) &block)+1);

  if (block.icon_flags & (1<<8))
  {
    if (strcmp(block.title.it.text, title) != 0)
    {
      strcpy(block.title.it.text, title);

      _swi(Wimp_ForceRedraw, _INR(0,2), window_handle, 0x4B534154, 3);
    }
  }
  else
  {
    generror("Title bar in window is not indirected.", false);
  }
}



/* Force redraw code */
void force_redraw(int window_handle, int minx, int miny, int maxx, int maxy)
{
  _swi(Wimp_ForceRedraw, _INR(0,4), window_handle, minx, miny, maxx, maxy);
}



static void drag_start(int window_handle, int icon_handle)
{
  int xstart, ystart, xsize, ysize;
  char string[256];

  drag_window_handle=window_handle;
  drag_icon_handle=icon_handle;

  {
    struct wimp_getwindowstate_block block;

    block.window_handle=window_handle;

    _swi(Wimp_GetWindowState, _IN(1), &block);

    xstart=block.min.x-block.scroll.x;
    ystart=block.max.y-block.scroll.y;
  }

  xsize=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 11);
  ysize=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 12);

  xsize <<= eig.x;
  ysize <<= eig.y;

  {
    struct wimp_geticonstate_block gis_block;
    struct wimp_dragbox_block block;

    gis_block.window_handle=window_handle;
    gis_block.icon_handle  =icon_handle;

    _swi(Wimp_GetIconState, _IN(1), &gis_block);

    block.window_handle=window_handle;
    block.drag_type    =5;
    block.min.x         =gis_block.min.x+xstart;
    block.min.y         =gis_block.min.y+ystart;
    block.max.x         =gis_block.max.x+xstart;
    block.max.y         =gis_block.max.y+ystart;
    block.parent_min.x =0;
    block.parent_min.y =0;
    block.parent_max.x =xsize;
    block.parent_max.y =ysize;

    read_icon_data(window_handle, icon_handle, string, sizeof(string));

    if (_swi(OS_Byte, _INR(0,1)|_RETURN(2), 161, 28) & (1<<1))
    {
      _swi(DragASprite_Start, _INR(0,4), 0xc5, 1, string, &block.min.x, 0);
    }
    else
    {
      _swi(Wimp_DragBox, _IN(1), &block);
    }
  }
}



static void open_open_window(bool open_window_flag)
{
  char string[MESSAGE_MAX_CONNECTION];
  int connection_type;

  read_icon_data(win_open, 4, string, MESSAGE_MAX_CONNECTION);

  {
    char type[MESSAGE_MAX_CONNECTION];

    if (strcmp(string, lookup("SSH", type, MESSAGE_MAX_CONNECTION)) == 0)
      connection_type = NETTLE_SSH;
    else if (strcmp(string, lookup("Taskwindow", type, MESSAGE_MAX_CONNECTION)) == 0)
      connection_type = NETTLE_TASKWINDOW;
    else
      connection_type = NETTLE_TELNET;
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
       /* unshade the host icons, shade the command icons */
       set_icon_state (win_open, 0, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, 8, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, 7, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, 1, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
       break;

    case NETTLE_SSH:
       /* unshade the host and command icons */
       set_icon_state (win_open, 0, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, 8, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, 7, 0, WIMP_ICON_SHADED_BIT);
       set_icon_state (win_open, 1, 0, WIMP_ICON_SHADED_BIT);
       break;

    case NETTLE_TASKWINDOW:
      /* shade the host icons, unshade the command icons */
      set_icon_state (win_open, 0, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
      set_icon_state (win_open, 8, WIMP_ICON_SHADED_BIT, WIMP_ICON_SHADED_BIT);
      set_icon_state (win_open, 7, 0, WIMP_ICON_SHADED_BIT);
      set_icon_state (win_open, 1, 0, WIMP_ICON_SHADED_BIT);
      break;
  }

  if (open_window_flag)
  {
    struct wimp_getwindowstate_block window;

    window.window_handle = win_open;
    _swi(Wimp_GetWindowState, _IN(1), &window);

    window.handle_behind = -1;  /* Open on top of stack */

    if ((window.window_flags & (1 << 16)) == 0)
    {
      /* window is not open, open it centred on the pointer taking care to
       * not obscure the icon bar */
      struct wimp_getpointerinfo_block pointer;
      int width = window.max.x - window.min.x;
      int height = window.max.y - window.min.y;

      _swi(Wimp_GetPointerInfo, _IN(1), &pointer);

      window.min.x = pointer.pos.x - width / 2;
      window.min.y = pointer.pos.y - height / 2;

      /* '134 + 2' is a cheap approximation of the height of the icon bar */
      if (window.min.y < 134 + 2)
        window.min.y = 134 + 2;

      window.max.x = window.min.x + width;
      window.max.y = window.min.y + height;
    }
    _swi(Wimp_OpenWindow, _IN(1), &window);
  }

  switch (connection_type)
  {
    case NETTLE_TELNET:
    case NETTLE_SSH:
      set_caret_position(win_open, 0, -1, get_icon_data_length(win_open, 0));
      break;

    case NETTLE_TASKWINDOW:
      set_caret_position(win_open, 7, -1, get_icon_data_length(win_open, 7));
      break;
  }
}



static void open_choices_window(void)
{
  char string[8];

  set_icon_data(win_choices, 6, zap_font);
  set_icon_data(win_choices, 8, zap_lowres_font);
  set_termsize_icons(win_choices, 15, 16, 17, defaultsize, defaultscroll);
  sprintf(string, "%d", line_editor_size);
  set_icon_data(win_choices, 19, string);

  open_window_centred(win_choices);
  set_caret_position(win_choices, 15, -1, get_icon_data_length(win_choices, 15));
}

static bool win_choices_read(int save)
{
  struct coords new_termsize;
  int new_scrollback;
  int new_line_editor_size;
  char string[8];

  if (!read_termsize_icons (win_choices, 15, 16, 17,
			    &new_termsize, &new_scrollback))
    return false;

  new_line_editor_size = atoi (read_icon_data (win_choices, 19, string, sizeof (string)));
  if (new_line_editor_size < 1 || new_line_editor_size > MAX_LINE_EDITOR_SIZE)
  {
    generror ("BadLineEdSize", true);
    return false;
  }

  /* read the option icons - these must be the last things to be read */

  /* make the choices in the new_* variables permanent */
  defaultsize = new_termsize;
  defaultscroll = new_scrollback;

  /* if we're saving, save now */
  return save ? save_choices () : true;
}

void create_menu_by_icon (int *menu, int window, int icon)
{
  /* open the menu in the proper place next to a menu icon */
  struct wimp_geticonstate_block gisblock;
  struct wimp_getwindowstate_block gwsblock;

  gisblock.window_handle = window;
  gisblock.icon_handle = icon;
  _swi (Wimp_GetIconState, _IN(1), (int) &gisblock);

  gwsblock.window_handle = window;
  _swi (Wimp_GetWindowState, _IN(1), (int) &gwsblock);

  _swi(Wimp_CreateMenu, _INR(1,3), menu,
       gwsblock.min.x + gwsblock.scroll.x + gisblock.max.x,
       gwsblock.max.y + gwsblock.scroll.y + gisblock.max.y);
}

void set_termsize_icons (int window_handle, int xicon, int yicon, int sicon,
			 struct coords size, int scrollback)
{
  char string[8];
  struct wimp_getcaretposition_block block;

  sprintf (string, "%d", size.x);
  set_icon_data (window_handle, xicon, string);

  sprintf (string, "%d", size.y);
  set_icon_data (window_handle, yicon, string);

  sprintf (string, "%d", scrollback);
  set_icon_data (window_handle, sicon, string);

  _swi(Wimp_GetCaretPosition, _IN(1), &block);

  if (block.window_handle == window_handle &&
      (block.icon_handle == xicon ||
       block.icon_handle == yicon ||
       block.icon_handle == sicon))
  {
    set_caret_position (window_handle, block.icon_handle, -1,
			get_icon_data_length (window_handle, block.icon_handle));
  }
}


bool read_termsize_icons (int window_handle, int xicon, int yicon, int sicon,
			  struct coords *size, int *scrollback)
{
  char string[8];
  struct coords tmpsize;
  int tmpscroll;

  tmpsize.x = atoi (read_icon_data (window_handle, xicon, string, sizeof (string)));
  tmpsize.y = atoi (read_icon_data (window_handle, yicon, string, sizeof (string)));
  tmpscroll = atoi (read_icon_data (window_handle, sicon, string, sizeof (string)));

  if (tmpsize.x < 1 || tmpsize.x > 256 ||
      tmpsize.y < 1 || tmpsize.y > 128 ||
      tmpscroll < 0 || tmpscroll > 128)
  {
    generror ("BadTermSize", true);
    return false;
  }

  *size = tmpsize;
  *scrollback = tmpscroll;
  return true;
}
