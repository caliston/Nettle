/**
 * Selection code
 * (C) Nettle developers 2000-2001
 *
 * $Id$
 */

#include "generic.h"
#include "globals.h"

#include "misc.h"
#include "nettle.h"
#include "seln.h"
#include "wimp.h"
#include "zapredraw.h"

void refresh_selection_set(void)
{
  if (selection_session)
  {
    int loop;
    if (selection_start>selection_end)
    {
      for (loop=selection_end; loop<selection_start; loop++)
      {
	write_assigned_flags(selection_session, loop*4,
			     read_assigned_flags(selection_session, loop*4) |
			     NETTLE_FLAG_SELECTED);
      }
    }
    else
    {
      for (loop=selection_start; loop<selection_end; loop++)
      {
	write_assigned_flags(selection_session, loop*4,
			     read_assigned_flags(selection_session, loop*4) |
			     NETTLE_FLAG_SELECTED);
      }
    }
  }
}

void refresh_selection_clear(void)
{
  if (selection_session)
  {
    int loop;
    if (selection_start>selection_end)
    {
      for (loop=selection_end; loop<selection_start; loop++)
      {
	write_assigned_flags(selection_session, loop*4,
			     read_assigned_flags(selection_session, loop*4) &
			     ~NETTLE_FLAG_SELECTED);
      }
    }
    else
    {
      for (loop=selection_start; loop<selection_end; loop++)
      {
	write_assigned_flags(selection_session, loop*4,
			     read_assigned_flags(selection_session, loop*4) &
			     ~NETTLE_FLAG_SELECTED);
      }
    }
  }
}

void selection_adjust(int x,int x_pos, int y, int y_pos)
{
  if (selection_session)
  {
    int click_point = -(((y - y_pos) / redraw.r_charh) >> eig.y)
                      * selection_session->terminal_size.x
                      + (((x - x_pos) / redraw.r_charw) >> eig.x);

    if (click_point<0)
    {
      click_point=0;
    }
    if (click_point>(selection_session->terminal_size.x*
				(selection_session->terminal_size.y+
					selection_session->scrollback)))
    {
      click_point=(selection_session->terminal_size.x*
				(selection_session->terminal_size.y+
					selection_session->scrollback));
    }

    refresh_selection_clear();

    if (click_point<selection_start)
    {
      if (click_point<selection_end && selection_start<selection_end)
      {
	selection_start=click_point;
	selection_adjust_dragging=SELECTION_ADJUST_START;
      }
      else
      {
	selection_end=click_point;
	selection_adjust_dragging=SELECTION_ADJUST_END;
      }
    }
    else
    {
      if (click_point>selection_end && selection_start>selection_end)
      {
	selection_start=click_point;
	selection_adjust_dragging=SELECTION_ADJUST_START;
      }
      else
      {
	selection_end=click_point;
	selection_adjust_dragging=SELECTION_ADJUST_END;
      }
    }
    refresh_selection_set();

    force_redraw(selection_session->window_handle,0,
       (-selection_session->terminal_size.y-
	selection_session->scrollback)*
	redraw.r_charh << eig.y,
	      selection_session->terminal_size.x*redraw.r_charw << eig.x,0);
  }
}

static void selection_adjust_drag(int x,int x_pos, int y, int y_pos)
{
  if (selection_session)
  {
    int click_point = -(((y - y_pos) / redraw.r_charh) >> eig.y)
                      * selection_session->terminal_size.x
                      + (((x - x_pos) / redraw.r_charw) >> eig.x);

    if (click_point<0)
    {
      click_point=0;
    }
    if (click_point>(selection_session->terminal_size.x*
				(selection_session->terminal_size.y+
					selection_session->scrollback)))
    {
      click_point=(selection_session->terminal_size.x*
				(selection_session->terminal_size.y+
					selection_session->scrollback));
    }

    refresh_selection_clear();

    switch (selection_adjust_dragging)
    {
      case SELECTION_ADJUST_START:
	selection_start=click_point;
	break;
      case SELECTION_ADJUST_END:
	selection_end=click_point;
	break;
    }

    refresh_selection_set();

    force_redraw(selection_session->window_handle,0,
       (-selection_session->terminal_size.y-
	selection_session->scrollback)*
	redraw.r_charh << eig.y,
	      selection_session->terminal_size.x*redraw.r_charw << eig.x, 0);
  }
}

void save_selection(char *filename, bool ansi_colour)
{
  FILE *file_handle;
  int loop;
  int current_fg=7;
  int current_bg=0;
  int current_flags=0;
  int loop_start;
  int loop_end;

  file_handle=fopen(filename,"wb");

  if (file_handle==0)
  {
    char string[1024];
    sprintf (string, lookup_static ("cantwrite"), filename);
    generror(string, false);
    return;
  }

  if (selection_end>selection_start)
  {
    loop_start=selection_start;
    loop_end=selection_end;
  }
  else
  {
    loop_start=selection_end;
    loop_end=selection_start;
  }

  for (loop=loop_start*4; loop<loop_end*4; loop+=4)
  {
    if (loop!=loop_start*4)
    {
      if ((loop % (selection_session->terminal_size.x*4))==0)
      {
	fputc('\n',file_handle);
      }
    }

    if (ansi_colour==true)
    {
      if (read_assigned_flags(selection_session, loop) & NETTLE_FLAG_INVERTED)
      {
	if (!(current_flags & NETTLE_FLAG_INVERTED))
	{
	  fprintf(file_handle,"\x1B%s","7m");
	}
      }
      if (!(read_assigned_flags(selection_session, loop) & NETTLE_FLAG_INVERTED))
      {
	if (current_flags & NETTLE_FLAG_INVERTED)
	{
	  fprintf(file_handle,"\x1B%s","27m");
	}
      }
      if (read_assigned_fg(selection_session,loop)!=current_fg)
      {
	if (read_assigned_fg(selection_session,loop)>7)
	{
	  fprintf(file_handle,"\x1B%s%c%c","1;3",
					      read_assigned_fg(selection_session,loop)-8+48,'m');
	}
	else
	{
	  fprintf(file_handle,"\x1B%c%c%c",'3',read_assigned_fg(selection_session,loop)+48,'m');
	}
      }
      if (read_assigned_bg(selection_session,loop)!=current_bg)
      {
	if (read_assigned_bg(selection_session,loop)>7)
	{
	  fprintf(file_handle,"\x1B%s%c%c","1;4",
				read_assigned_bg(selection_session,loop)-8+48,'m');
	}
	else
	{
	  fprintf(file_handle,"\x1B%c%c%c",'4',
				read_assigned_bg(selection_session,loop)+48,'m');
	}
      }
      current_fg=read_assigned_fg(selection_session,loop);
      current_bg=read_assigned_bg(selection_session,loop);
      current_flags=read_assigned_flags(selection_session,loop);
    }
    fputc(read_assigned_character(selection_session,loop),file_handle);
  }

  fclose(file_handle);

  _swi(OS_File, _INR(0,2), 18, filename, 0xFFF);
}

void handle_selection_drag(void)
{
  int x, y, buttons, window_handle, icon_handle;
  int x_pos, y_pos;
  bool do_scroll;

  {
    struct wimp_getpointerinfo_block block;

    _swi(Wimp_GetPointerInfo, _IN(1), &block);

    x            =block.x;
    y            =block.y;
    buttons      =block.buttons;
    window_handle=block.window_handle;
    icon_handle  =block.icon_handle;
  }

  if (buttons==0)
  {
    if (selection_start==selection_end)
    {
      selection_session = NULL;
    }
    selection_in_progress=false;
    return;
  }

  {
    struct wimp_getwindowinfo_block block;

    block.window_handle=selection_session->window_handle;

    _swi(Wimp_GetWindowInfo, _IN(1), ((int) &block)+1);

    x_pos=block.minx-block.scroll_x;
    y_pos=block.maxy-block.scroll_y;

    /* Scroll when selection happening and we're near the edge of the window */
    do_scroll = false;

    if (x<(block.minx+32))
    {
      block.scroll_x-=(block.minx+32-x);
      do_scroll = true;
    }

    if (x>(block.maxx-32))
    {
      block.scroll_x+=(x-block.maxx+32);
      do_scroll = true;
    }

    if (y<(block.miny+32))
    {
      block.scroll_y-=(block.miny+32-y);
      do_scroll = true;
    }

    if (y>(block.maxy-32))
    {
      block.scroll_y+=(y-block.maxy+32);
      do_scroll = true;
    }

    if (do_scroll)
    {
      _swi(Wimp_OpenWindow, _IN(1), &block);
    }
  }

  switch (buttons)
  {
    case 4:
      /* Drag SELECT - clear the selection, re-work it out, and set it again, then redraw */
      refresh_selection_clear();

      selection_end = -(((y - y_pos) / redraw.r_charh) >> eig.y)
                      * selection_session->terminal_size.x
                      + (((x - x_pos) / redraw.r_charw) >> eig.x);

      if (selection_end>(selection_session->terminal_size.x*
				(selection_session->terminal_size.y+
					selection_session->scrollback)))
      {
	selection_end=(selection_session->terminal_size.x*
				(selection_session->terminal_size.y+
					selection_session->scrollback));
      }
      if (selection_end<0)
      {
	selection_end=0;
      }

      refresh_selection_set();

      force_redraw(selection_session->window_handle,0,
	       (-selection_session->terminal_size.y-
		selection_session->scrollback)*
		redraw.r_charh << eig.y,
		selection_session->terminal_size.x*redraw.r_charw << eig.x, 0);

      break;
    case 1:
      /* ADJUST dragging - see c.seln */
      selection_adjust_drag(x,x_pos,y,y_pos);
      break;
  }
}


void force_redraw_selection (struct session_struct *session)
{
  int top, bottom;

  if (session != selection_session)
    return;

  if (selection_start <= selection_end)
  {
    top = selection_start;
    bottom = selection_end;
  }
  else
  {
    top = selection_end;
    bottom = selection_start;
  }

  top /= session->terminal_size.x;
  bottom /= session->terminal_size.x;

  force_redraw (session->window_handle, 0,
	        (-bottom - 1) * redraw.r_charh << eig.y,
		selection_session->terminal_size.x * redraw.r_charw << eig.x,
		-top * redraw.r_charh << eig.y);
}
