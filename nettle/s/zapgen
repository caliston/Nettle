;R0	rn	0
;R1	rn	1
;R2	rn	2
;R3	rn	3
;R4	rn	4
;R5	rn	5
;R6	rn	6
;R7	rn	7
;R8	rn	8
;R9	rn	9
;R10	rn	10
;R11	rn	11
;R12	rn	12
;R13	rn	13
;R14	rn	14
;PC	rn	15

	AREA    |C$$code|, CODE, READONLY

	EXPORT	zapgen_code

zapgen_code
; On entry
;    R0 = area to write data to
;    R1 = area to read data from
;    R2 = total X size
;    R3 = total Y size
;    [R13,#0] = other session flags
;
; On exit
;    R0 = last address in R0 written to
;
;    Can corrupt R1-R3, R12, (R14)
;    Must preserve R4-R11

	STMFD   R13!,{R4-R10}

        LDR     R12,[R13,#0] ; get session flags from stack

	ADD     R4,R3,#1
	MOV     R4,R4,LSL#2 ; R4 is current_pointer%
	MOV     R5,#0 ; y_loop
code_y_loop
	MOV     R6,R5,LSL#2 ; y_loop*4
	STR     R4,[R0,R6]
	ADD     R9,R4,R0
	MOV     R6,R2 ; x_loop
	MUL     R7,R2,R5 ; y_loop*terminal_size_x
	MOV     R7,R7,LSL#2 ; *4
	ADD     R7,R7,R1
code_x_loop
	LDRB    R10,[R7,#2]
	TST     R10,#1 ; cursor bit
	BNE     code_draw_cursor ; branch if bit 0 is set

	MOV     R8,#0
	STRB    R8,[R9],#1   ; 0

	MOV     R8,#1
	STRB    R8,[R9],#1   ; 1

	AND	R8,R12,#128		; reverse video
	TST	R10,#4			; invert bit
	EORNE	R8,R8,#128
	TST	R10,#16 		; selected bit
	EORNE	R8,R8,#128
	TST     R8,#128 		; are we inverted?
	LDRB    R8,[R7],#1
	STRNEB  R8,[R9,#1]   		; foreground
	STREQB  R8,[R9],#1   		; foreground inverted
	LDRB    R8,[R7],#1
	STRNEB  R8,[R9],#2   		; background
	STREQB  R8,[R9],#1   		; background inverted

	LDRB    R8,[R7],#1   ; flags (dealt with elsewhere)

	TST     R10,#8       ; set if +&100

	; if not set
	LDREQB  R8,[R7],#1
	STREQB  R8,[R9],#1   ; byte
	ADDEQ   R4,R4,#5

	; if set

	MOVNE   R8,#0
	STRNEB  R8,[R9],#1 ; 0
	MOVNE   R8,#3
	STRNEB  R8,[R9],#1 ; 3

	LDRNE   R8,[R7],#1
	STRNEB  R8,[R9],#1 ; byte
	MOVNE   R8,#&01
	STRNEB  R8,[R9],#1 ; &100+
	ADDNE   R4,R4,#8

	B       code_next_stage

code_draw_cursor

	MOV     R8,#0
	STRB    R8,[R9],#1 ; 0

	MOV     R8,#4
	STRB    R8,[R9],#1 ; 4

	LDRB    R8,[R7],#1
	STRB    R8,[R9,#1] ; foreground

	LDRB    R8,[R7],#1
	STRB    R8,[R9],#2 ; background

	LDRB    R8,[R7],#1 ; flags (dealt with elsewhere)

	TST     R10,#8     ; +&100 bit
	LDREQB  R8,[R7],#1
	STREQB  R8,[R9],#1 ; character
	ADDEQ   R4,R4,#9

	MOVNE   R8,#0
	STRNEB  R8,[R9],#1 ; 0
	MOVNE   R8,#3
	STRNEB  R8,[R9],#1 ; 3

	LDRNE   R8,[R7],#1
	STRNEB  R8,[R9],#1 ; byte
	MOVNE   R8,#&01
	STRNEB  R8,[R9],#1 ; &100+
	ADDNE   R4,R4,#12

	MOV     R8,#0
	STRB    R8,[R9],#1 ; 0
	MOV     R8,#3
	STRB    R8,[R9],#1 ; 3

	TST     R10,#2     ; got cursor bit
	MOVEQ   R8,#&00
	STREQB  R8,[R9],#1 ; &100
	MOVEQ   R8,#&01
	STREQB  R8,[R9],#1 ;

	MOVNE   R8,#&01
	STRNEB  R8,[R9],#1 ; &101
	MOVNE   R8,#&01
	STRNEB  R8,[R9],#1 ;

code_next_stage

	SUBS    R6,R6,#1
	BNE     code_x_loop

	MOV     R8,#0
	STRB    R8,[R9],#1

	MOV     R8,#2
	STRB    R8,[R9],#1

	ADD     R4,R4,#2

	ADD     R5,R5,#1
	CMP     R5,R3
	BNE     code_y_loop

	MOV     R6,R5,LSL#2 ; y_loop*4
	MOV     R8,#0
	STR     R8,[R0,R6]

	MOV     R0,R4 ; put last addr written to in R0

	LDMFD   R13!,{R4-R10}

	MOV     PC,R14

	END
