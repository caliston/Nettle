; zapgen.s
;


;R0	rn	0
;R1	rn	1
;R2	rn	2
;R3	rn	3
;R4	rn	4
;R5	rn	5
;R6	rn	6
;R7	rn	7
;R8	rn	8
;R9	rn	9
;R10	rn	10
;R11	rn	11
;R12	rn	12
;R13	rn	13
;R14	rn	14
;PC	rn	15


	AREA	|C$$code|, CODE, READONLY

	EXPORT	zapgen_code


zapgen_code

; On entry
;    R0 = area to write data to
;    R1 = area to read data from
;    R2 = total X size
;    R3 = total Y size
;    [R13, #0] = other session flags
;
; On exit
;    R0 = last address in R0 written to
;
;    Can corrupt R1-R3, R12, (R14)
;    Must preserve R4-R11

	STMFD	r13!, {r4-r10}

	LDR	r12, [r13, #28]		; get session flags from stack
					; Note that this will change if
					; function entry stack use is
					; changed.

	ADD	r4, r3, #1
	MOV	r4, r4, LSL #2		; R4 is current_pointer%
	MOV	r5, #0			; y_loop
code_y_loop
	MOV	r6, r5, LSL #2		; y_loop*4
	STR	r4, [r0, r6]
	ADD	r9, r4, r0
	MOV	r6, r2			; x_loop
	MUL	r7, r2, r5		; y_loop*terminal_size_x
	MOV	r7, r7, LSL #2		; *4
	ADD	r7, r7, r1
code_x_loop
	LDRB	r10, [r7, #2]
	TST	r10, #1			; cursor bit
	BNE	code_draw_cursor	; branch if bit 0 is set

	MOV	r8, #0
	STRB	r8, [r9], #1		; 0

	MOV	r8, #1
	STRB	r8, [r9], #1		; 1

	AND	r8, r12, #128		; reverse video
	TST	r10, #4			; invert bit
	EORNE	r8, r8, #128
	TST	r10, #16		; selected bit
	EORNE	r8, r8, #128
	TST	r8, #128		; are we inverted?
	LDRB	r8, [r7], #1
	STRNEB  r8, [r9, #1]		; foreground
	STREQB  r8, [r9], #1		; foreground inverted
	LDRB	r8, [r7], #1
	STRNEB  r8, [r9], #2		; background
	STREQB  r8, [r9], #1		; background inverted

	LDRB	r8, [r7], #1		; flags (dealt with elsewhere)

	TST	r10, #8			; set if +&100

	; if not set
	LDREQB  r8, [r7], #1
	STREQB  r8, [r9], #1		; byte
	ADDEQ	r4, r4, #5

	; if set

	MOVNE	r8, #0
	STRNEB  r8, [r9], #1		; 0
	MOVNE	r8, #3
	STRNEB  r8, [r9], #1		; 3

	LDRNE	r8, [r7], #1
	STRNEB  r8, [r9], #1		; byte
	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		; &100+
	ADDNE	r4, r4, #8

	B	code_next_stage

code_draw_cursor

	MOV	r8, #0
	STRB	r8, [r9], #1		; 0

	MOV	r8, #4
	STRB	r8, [r9], #1		; 4

	LDRB	r8, [r7], #1
	STRB	r8, [r9, #1]		; foreground

	LDRB	r8, [r7], #1
	STRB	r8, [r9], #2		; background

	LDRB	r8, [r7], #1		; flags (dealt with elsewhere)

	TST	r10, #8			; +&100 bit
	LDREQB  r8, [r7], #1
	STREQB  r8, [r9], #1		; character
	ADDEQ	r4, r4, #9

	MOVNE	r8, #0
	STRNEB  r8, [r9], #1		; 0
	MOVNE	r8, #3
	STRNEB  r8, [r9], #1		; 3

	LDRNE	r8, [r7], #1
	STRNEB  r8, [r9], #1		; byte
	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		; &100+
	ADDNE	r4, r4, #12

	MOV	r8, #0
	STRB	r8, [r9], #1		; 0
	MOV	r8, #3
	STRB	r8, [r9], #1		; 3

	TST	r10, #2			; got cursor bit
	MOVEQ	r8, #&00
	STREQB  r8, [r9], #1		; &100
	MOVEQ	r8, #&01
	STREQB  r8, [r9], #1		;

	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		; &101
	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		;

code_next_stage

	SUBS	r6, r6, #1
	BNE	code_x_loop

	MOV	r8, #0
	STRB	r8, [r9], #1

	MOV	r8, #2
	STRB	r8, [r9], #1

	ADD	r4, r4, #2

	ADD	r5, r5, #1
	CMP	r5, r3
	BNE	code_y_loop

	MOV	r6, r5, LSL #2		; y_loop*4
	MOV	r8, #0
	STR	r8, [r0,r6]

	MOV	r0, r4			; put last addr written to in R0

	LDMFD	r13!, {r4-r10}

	MOV	pc, r14


	END
