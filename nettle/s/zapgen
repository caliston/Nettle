;
; Nettle zapgen code
; (C) Nettle developers 2000-2001
; $Id$
;


r0	RN	0
r1	RN	1
r2	RN	2
r3	RN	3
r4	RN	4
r5	RN	5
r6	RN	6
r7	RN	7
r8	RN	8
r9	RN	9
r10	RN	10
r11	RN	11
r12	RN	12
r13	RN	13
r14	RN	14
pc	RN	15


	AREA	|C$$code|, CODE, READONLY

	EXPORT	zapgen_code


zapgen_code

; On entry
;    R0 = area to write data to
;    R1 = area to read data from
;    R2 = total X size
;    R3 = total Y size
;    [R13, #0] = other session flags
;
; On exit
;    R0 = last address in R0 written to
;
;    Can corrupt R1-R3, R12, (R14)
;    Must preserve R4-R11

	STMFD	r13!, {r4-r10, r14}

	LDR	r12, [r13, #32]		; get session flags from stack
					; Note that this will change if
					; function entry stack use is
					; changed.

	ADD	r4, r3, #1
	MOV	r4, r4, LSL #2		; R4 is current_pointer%
	MOV	r5, #0			; y_loop
code_y_loop
	MOV	r6, r5, LSL #2		; y_loop*4
	STR	r4, [r0, r6]
	ADD	r9, r4, r0
	MOV	r6, r2			; x_loop
	MUL	r7, r2, r5		; y_loop*terminal_size_x
	MOV	r7, r7, LSL #2		; *4
	ADD	r7, r7, r1

	STMFD	r13!, {r0-r3}		; scratch space

	MOV	r2, #&100
	MOV	r3, #&100		; initial colour information

code_x_loop
	LDRB	r0, [r7], #1		; foreground
	LDRB	r1, [r7], #1		; background
	LDRB	r10, [r7], #1		; flags
	BL	colour_change

	TST	r10, #1			; cursor bit
	BNE	code_draw_cursor	; branch if bit 0 is set

	BL	write_character

	SUBS	r6, r6, #1
	BNE	code_x_loop
	B	code_next_stage

code_draw_cursor
	MOV	r8, #0
	STRB	r8, [r9], #1		; 0

	MOV	r8, #8
	STRB	r8, [r9], #1		; 8

	STRB	r1, [r9], #1		; foreground (well, background)

	TST	r1, #2			; select contrasting background
	MOVEQ	r8, #7
	MOVNE	r8, #0
	TST	r1, #8
	ORREQ	r8, r8, #8		; set bright if bg *not* bright
	STRB	r8, [r9], #1

	BL	write_character		; the charadcter under the cursor

	TST	r10, #2			; test cursor bit
	MOVEQ	r8, #&7F
	STREQB	r8, [r9], #1		; 0: write &7F
	MOVNE	r8, #1
	BLNE	multibyte		; 1: write &101

	SUBS	r6, r6, #1
	BNE	code_x_loop

code_next_stage

	LDMFD	r13!, {r0-r3}

	MOV	r8, #0
	STRB	r8, [r9], #1

	MOV	r8, #2
	STRB	r8, [r9], #1

	SUB	r4, r9, r0		; update R4

	ADD	r5, r5, #1
	CMP	r5, r3
	BNE	code_y_loop

	MOV	r6, r5, LSL #2		; y_loop*4
	MOV	r8, #0
	STR	r8, [r0,r6]

	MOV	r0, r4			; put last addr written to in R0

	LDMFD	r13!, {r4-r10, pc}


colour_change
;
; On entry
;	R0 = new foreground
;	R1 = new background
;	R2 = old foreground
;	R3 = old background
;	R9 -> Zap data buffer
;	R10 = character flags
;	R12 = session flags
;
; On exit
;	R2, R3, R9 updated & colour control written if needed
;	Can corrupt R0, R1, R8

	TEQ	r0, r2
	TEQEQ	r1, r3
	MOVEQ	pc, r14			; quick abort

	MOV	r8, #0			; control prefix
	STRB	r8, [r9], #1

	AND	r8, r12, #128		; reverse video
	TST	r10, #4			; invert bit
	EORNE	r8, r8, #128
	TST	r10, #16		; selected bit
	EORNE	r8, r8, #128
	TST	r8, #128		; are we inverted?
	EORNE	r0, r0, r1
	EORNE	r1, r0, r1
	EORNE	r0, r0, r1		; exchange colours if so

	MOV	r8, #1			; change both colours
	TEQ	r0, r2
	MOVEQ	r8, #7			; or just the background (fg same)
	TEQ	r1, r3
	MOVEQ	r8, #6			; or just the foreground (bg same)
	STRB	r8, [r9], #1

	TEQ	r8, #1
	TEQNE	r8, #6
	STREQB	r0, [r9], #1		; changing the foreground

	TEQ	r8, #1
	TEQNE	r8, #7
	STREQB	r1, [r9], #1		; changing the background

	MOV	r2, r0			; update foreground
	MOV	r3, r1			; update background

	MOV	pc, r14


write_character
;
; On entry
;	R7 -> character
;	R9 -> Zap data buffer
;	R10 = character flags
;
; On exit
;	R7 += 1
;	R9 updated, character stored
;	Will corrupt R8

	LDRB	r8, [r7], #1
	TST	r10, #8			; set if +&100
	BNE	multibyte

	; if not set
	STRB	r8, [r9], #1		; byte
	TEQ	r8, #0
	STREQB	r8, [r9], #1		; extra byte if NUL
	MOV	pc, r14

multibyte
	; if set
	STRB	r8, [r9, #2]		; byte
	MOV	r8, #0
	STRB	r8, [r9], #1		; 0
	MOV	r8, #3
	STRB	r8, [r9], #2		; 3  (& skip byte)
	MOV	r8, #&01
	STRB	r8, [r9], #1		; &100+
	MOV	pc, r14



	END
