;
; Nettle zapgen code
; (C) Nettle developers 2000-2001
; $Id$
;


r0	RN	0
r1	RN	1
r2	RN	2
r3	RN	3
r4	RN	4
r5	RN	5
r6	RN	6
r7	RN	7
r8	RN	8
r9	RN	9
r10	RN	10
r11	RN	11
r12	RN	12
r13	RN	13
r14	RN	14
pc	RN	15


	AREA	|C$$code|, CODE, READONLY

	EXPORT	zapgen_code


zapgen_code

; On entry
;    R0 = area to write data to
;    R1 = area to read data from
;    R2 = total X size
;    R3 = total Y size
;    [R13, #0] = other session flags
;
; On exit
;    R0 = last address in R0 written to
;
;    Can corrupt R1-R3, R12, (R14)
;    Must preserve R4-R11

	LDR	r12, [r13]              ; pull session flags
	STMFD	r13!, {r4-r10, r14}

	ADD	r4, r3, #1
	MOV	r4, r4, LSL #2		; 8 bytes per char
	MOV	r5, #0			; y_loop
code_y_loop
	MOV	r6, r5, LSL #2		; y_loop*4
	STR	r4, [r0, r6]
	ADD	r9, r4, r0
	MOV	r6, r2			; x_loop
	MUL	r7, r2, r5		; y_loop*terminal_size_x
	MOV	r7, r7, LSL #2		; *4
	ADD	r7, r7, r1
code_x_loop
	LDRB	r10, [r7, #2]
	TST	r10, #1			; cursor bit
	BNE	code_draw_cursor	; branch if bit 0 is set

	MOV	r8, #0
	STRB	r8, [r9], #1		; 0

	MOV	r8, #1
	STRB	r8, [r9], #1		; 1

	AND	r8, r12, #128		; reverse video
	TST	r10, #4			; invert bit
	EORNE	r8, r8, #128
	TST	r10, #16		; selected bit
	EORNE	r8, r8, #128
	TST	r8, #128		; are we inverted?
	LDRB	r8, [r7], #1
	STRNEB  r8, [r9, #1]		; foreground
	STREQB  r8, [r9], #1		; foreground inverted
	LDRB	r8, [r7], #1
	STRNEB  r8, [r9], #2		; background
	STREQB  r8, [r9], #1		; background inverted

	LDRB	r8, [r7], #1		; flags (dealt with elsewhere)

	TST	r10, #8			; set if +&100

	; if not set
	LDREQB  r8, [r7], #1
	STREQB  r8, [r9], #1		; byte
	ADDEQ	r4, r4, #5

	; if set

	MOVNE	r8, #0
	STRNEB  r8, [r9], #1		; 0
	MOVNE	r8, #3
	STRNEB  r8, [r9], #1		; 3

	LDRNE	r8, [r7], #1
	STRNEB  r8, [r9], #1		; byte
	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		; &100+
	ADDNE	r4, r4, #8

	B	code_next_stage

code_draw_cursor

	MOV	r8, #0
	STRB	r8, [r9], #1		; 0

	MOV	r8, #4
	STRB	r8, [r9], #1		; 4

	LDRB	r8, [r7], #1
	STRB	r8, [r9, #1]		; foreground

	LDRB	r8, [r7], #1
	STRB	r8, [r9], #2		; background

	LDRB	r8, [r7], #1		; flags (dealt with elsewhere)

	TST	r10, #8			; +&100 bit
	LDREQB  r8, [r7], #1
	STREQB  r8, [r9], #1		; character
	ADDEQ	r4, r4, #9

	MOVNE	r8, #0
	STRNEB  r8, [r9], #1		; 0
	MOVNE	r8, #3
	STRNEB  r8, [r9], #1		; 3

	LDRNE	r8, [r7], #1
	STRNEB  r8, [r9], #1		; byte
	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		; &100+
	ADDNE	r4, r4, #12

	MOV	r8, #0
	STRB	r8, [r9], #1		; 0
	MOV	r8, #3
	STRB	r8, [r9], #1		; 3

	TST	r10, #2			; got cursor bit
	MOVEQ	r8, #&00
	STREQB  r8, [r9], #1		; &100
	MOVEQ	r8, #&01
	STREQB  r8, [r9], #1		;

	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		; &101
	MOVNE	r8, #&01
	STRNEB  r8, [r9], #1		;

code_next_stage

	SUBS	r6, r6, #1
	BNE	code_x_loop

	MOV	r8, #0
	STRB	r8, [r9], #1

	MOV	r8, #2
	STRB	r8, [r9], #1

	ADD	r4, r4, #2

	ADD	r5, r5, #1
	CMP	r5, r3
	BNE	code_y_loop

	MOV	r6, r5, LSL #2		; y_loop*4
	MOV	r8, #0
	STR	r8, [r0,r6]

	MOV	r0, r4			; put last addr written to in R0

	LDMFD	r13!, {r4-r10, r14}

	END
